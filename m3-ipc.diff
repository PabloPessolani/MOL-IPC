diff -Naur /home/jara/linux-2.6.32/arch/x86/include/asm/irq_vectors.h /usr/src/linux/arch/x86/include/asm/irq_vectors.h
--- /home/jara/linux-2.6.32/arch/x86/include/asm/irq_vectors.h	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/arch/x86/include/asm/irq_vectors.h	2013-08-28 10:03:38.000000000 -0300
@@ -36,6 +36,9 @@
 #ifdef CONFIG_X86_32
 # define SYSCALL_VECTOR			0x80
 # define IA32_SYSCALL_VECTOR		0x80
+/* jara */
+# define MINIX_SYSCALL_VECTOR   	0x90
+/* fin jara */
 #else
 # define IA32_SYSCALL_VECTOR		0x80
 #endif
diff -Naur /home/jara/linux-2.6.32/arch/x86/kernel/entry_32.S /usr/src/linux/arch/x86/kernel/entry_32.S
--- /home/jara/linux-2.6.32/arch/x86/kernel/entry_32.S	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/arch/x86/kernel/entry_32.S	2012-08-13 12:42:00.000000000 -0300
@@ -53,6 +53,7 @@
 #include <asm/processor-flags.h>
 #include <asm/ftrace.h>
 #include <asm/irq_vectors.h>
+#include "../../../kernel/minix/kipc.h"
 
 /* Avoid __ASSEMBLER__'ifying <linux/audit.h> just for this.  */
 #include <linux/elf-em.h>
@@ -78,6 +79,7 @@
  */
 
 #define nr_syscalls ((syscall_table_size)/4)
+#define nr_molcalls NR_MOLCALLS
 
 #ifdef CONFIG_PREEMPT
 #define preempt_stop(clobbers)	DISABLE_INTERRUPTS(clobbers); TRACE_IRQS_OFF
@@ -513,6 +515,31 @@
 	PTGS_TO_GS_EX
 ENDPROC(ia32_sysenter_target)
 
+/*
+* MINIX IPC primitives
+*/
+.pushsection .kprobes.text, "ax"
+# Minix IPC handler stub
+ENTRY(minix_ipc)
+    RING0_INT_FRAME   # can't unwind into user space anyway
+    pushl %eax    # save orig_eax
+    CFI_ADJUST_CFA_OFFSET 4
+    SAVE_ALL
+    GET_THREAD_INFO(%ebp)
+        # system call tracing in operation / emulation
+    testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)
+    jnz syscall_trace_entry
+    cmpl $(nr_molcalls), %eax
+    jae syscall_badsys
+minix_ipc_call:
+    call *mol_sys_call_table(,%eax,4)
+#    movl $3333,%eax
+    movl %eax,PT_EAX(%esp)    # store the return value
+minix_ipc_exit:
+    jmp syscall_exit
+    CFI_ENDPROC
+ENDPROC(minix_ipc)
+
 	# system call handler stub
 ENTRY(system_call)
 	RING0_INT_FRAME			# can't unwind into user space anyway
@@ -1200,6 +1227,8 @@
 
 .section .rodata,"a"
 #include "syscall_table_32.S"
+#include "mol_syscall_table_32.S"
+
 
 syscall_table_size=(.-sys_call_table)
 
diff -Naur /home/jara/linux-2.6.32/arch/x86/kernel/mol_syscall_table_32.S /usr/src/linux/arch/x86/kernel/mol_syscall_table_32.S
--- /home/jara/linux-2.6.32/arch/x86/kernel/mol_syscall_table_32.S	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/arch/x86/kernel/mol_syscall_table_32.S	2013-10-07 19:24:42.000000000 -0300
@@ -0,0 +1,53 @@
+ENTRY(mol_sys_call_table)
+	.long mol_vm_init		/* 0 */
+/* Standard MINIX IPC functions that match MINIX IPC numbers */
+	.long mol_mini_send		/* 1 */
+	.long mol_mini_receive		/* 2 */
+	.long mol_void			/* 5 */
+	.long mol_mini_notify		/* 4 */ 
+/* void functions, funct# < 8 that can be used in the future */
+	.long mol_mini_sendrec		/* 3 */ 
+	.long mol_mini_rcvrqst		/* 6 */
+	.long mol_mini_reply		/* 7 */
+/* VMM system calls, funct# >= 8 to use a mask */
+	.long mol_vm_end		/* 8 */
+	.long mol_bind			/* 9 */
+	.long mol_unbind		/* 10 */
+	.long mol_vm_dump		/* 11 */
+	.long mol_proc_dump		/* 12 */
+	.long mol_getpriv		/* 13 get priviledges */
+	.long mol_setpriv		/* 14 seg priviledges */
+	.long mol_vcopy			/* 15 copy data between user-user or user-kernel */
+	.long mol_getvminfo		/* 16 */
+	.long mol_getprocinfo		/* 17 */
+	.long mol_void			/* 18- used for mol_rmtbind */
+	.long mol_mini_relay		/* 19 */
+	.long mol_proxies_bind		/* 20 */
+	.long mol_proxies_unbind	/* 21 */
+	.long mol_getnodeinfo		/* 22 */
+	.long mol_put2lcl		/* 23 */
+	.long mol_get2rmt		/* 24 */
+	.long mol_add_node		/* 25 */
+	.long mol_del_node		/* 26 */
+	.long mol_drvs_init		/* 27 */
+	.long mol_drvs_end		/* 28 */
+	.long mol_getep			/* 29 */
+	.long mol_getdrvsinfo		/* 30 */
+	.long mol_proxy_conn		/* 31 */
+	.long mol_wait4bind		/* 32 */
+	.long mol_migrate		/* 33 */
+	.long mol_node_up		/* 34 */
+	.long mol_node_down		/* 35 */
+	.long mol_getproxyinfo	/* 36 */
+
+
+	
+	
+	
+
+
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/arch/x86/kernel/traps.c /usr/src/linux/arch/x86/kernel/traps.c
--- /home/jara/linux-2.6.32/arch/x86/kernel/traps.c	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/arch/x86/kernel/traps.c	2012-08-05 20:12:25.000000000 -0300
@@ -66,6 +66,7 @@
 #include <asm/setup.h>
 
 asmlinkage int system_call(void);
+asmlinkage int minix_ipc(void);
 
 /* Do we ignore FPU interrupts ? */
 char ignore_fpu_irq;
@@ -962,6 +963,11 @@
 
 	set_system_trap_gate(SYSCALL_VECTOR, &system_call);
 	set_bit(SYSCALL_VECTOR, used_vectors);
+	
+		/* jara metiendo mano */
+	set_system_intr_gate(MINIX_SYSCALL_VECTOR, &minix_ipc);
+	set_bit(MINIX_SYSCALL_VECTOR, used_vectors);
+	
 #endif
 
 	/*
diff -Naur /home/jara/linux-2.6.32/.config /usr/src/linux/.config
--- /home/jara/linux-2.6.32/.config	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/.config	2014-03-01 13:46:46.000000000 -0300
@@ -0,0 +1,2685 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32
+# Sat Mar  1 13:46:46 2014
+#
+# CONFIG_64BIT is not set
+CONFIG_X86_32=y
+# CONFIG_X86_64 is not set
+CONFIG_X86=y
+CONFIG_OUTPUT_FORMAT="elf32-i386"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_TIME_VSYSCALL is not set
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+# CONFIG_HAVE_CPUMASK_OF_CPU_MAP is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ZONE_DMA32 is not set
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+# CONFIG_AUDIT_ARCH is not set
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_X86_32_SMP=y
+CONFIG_X86_HT=y
+CONFIG_X86_TRAMPOLINE=y
+CONFIG_X86_32_LAZY_GS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_USER_SCHED is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_NS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP=y
+CONFIG_MM_OWNER=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+CONFIG_RELAY=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_X86_MPPARSE=y
+# CONFIG_X86_BIGSMP is not set
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_MRST is not set
+# CONFIG_X86_RDC321X is not set
+CONFIG_X86_32_NON_STANDARD=y
+# CONFIG_X86_NUMAQ is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_X86_SUMMIT is not set
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_PARAVIRT_GUEST is not set
+# CONFIG_MEMTEST is not set
+CONFIG_X86_CYCLONE_TIMER=y
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+CONFIG_M686=y
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+# CONFIG_GENERIC_CPU is not set
+CONFIG_X86_GENERIC=y
+CONFIG_X86_CPU=y
+CONFIG_X86_L1_CACHE_BYTES=64
+CONFIG_X86_INTERNODE_CACHE_BYTES=64
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_X86_XADD=y
+CONFIG_X86_PPRO_FENCE=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=5
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_CYRIX_32=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_CPU_SUP_TRANSMETA_32=y
+CONFIG_CPU_SUP_UMC_32=y
+# CONFIG_X86_DS is not set
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+# CONFIG_IOMMU_HELPER is not set
+# CONFIG_IOMMU_API is not set
+CONFIG_NR_CPUS=8
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_ANCIENT_MCE=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+CONFIG_VM86=y
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+CONFIG_X86_REBOOTFIXUPS=y
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_X86_MSR=y
+CONFIG_X86_CPUID=y
+# CONFIG_X86_CPU_DEBUG is not set
+# CONFIG_NOHIGHMEM is not set
+CONFIG_HIGHMEM4G=y
+# CONFIG_HIGHMEM64G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_HIGHMEM=y
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_MEMORY_FAILURE is not set
+CONFIG_HIGHPTE=y
+CONFIG_X86_CHECK_BIOS_CORRUPTION=y
+CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
+CONFIG_X86_RESERVE_LOW_64K=y
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+# CONFIG_MTRR_SANITIZER is not set
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_EFI=y
+CONFIG_SECCOMP=y
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+CONFIG_HZ_1000=y
+CONFIG_HZ=1000
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+# CONFIG_KEXEC_JUMP is not set
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+CONFIG_X86_NEED_RELOCS=y
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_VERBOSE is not set
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_TRACE=y
+CONFIG_PM_TRACE_RTC=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HIBERNATION_NVS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+# CONFIG_PM_RUNTIME is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+# CONFIG_ACPI_POWER_METER is not set
+CONFIG_ACPI_SYSFS_POWER=y
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_VIDEO=y
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_HOTPLUG_CPU=y
+# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
+CONFIG_ACPI_THERMAL=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+# CONFIG_ACPI_DEBUG is not set
+# CONFIG_ACPI_PCI_SLOT is not set
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+# CONFIG_ACPI_SBS is not set
+# CONFIG_SFI is not set
+# CONFIG_APM is not set
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_DEBUG=y
+# CONFIG_CPU_FREQ_STAT is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPUFreq processor drivers
+#
+CONFIG_X86_ACPI_CPUFREQ=y
+# CONFIG_X86_POWERNOW_K6 is not set
+# CONFIG_X86_POWERNOW_K7 is not set
+# CONFIG_X86_POWERNOW_K8 is not set
+# CONFIG_X86_GX_SUSPMOD is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_SPEEDSTEP_ICH is not set
+# CONFIG_X86_SPEEDSTEP_SMI is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+# CONFIG_X86_CPUFREQ_NFORCE2 is not set
+# CONFIG_X86_LONGRUN is not set
+# CONFIG_X86_LONGHAUL is not set
+# CONFIG_X86_E_POWERSAVER is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+# CONFIG_PCI_GOOLPC is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_DMAR is not set
+CONFIG_PCIEPORTBUS=y
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+# CONFIG_PCIEASPM is not set
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_LEGACY is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_HT_IRQ=y
+# CONFIG_PCI_IOV is not set
+CONFIG_ISA_DMA_API=y
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+# CONFIG_OLPC is not set
+CONFIG_K8_NB=y
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_CARDBUS=y
+
+#
+# PC-card bridges
+#
+CONFIG_YENTA=y
+CONFIG_YENTA_O2=y
+CONFIG_YENTA_RICOH=y
+CONFIG_YENTA_TI=y
+CONFIG_YENTA_ENE_TUNE=y
+CONFIG_YENTA_TOSHIBA=y
+# CONFIG_PD6729 is not set
+# CONFIG_I82092 is not set
+CONFIG_PCCARD_NONSTATIC=y
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_FAKE is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ is not set
+# CONFIG_HOTPLUG_PCI_IBM is not set
+# CONFIG_HOTPLUG_PCI_ACPI is not set
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+# CONFIG_INET_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_DEFAULT_BIC is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_HTCP is not set
+# CONFIG_DEFAULT_VEGAS is not set
+# CONFIG_DEFAULT_WESTWOOD is not set
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_NETLABEL=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_MATCH_IPV6HEADER=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_MANGLE=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+CONFIG_TIPC=y
+CONFIG_TIPC_ADVANCED=y
+CONFIG_TIPC_ZONES=3
+CONFIG_TIPC_CLUSTERS=1
+CONFIG_TIPC_NODES=255
+CONFIG_TIPC_SLAVE_NODES=0
+CONFIG_TIPC_PORTS=8191
+CONFIG_TIPC_LOG=0
+# CONFIG_TIPC_DEBUG is not set
+# CONFIG_ATM is not set
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_INGRESS is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+# CONFIG_AX25 is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_CFG80211_DEFAULT_PS_VALUE=1
+# CONFIG_CFG80211_DEBUGFS is not set
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+# CONFIG_MAC80211_MESH is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_LEDS=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+# CONFIG_MTD is not set
+CONFIG_PARPORT=y
+CONFIG_PARPORT_PC=y
+# CONFIG_PARPORT_SERIAL is not set
+# CONFIG_PARPORT_PC_FIFO is not set
+# CONFIG_PARPORT_PC_SUPERIO is not set
+# CONFIG_PARPORT_PC_PCMCIA is not set
+# CONFIG_PARPORT_GSC is not set
+# CONFIG_PARPORT_AX88796 is not set
+# CONFIG_PARPORT_1284 is not set
+CONFIG_PNP=y
+CONFIG_PNP_DEBUG_MESSAGES=y
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_SX8=y
+CONFIG_BLK_DEV_UB=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+CONFIG_HAVE_IDE=y
+CONFIG_IDE=y
+
+#
+# Please see Documentation/ide/ide.txt for help/info on IDE drives
+#
+CONFIG_IDE_XFER_MODE=y
+CONFIG_IDE_TIMINGS=y
+CONFIG_IDE_ATAPI=y
+CONFIG_BLK_DEV_IDE_SATA=y
+CONFIG_IDE_GD=y
+CONFIG_IDE_GD_ATA=y
+# CONFIG_IDE_GD_ATAPI is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_DELKIN is not set
+CONFIG_BLK_DEV_IDECD=y
+CONFIG_BLK_DEV_IDECD_VERBOSE_ERRORS=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEACPI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+CONFIG_IDE_PROC_FS=y
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_PLATFORM=y
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_IDEPNP is not set
+CONFIG_BLK_DEV_IDEDMA_SFF=y
+
+#
+# PCI IDE chipsets support
+#
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_PCIBUS_ORDER=y
+# CONFIG_BLK_DEV_GENERIC is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+CONFIG_BLK_DEV_AMD74XX=y
+# CONFIG_BLK_DEV_ATIIXP is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_CS5535 is not set
+# CONFIG_BLK_DEV_CS5536 is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_JMICRON is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT8172 is not set
+# CONFIG_BLK_DEV_IT8213 is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_BLK_DEV_TC86C001 is not set
+CONFIG_BLK_DEV_IDEDMA=y
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=y
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+CONFIG_CHR_DEV_OSST=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=y
+CONFIG_SCSI_SAS_LIBSAS=y
+# CONFIG_SCSI_SAS_ATA is not set
+CONFIG_SCSI_SAS_HOST_SMP=y
+CONFIG_SCSI_SAS_LIBSAS_DEBUG=y
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+CONFIG_SCSI_AIC94XX=y
+# CONFIG_AIC94XX_DEBUG is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_PPA is not set
+# CONFIG_SCSI_IMM is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+CONFIG_SCSI_DH=y
+# CONFIG_SCSI_DH_RDAC is not set
+# CONFIG_SCSI_DH_HP_SW is not set
+# CONFIG_SCSI_DH_EMC is not set
+# CONFIG_SCSI_DH_ALUA is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_PMP=y
+CONFIG_SATA_AHCI=y
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_SVW is not set
+CONFIG_ATA_PIIX=y
+CONFIG_SATA_MV=y
+CONFIG_SATA_NV=y
+CONFIG_PDC_ADMA=y
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_SATA_SIL=y
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_ULI is not set
+CONFIG_SATA_VIA=y
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_PATA_ACPI is not set
+CONFIG_PATA_ALI=y
+CONFIG_PATA_AMD=y
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5535 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+CONFIG_ATA_GENERIC=y
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_MARVELL is not set
+CONFIG_PATA_MPIIX=y
+CONFIG_PATA_OLDPIIX=y
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PCMCIA is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+CONFIG_PATA_SCH=y
+# CONFIG_MD is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# You can enable one or both FireWire driver stacks.
+#
+
+#
+# See the help texts for more information.
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_VETH=y
+# CONFIG_NET_SB1000 is not set
+# CONFIG_ARCNET is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+# CONFIG_ETHOC is not set
+# CONFIG_DNET is not set
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+# CONFIG_TULIP is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_ULI526X is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_HP100 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+CONFIG_AMD8111_ETH=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+CONFIG_FORCEDETH=y
+# CONFIG_FORCEDETH_NAPI is not set
+CONFIG_E100=y
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+CONFIG_NE2K_PCI=y
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_R6040 is not set
+# CONFIG_SIS900 is not set
+CONFIG_EPIC100=y
+CONFIG_SMSC9420=y
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+# CONFIG_NET_POCKET is not set
+# CONFIG_ATL2 is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+CONFIG_E1000=y
+CONFIG_E1000E=y
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_R8169=y
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+CONFIG_SKY2=y
+# CONFIG_SKY2_DEBUG is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_TIGON3=y
+CONFIG_BNX2=y
+# CONFIG_CNIC is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_JME is not set
+CONFIG_NETDEV_10000=y
+# CONFIG_CHELSIO_T1 is not set
+CONFIG_CHELSIO_T3_DEPENDS=y
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_ENIC is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_NIU is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_BNX2X is not set
+# CONFIG_QLGE is not set
+# CONFIG_SFC is not set
+# CONFIG_BE2NET is not set
+CONFIG_TR=y
+# CONFIG_IBMOL is not set
+# CONFIG_IBMLS is not set
+# CONFIG_3C359 is not set
+# CONFIG_TMS380TR is not set
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+# CONFIG_PCMCIA_PCNET is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_WAN is not set
+CONFIG_FDDI=y
+# CONFIG_DEFXX is not set
+# CONFIG_SKFP is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+CONFIG_NETCONSOLE=y
+# CONFIG_NETCONSOLE_DYNAMIC is not set
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_VMXNET3=y
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_DB9 is not set
+# CONFIG_JOYSTICK_GAMECON is not set
+# CONFIG_JOYSTICK_TURBOGRAFX is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+# CONFIG_JOYSTICK_WALKERA0701 is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_WACOM is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_APANEL is not set
+# CONFIG_INPUT_WISTRON_BTNS is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_WINBOND_CIR is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_SYNCLINK_GT is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_STALDRV is not set
+# CONFIG_NOZOMI is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_PNP=y
+# CONFIG_SERIAL_8250_CS is not set
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DETECT_IRQ=y
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_PRINTER is not set
+# CONFIG_PPDEV is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_GEODE=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_NVRAM=y
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_IPWIRELESS is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_CS5535_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+# CONFIG_HPET_MMAP is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_I801=y
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_I2C_SCMI is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Graphics adapter I2C/DDC channel drivers
+#
+# CONFIG_I2C_VOODOO3 is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_SENSORS_APPLESMC is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_SENSORS_ATK0110 is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_THERMAL=y
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_SC520_WDT is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_ITCO_WDT is not set
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_SBC8360_WDT is not set
+# CONFIG_SBC7240_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83697HF_WDT is not set
+# CONFIG_W83697UG_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+# CONFIG_AGP_ALI is not set
+# CONFIG_AGP_ATI is not set
+# CONFIG_AGP_AMD is not set
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=y
+# CONFIG_AGP_NVIDIA is not set
+# CONFIG_AGP_SIS is not set
+# CONFIG_AGP_SWORKS is not set
+# CONFIG_AGP_VIA is not set
+# CONFIG_AGP_EFFICEON is not set
+CONFIG_VGA_ARB=y
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_I810 is not set
+# CONFIG_DRM_I830 is not set
+CONFIG_DRM_I915=y
+# CONFIG_DRM_I915_KMS is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_VESA is not set
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I810 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_GEODE is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_PROGEAR is not set
+# CONFIG_BACKLIGHT_MBP_NVIDIA is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=64
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_SEQ_DUMMY=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_HRTIMER=y
+CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_DMA_SGBUF=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_PCSP is not set
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_MTS64 is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_PORTMAN2X4 is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5530 is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+CONFIG_SND_HDA_INTEL=y
+CONFIG_SND_HDA_HWDEP=y
+# CONFIG_SND_HDA_RECONFIG is not set
+# CONFIG_SND_HDA_INPUT_BEEP is not set
+# CONFIG_SND_HDA_INPUT_JACK is not set
+# CONFIG_SND_HDA_PATCH_LOADER is not set
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_SND_HDA_CODEC_ATIHDMI=y
+CONFIG_SND_HDA_CODEC_NVHDMI=y
+CONFIG_SND_HDA_CODEC_INTELHDMI=y
+CONFIG_SND_HDA_ELD=y
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_SND_HDA_CODEC_CA0110=y
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_SND_HDA_GENERIC=y
+# CONFIG_SND_HDA_POWER_SAVE is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_HIFIER is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SIS7019 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_USX2Y is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_US122L is not set
+CONFIG_SND_PCMCIA=y
+# CONFIG_SND_VXPOCKET is not set
+# CONFIG_SND_PDAUDIOCF is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_USS720 is not set
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_ALIX2 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_CLEVO_MAIL is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_BD2802 is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+# CONFIG_LEDS_TRIGGER_IDE_DISK is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC=y
+
+#
+# Reporting subsystems
+#
+# CONFIG_EDAC_DEBUG is not set
+CONFIG_EDAC_DECODE_MCE=y
+# CONFIG_EDAC_MM_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+# CONFIG_INTEL_IOATDMA is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACER_WMI is not set
+# CONFIG_ASUS_LAPTOP is not set
+# CONFIG_FUJITSU_LAPTOP is not set
+# CONFIG_TC1100_WMI is not set
+# CONFIG_MSI_LAPTOP is not set
+# CONFIG_PANASONIC_LAPTOP is not set
+# CONFIG_COMPAL_LAPTOP is not set
+# CONFIG_SONY_LAPTOP is not set
+# CONFIG_THINKPAD_ACPI is not set
+# CONFIG_INTEL_MENLOW is not set
+CONFIG_EEEPC_LAPTOP=y
+# CONFIG_ACPI_WMI is not set
+# CONFIG_ACPI_ASUS is not set
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_ACPI_TOSHIBA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+CONFIG_EFI_VARS=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+CONFIG_SGI_PARTITION=y
+# CONFIG_ULTRIX_PARTITION is not set
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_X86_VERBOSE_BOOTUP=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_EARLY_PRINTK_DBGP=y
+# CONFIG_4KSTACKS is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+CONFIG_OPTIMIZE_INLINING=y
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_SECURITY_ROOTPLUG is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_IMA is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_AES_586=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_586 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+# CONFIG_CRYPTO_DEV_GEODE is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -Naur /home/jara/linux-2.6.32/.config.old /usr/src/linux/.config.old
--- /home/jara/linux-2.6.32/.config.old	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/.config.old	2013-08-29 15:43:48.000000000 -0300
@@ -0,0 +1,2677 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32
+# Thu Aug 29 15:43:48 2013
+#
+# CONFIG_64BIT is not set
+CONFIG_X86_32=y
+# CONFIG_X86_64 is not set
+CONFIG_X86=y
+CONFIG_OUTPUT_FORMAT="elf32-i386"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_TIME_VSYSCALL is not set
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+# CONFIG_HAVE_CPUMASK_OF_CPU_MAP is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ZONE_DMA32 is not set
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+# CONFIG_AUDIT_ARCH is not set
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_X86_32_SMP=y
+CONFIG_X86_HT=y
+CONFIG_X86_TRAMPOLINE=y
+CONFIG_X86_32_LAZY_GS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_USER_SCHED is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_NS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP=y
+CONFIG_MM_OWNER=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+CONFIG_RELAY=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_X86_MPPARSE=y
+# CONFIG_X86_BIGSMP is not set
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_MRST is not set
+# CONFIG_X86_RDC321X is not set
+CONFIG_X86_32_NON_STANDARD=y
+# CONFIG_X86_NUMAQ is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_X86_SUMMIT is not set
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_PARAVIRT_GUEST is not set
+# CONFIG_MEMTEST is not set
+CONFIG_X86_CYCLONE_TIMER=y
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+CONFIG_M686=y
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+# CONFIG_GENERIC_CPU is not set
+CONFIG_X86_GENERIC=y
+CONFIG_X86_CPU=y
+CONFIG_X86_L1_CACHE_BYTES=64
+CONFIG_X86_INTERNODE_CACHE_BYTES=64
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_X86_XADD=y
+CONFIG_X86_PPRO_FENCE=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=5
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_CYRIX_32=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_CPU_SUP_TRANSMETA_32=y
+CONFIG_CPU_SUP_UMC_32=y
+# CONFIG_X86_DS is not set
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+# CONFIG_IOMMU_HELPER is not set
+# CONFIG_IOMMU_API is not set
+CONFIG_NR_CPUS=8
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_ANCIENT_MCE=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+CONFIG_VM86=y
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+CONFIG_X86_REBOOTFIXUPS=y
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_X86_MSR=y
+CONFIG_X86_CPUID=y
+# CONFIG_X86_CPU_DEBUG is not set
+# CONFIG_NOHIGHMEM is not set
+CONFIG_HIGHMEM4G=y
+# CONFIG_HIGHMEM64G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_HIGHMEM=y
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_MEMORY_FAILURE is not set
+CONFIG_HIGHPTE=y
+CONFIG_X86_CHECK_BIOS_CORRUPTION=y
+CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
+CONFIG_X86_RESERVE_LOW_64K=y
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+# CONFIG_MTRR_SANITIZER is not set
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_EFI=y
+CONFIG_SECCOMP=y
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+CONFIG_HZ_1000=y
+CONFIG_HZ=1000
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+# CONFIG_KEXEC_JUMP is not set
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+CONFIG_X86_NEED_RELOCS=y
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_VERBOSE is not set
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_TRACE=y
+CONFIG_PM_TRACE_RTC=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HIBERNATION_NVS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+# CONFIG_PM_RUNTIME is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+# CONFIG_ACPI_POWER_METER is not set
+CONFIG_ACPI_SYSFS_POWER=y
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_VIDEO=y
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_HOTPLUG_CPU=y
+# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
+CONFIG_ACPI_THERMAL=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+# CONFIG_ACPI_DEBUG is not set
+# CONFIG_ACPI_PCI_SLOT is not set
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+# CONFIG_ACPI_SBS is not set
+# CONFIG_SFI is not set
+# CONFIG_APM is not set
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_DEBUG=y
+# CONFIG_CPU_FREQ_STAT is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPUFreq processor drivers
+#
+CONFIG_X86_ACPI_CPUFREQ=y
+# CONFIG_X86_POWERNOW_K6 is not set
+# CONFIG_X86_POWERNOW_K7 is not set
+# CONFIG_X86_POWERNOW_K8 is not set
+# CONFIG_X86_GX_SUSPMOD is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_SPEEDSTEP_ICH is not set
+# CONFIG_X86_SPEEDSTEP_SMI is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+# CONFIG_X86_CPUFREQ_NFORCE2 is not set
+# CONFIG_X86_LONGRUN is not set
+# CONFIG_X86_LONGHAUL is not set
+# CONFIG_X86_E_POWERSAVER is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+# CONFIG_PCI_GOOLPC is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_DMAR is not set
+CONFIG_PCIEPORTBUS=y
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+# CONFIG_PCIEASPM is not set
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_LEGACY is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_HT_IRQ=y
+# CONFIG_PCI_IOV is not set
+CONFIG_ISA_DMA_API=y
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+# CONFIG_OLPC is not set
+CONFIG_K8_NB=y
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_CARDBUS=y
+
+#
+# PC-card bridges
+#
+CONFIG_YENTA=y
+CONFIG_YENTA_O2=y
+CONFIG_YENTA_RICOH=y
+CONFIG_YENTA_TI=y
+CONFIG_YENTA_ENE_TUNE=y
+CONFIG_YENTA_TOSHIBA=y
+# CONFIG_PD6729 is not set
+# CONFIG_I82092 is not set
+CONFIG_PCCARD_NONSTATIC=y
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_FAKE is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ is not set
+# CONFIG_HOTPLUG_PCI_IBM is not set
+# CONFIG_HOTPLUG_PCI_ACPI is not set
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+# CONFIG_INET_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_DEFAULT_BIC is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_HTCP is not set
+# CONFIG_DEFAULT_VEGAS is not set
+# CONFIG_DEFAULT_WESTWOOD is not set
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_NETLABEL=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_MATCH_IPV6HEADER=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_MANGLE=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_INGRESS is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+# CONFIG_AX25 is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_CFG80211_DEFAULT_PS_VALUE=1
+# CONFIG_CFG80211_DEBUGFS is not set
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+# CONFIG_MAC80211_MESH is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_LEDS=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+# CONFIG_MTD is not set
+CONFIG_PARPORT=y
+CONFIG_PARPORT_PC=y
+# CONFIG_PARPORT_SERIAL is not set
+# CONFIG_PARPORT_PC_FIFO is not set
+# CONFIG_PARPORT_PC_SUPERIO is not set
+# CONFIG_PARPORT_PC_PCMCIA is not set
+# CONFIG_PARPORT_GSC is not set
+# CONFIG_PARPORT_AX88796 is not set
+# CONFIG_PARPORT_1284 is not set
+CONFIG_PNP=y
+CONFIG_PNP_DEBUG_MESSAGES=y
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_SX8=y
+CONFIG_BLK_DEV_UB=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+CONFIG_HAVE_IDE=y
+CONFIG_IDE=y
+
+#
+# Please see Documentation/ide/ide.txt for help/info on IDE drives
+#
+CONFIG_IDE_XFER_MODE=y
+CONFIG_IDE_TIMINGS=y
+CONFIG_IDE_ATAPI=y
+CONFIG_BLK_DEV_IDE_SATA=y
+CONFIG_IDE_GD=y
+CONFIG_IDE_GD_ATA=y
+# CONFIG_IDE_GD_ATAPI is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_DELKIN is not set
+CONFIG_BLK_DEV_IDECD=y
+CONFIG_BLK_DEV_IDECD_VERBOSE_ERRORS=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEACPI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+CONFIG_IDE_PROC_FS=y
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_PLATFORM=y
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_IDEPNP is not set
+CONFIG_BLK_DEV_IDEDMA_SFF=y
+
+#
+# PCI IDE chipsets support
+#
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_PCIBUS_ORDER=y
+# CONFIG_BLK_DEV_GENERIC is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+CONFIG_BLK_DEV_AMD74XX=y
+# CONFIG_BLK_DEV_ATIIXP is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_CS5535 is not set
+# CONFIG_BLK_DEV_CS5536 is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_JMICRON is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT8172 is not set
+# CONFIG_BLK_DEV_IT8213 is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_BLK_DEV_TC86C001 is not set
+CONFIG_BLK_DEV_IDEDMA=y
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=y
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+CONFIG_CHR_DEV_OSST=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=y
+CONFIG_SCSI_SAS_LIBSAS=y
+# CONFIG_SCSI_SAS_ATA is not set
+CONFIG_SCSI_SAS_HOST_SMP=y
+CONFIG_SCSI_SAS_LIBSAS_DEBUG=y
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+CONFIG_SCSI_AIC94XX=y
+# CONFIG_AIC94XX_DEBUG is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_PPA is not set
+# CONFIG_SCSI_IMM is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+CONFIG_SCSI_DH=y
+# CONFIG_SCSI_DH_RDAC is not set
+# CONFIG_SCSI_DH_HP_SW is not set
+# CONFIG_SCSI_DH_EMC is not set
+# CONFIG_SCSI_DH_ALUA is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_PMP=y
+CONFIG_SATA_AHCI=y
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_SVW is not set
+CONFIG_ATA_PIIX=y
+CONFIG_SATA_MV=y
+CONFIG_SATA_NV=y
+CONFIG_PDC_ADMA=y
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_SATA_SIL=y
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_ULI is not set
+CONFIG_SATA_VIA=y
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_PATA_ACPI is not set
+CONFIG_PATA_ALI=y
+CONFIG_PATA_AMD=y
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5535 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+CONFIG_ATA_GENERIC=y
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_MARVELL is not set
+CONFIG_PATA_MPIIX=y
+CONFIG_PATA_OLDPIIX=y
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PCMCIA is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+CONFIG_PATA_SCH=y
+# CONFIG_MD is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# You can enable one or both FireWire driver stacks.
+#
+
+#
+# See the help texts for more information.
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_VETH=y
+# CONFIG_NET_SB1000 is not set
+# CONFIG_ARCNET is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+# CONFIG_ETHOC is not set
+# CONFIG_DNET is not set
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+# CONFIG_TULIP is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_ULI526X is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_HP100 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+CONFIG_AMD8111_ETH=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+CONFIG_FORCEDETH=y
+# CONFIG_FORCEDETH_NAPI is not set
+CONFIG_E100=y
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+CONFIG_NE2K_PCI=y
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_R6040 is not set
+# CONFIG_SIS900 is not set
+CONFIG_EPIC100=y
+CONFIG_SMSC9420=y
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+# CONFIG_NET_POCKET is not set
+# CONFIG_ATL2 is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+CONFIG_E1000=y
+CONFIG_E1000E=y
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_R8169=y
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+CONFIG_SKY2=y
+# CONFIG_SKY2_DEBUG is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_TIGON3=y
+CONFIG_BNX2=y
+# CONFIG_CNIC is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_JME is not set
+CONFIG_NETDEV_10000=y
+# CONFIG_CHELSIO_T1 is not set
+CONFIG_CHELSIO_T3_DEPENDS=y
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_ENIC is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_NIU is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_BNX2X is not set
+# CONFIG_QLGE is not set
+# CONFIG_SFC is not set
+# CONFIG_BE2NET is not set
+CONFIG_TR=y
+# CONFIG_IBMOL is not set
+# CONFIG_IBMLS is not set
+# CONFIG_3C359 is not set
+# CONFIG_TMS380TR is not set
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+# CONFIG_PCMCIA_PCNET is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_WAN is not set
+CONFIG_FDDI=y
+# CONFIG_DEFXX is not set
+# CONFIG_SKFP is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+CONFIG_NETCONSOLE=y
+# CONFIG_NETCONSOLE_DYNAMIC is not set
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_VMXNET3=y
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_DB9 is not set
+# CONFIG_JOYSTICK_GAMECON is not set
+# CONFIG_JOYSTICK_TURBOGRAFX is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+# CONFIG_JOYSTICK_WALKERA0701 is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_WACOM is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_APANEL is not set
+# CONFIG_INPUT_WISTRON_BTNS is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_WINBOND_CIR is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_SYNCLINK_GT is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_STALDRV is not set
+# CONFIG_NOZOMI is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_PNP=y
+# CONFIG_SERIAL_8250_CS is not set
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DETECT_IRQ=y
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_PRINTER is not set
+# CONFIG_PPDEV is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_GEODE=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_NVRAM=y
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_IPWIRELESS is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_CS5535_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+# CONFIG_HPET_MMAP is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_I801=y
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_I2C_SCMI is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Graphics adapter I2C/DDC channel drivers
+#
+# CONFIG_I2C_VOODOO3 is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_SENSORS_APPLESMC is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_SENSORS_ATK0110 is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_THERMAL=y
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_SC520_WDT is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_ITCO_WDT is not set
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_SBC8360_WDT is not set
+# CONFIG_SBC7240_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83697HF_WDT is not set
+# CONFIG_W83697UG_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+# CONFIG_AGP_ALI is not set
+# CONFIG_AGP_ATI is not set
+# CONFIG_AGP_AMD is not set
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=y
+# CONFIG_AGP_NVIDIA is not set
+# CONFIG_AGP_SIS is not set
+# CONFIG_AGP_SWORKS is not set
+# CONFIG_AGP_VIA is not set
+# CONFIG_AGP_EFFICEON is not set
+CONFIG_VGA_ARB=y
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_I810 is not set
+# CONFIG_DRM_I830 is not set
+CONFIG_DRM_I915=y
+# CONFIG_DRM_I915_KMS is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_VESA is not set
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I810 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_GEODE is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_PROGEAR is not set
+# CONFIG_BACKLIGHT_MBP_NVIDIA is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=64
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_SEQ_DUMMY=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_HRTIMER=y
+CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_DMA_SGBUF=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_PCSP is not set
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_MTS64 is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_PORTMAN2X4 is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5530 is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+CONFIG_SND_HDA_INTEL=y
+CONFIG_SND_HDA_HWDEP=y
+# CONFIG_SND_HDA_RECONFIG is not set
+# CONFIG_SND_HDA_INPUT_BEEP is not set
+# CONFIG_SND_HDA_INPUT_JACK is not set
+# CONFIG_SND_HDA_PATCH_LOADER is not set
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_SND_HDA_CODEC_ATIHDMI=y
+CONFIG_SND_HDA_CODEC_NVHDMI=y
+CONFIG_SND_HDA_CODEC_INTELHDMI=y
+CONFIG_SND_HDA_ELD=y
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_SND_HDA_CODEC_CA0110=y
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_SND_HDA_GENERIC=y
+# CONFIG_SND_HDA_POWER_SAVE is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_HIFIER is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SIS7019 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_USX2Y is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_US122L is not set
+CONFIG_SND_PCMCIA=y
+# CONFIG_SND_VXPOCKET is not set
+# CONFIG_SND_PDAUDIOCF is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_USS720 is not set
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_ALIX2 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_CLEVO_MAIL is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_BD2802 is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+# CONFIG_LEDS_TRIGGER_IDE_DISK is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC=y
+
+#
+# Reporting subsystems
+#
+# CONFIG_EDAC_DEBUG is not set
+CONFIG_EDAC_DECODE_MCE=y
+# CONFIG_EDAC_MM_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+# CONFIG_INTEL_IOATDMA is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACER_WMI is not set
+# CONFIG_ASUS_LAPTOP is not set
+# CONFIG_FUJITSU_LAPTOP is not set
+# CONFIG_TC1100_WMI is not set
+# CONFIG_MSI_LAPTOP is not set
+# CONFIG_PANASONIC_LAPTOP is not set
+# CONFIG_COMPAL_LAPTOP is not set
+# CONFIG_SONY_LAPTOP is not set
+# CONFIG_THINKPAD_ACPI is not set
+# CONFIG_INTEL_MENLOW is not set
+CONFIG_EEEPC_LAPTOP=y
+# CONFIG_ACPI_WMI is not set
+# CONFIG_ACPI_ASUS is not set
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_ACPI_TOSHIBA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+CONFIG_EFI_VARS=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+CONFIG_SGI_PARTITION=y
+# CONFIG_ULTRIX_PARTITION is not set
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_X86_VERBOSE_BOOTUP=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_EARLY_PRINTK_DBGP=y
+# CONFIG_4KSTACKS is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+CONFIG_OPTIMIZE_INLINING=y
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_SECURITY_ROOTPLUG is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_IMA is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_AES_586=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_586 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+# CONFIG_CRYPTO_DEV_GEODE is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -Naur /home/jara/linux-2.6.32/include/config/auto.conf /usr/src/linux/include/config/auto.conf
--- /home/jara/linux-2.6.32/include/config/auto.conf	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/config/auto.conf	2014-03-01 13:46:59.000000000 -0300
@@ -0,0 +1,904 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32
+# Sat Mar  1 13:46:59 2014
+#
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_SYSFS_POWER=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_SECURITY_NETWORK=y
+CONFIG_OSF_PARTITION=y
+CONFIG_HID_CHERRY=y
+CONFIG_FRAME_WARN=2048
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_TIPC_CLUSTERS=1
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_CARDBUS=y
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_INPUT_POLLDEV=y
+CONFIG_SMSC9420=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_E1000=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRASH_DUMP=y
+CONFIG_FLATMEM=y
+CONFIG_X86_MCE_THRESHOLD=y
+CONFIG_PROC_KCORE=y
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_TIPC_NODES=255
+CONFIG_CRYPTO_CBC=y
+CONFIG_DEVKMEM=y
+CONFIG_HIGHPTE=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_SECCOMP=y
+CONFIG_X86_PAT=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_PNPACPI=y
+CONFIG_TIMERFD=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_PATA_MPIIX=y
+CONFIG_EVENTFD=y
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EDAC=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_HAS_DMA=y
+CONFIG_BLK_DEV_UB=y
+CONFIG_THERMAL=y
+CONFIG_X86_CPU=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_CFG80211_DEFAULT_PS_VALUE=1
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_SUN_PARTITION=y
+CONFIG_NFS_COMMON=y
+CONFIG_X86_TSC=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_HID_PID=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VM86=y
+CONFIG_HPET_TIMER=y
+CONFIG_CPU_SUP_TRANSMETA_32=y
+CONFIG_VGA_ARB=y
+CONFIG_X86_CYCLONE_TIMER=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_FREEZER=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_ATA_SFF=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_VMXNET3=y
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_KEYBOARD_ATKBD=y
+CONFIG_NETDEV_10000=y
+CONFIG_RCU_FANOUT=32
+CONFIG_FDDI=y
+CONFIG_BLK_DEV=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_X86_MSR=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAS_IOPORT=y
+CONFIG_SND_SEQ_DUMMY=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_QUOTA_TREE=y
+CONFIG_CRYPTO_AES=y
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_MODULES=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_OUTPUT_FORMAT="elf32-i386"
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_BNX2=y
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_PARPORT_PC=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_CRYPTO_AES_586=y
+CONFIG_EXT2_FS=y
+CONFIG_INPUT_MISC=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_EXT3_FS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_CRYPTO_DES=y
+CONFIG_DNOTIFY=y
+CONFIG_HID_KYE=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SCSI_DH=y
+CONFIG_ACPI=y
+CONFIG_USB_HID=y
+CONFIG_NETPOLL=y
+CONFIG_TIPC_ZONES=3
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_RELOCATABLE=y
+CONFIG_QFMT_V2=y
+CONFIG_RTC_LIB=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_SND_PCI=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_X86_TRAMPOLINE=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_NET_PCI=y
+CONFIG_SUSPEND=y
+CONFIG_X86_GENERIC=y
+CONFIG_INOTIFY=y
+CONFIG_X86_32_LAZY_GS=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_HOTPLUG=y
+CONFIG_CGROUPS=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_SND_PCM=y
+CONFIG_DEVPORT=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_PCI_MSI=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+CONFIG_IPV6=y
+CONFIG_X86_PPRO_FENCE=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_TIPC_PORTS=8191
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_CPUSETS=y
+CONFIG_OPTIMIZE_INLINING=y
+CONFIG_PARPORT=y
+CONFIG_NET_CLS=y
+CONFIG_VFAT_FS=y
+CONFIG_SKY2=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_RD_LZMA=y
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_DRM_I915=y
+CONFIG_R8169=y
+CONFIG_SATA_MV=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_GENERIC_ACL=y
+CONFIG_SATA_NV=y
+CONFIG_PROC_FS=y
+CONFIG_SND_HDA_CODEC_ATIHDMI=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_SND_USB=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_IDE_GENERIC=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+CONFIG_X86_CMPXCHG=y
+CONFIG_RD_GZIP=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_EARLY_PRINTK_DBGP=y
+CONFIG_TIPC=y
+CONFIG_INET=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_RT_MUTEXES=y
+CONFIG_LOGO=y
+CONFIG_HPET=y
+CONFIG_SYSVIPC=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=64
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_WLAN=y
+CONFIG_ATA_GENERIC=y
+CONFIG_SCSI=y
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_USB_MON=y
+CONFIG_SERIAL_8250_RSA=y
+CONFIG_HIBERNATION=y
+CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_ACPI_PROCFS_POWER=y
+CONFIG_SLUB=y
+CONFIG_DOUBLEFAULT=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_VETH=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_X86_IO_APIC=y
+CONFIG_LOGITECH_FF=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_NR_CPUS=8
+CONFIG_X86_EXTENDED_PLATFORM=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_GENERIC_BUG=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CPU_FREQ_DEBUG=y
+CONFIG_X86_L1_CACHE_BYTES=64
+CONFIG_SWAP=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_KEYS=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_XFRM=y
+CONFIG_CRC32=y
+CONFIG_X86_MPPARSE=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_DEFAULT_CFQ=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_USER_NS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_HID_CHICONY=y
+CONFIG_PACKET_MMAP=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_EDAC_DECODE_MCE=y
+CONFIG_UNIX=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_SND_HDA_ELD=y
+CONFIG_HAMRADIO=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_MTRR=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_X86_XADD=y
+CONFIG_NETLABEL=y
+CONFIG_ISA_DMA_API=y
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_CPU_SUP_UMC_32=y
+CONFIG_HID_TOPSEED=y
+CONFIG_SERIAL_CORE=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_SIGNALFD=y
+CONFIG_PDC_ADMA=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_UID16=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_SCSI_WAIT_SCAN=m
+CONFIG_CRYPTO_ARC4=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_CRYPTO_AEAD=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_E1000E=y
+CONFIG_NE2K_PCI=y
+CONFIG_RFKILL_LEDS=y
+CONFIG_BINFMT_MISC=y
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_IDE_TIMINGS=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_FIB_HASH=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_HID_TWINHAN=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ANON_INODES=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_INET6_AH=y
+CONFIG_SLABINFO=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_CHELSIO_T3_DEPENDS=y
+CONFIG_VGA_CONSOLE=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_WATCHDOG=y
+CONFIG_SERIAL_8250_DETECT_IRQ=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_ACPI_FAN=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_ATA_ACPI=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_BLK_DEV_BSG=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_YENTA_ENE_TUNE=y
+CONFIG_GROUP_SCHED=y
+CONFIG_MAC80211_LEDS=y
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+CONFIG_YENTA_RICOH=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_HAVE_IDE=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_LOCKD_V4=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_SCHED_MC=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_PATA_AMD=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_BLK_DEV_IDEDMA_SFF=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_BLK_DEV_SX8=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_LBDAF=y
+CONFIG_X86_CMOV=y
+CONFIG_KERNEL_GZIP=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_SERIAL_NONSTANDARD=y
+CONFIG_PATA_ALI=y
+CONFIG_SCSI_SAS_LIBSAS_DEBUG=y
+CONFIG_X86_ANCIENT_MCE=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_RD_BZIP2=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_HID_CYPRESS=y
+CONFIG_IDE_PROC_FS=y
+CONFIG_USB_STORAGE=y
+CONFIG_HOTPLUG_PCI=y
+CONFIG_PROC_VMCORE=y
+CONFIG_SND_HRTIMER=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_ELF_CORE=y
+CONFIG_DEBUG_FS=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_YENTA_O2=y
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_PERF_EVENTS=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_SND_DRIVERS=y
+CONFIG_PATA_SCH=y
+CONFIG_SCSI_DMA=y
+CONFIG_BLK_DEV_AMD74XX=y
+CONFIG_PM_DEBUG=y
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CRYPTO_HASH=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_SCSI_SAS_HOST_SMP=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_X86_THERMAL_VECTOR=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_SCSI_SAS_ATTRS=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_INET_TUNNEL=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_IDLE=y
+CONFIG_PRINTK_TIME=y
+CONFIG_SND_VMASTER=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_SYN_COOKIES=y
+CONFIG_X86_INTERNODE_CACHE_BYTES=64
+CONFIG_DMIID=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_SATA_VIA=y
+CONFIG_PROC_EVENTS=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_PCI_BIOS=y
+CONFIG_X86_NEED_RELOCS=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_SCSI_SPI_ATTRS=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+CONFIG_USB_SUSPEND=y
+CONFIG_PNP_DEBUG_MESSAGES=y
+CONFIG_PM_TRACE=y
+CONFIG_BLOCK=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_LOCKD=y
+CONFIG_QUOTACTL=y
+CONFIG_USB_PRINTER=y
+CONFIG_SND_HDA_GENERIC=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_ZONE_DMA=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_WIRELESS=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_EFI_VARS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_ATA_PIIX=y
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_SATA_SIL=y
+CONFIG_KEXEC=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_KALLSYMS=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_HID_SUPPORT=y
+CONFIG_NEW_LEDS=y
+CONFIG_TIPC_LOG=0
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_HAVE_KVM=y
+CONFIG_FSNOTIFY=y
+CONFIG_FB_TILEBLITTING=y
+CONFIG_K8_NB=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_X86_VERBOSE_BOOTUP=y
+CONFIG_NLS_UTF8=y
+CONFIG_SND_HDA_CODEC_CA0110=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_AGP_AMD64=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_IPV6_SIT=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_SATA_PMP=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_CPU_FREQ=y
+CONFIG_PM_SLEEP=y
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_HID_PANTHERLORD=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_INPUT_MOUSE=y
+CONFIG_SECURITY=y
+CONFIG_FIRMWARE_MEMMAP=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_TREE_RCU=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_HIGHMEM4G=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_SHMEM=y
+CONFIG_SCSI_AIC94XX=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_INET_LRO=y
+CONFIG_EPOLL=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_HID_SONY=y
+CONFIG_YENTA_TI=y
+CONFIG_RELAY=y
+CONFIG_MSDOS_FS=y
+CONFIG_FONT_8x8=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_RPCSEC_GSS_KRB5=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SCSI_TGT=y
+CONFIG_BLK_DEV_IDECD_VERBOSE_ERRORS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_YENTA=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HW_RANDOM_GEODE=y
+CONFIG_SERIO=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_HID_LOGITECH=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_X86_CHECK_BIOS_CORRUPTION=y
+CONFIG_NVRAM=y
+CONFIG_X86_32_NON_STANDARD=y
+CONFIG_MM_OWNER=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP=y
+CONFIG_FILE_LOCKING=y
+CONFIG_USB_SUPPORT=y
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_SMSC_PHY=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_FB=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_SOUND=y
+CONFIG_ACPI_THERMAL=y
+CONFIG_HWMON=y
+CONFIG_HIBERNATION_NVS=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ROOT_NFS=y
+CONFIG_QUOTA=y
+CONFIG_TMPFS=y
+CONFIG_ASK_IP_FIB_HASH=y
+CONFIG_X86_32=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_SCHED_HRTICK=y
+CONFIG_GENERIC_TIME=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_FUTEX=y
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_MISC_DEVICES=y
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_EXPERIMENTAL=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_INPUT=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_EEEPC_LAPTOP=y
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_LOCALVERSION=""
+CONFIG_USB_DEVICEFS=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_FORCEDETH=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_SCSI_SAS_LIBSAS=y
+CONFIG_MICROCODE=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_NF_CONNTRACK=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_SYSFS=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_X86_CPUID=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_STOP_MACHINE=y
+CONFIG_CAN_PM_TRACE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_SATA_AHCI=y
+CONFIG_ACPI_DOCK=y
+CONFIG_PM=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_PATA_OLDPIIX=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_NO_HZ=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_USB_UHCI_HCD=y
+CONFIG_IDE_ATAPI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_GYRATION=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_HZ=1000
+CONFIG_X86_BSWAP=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_HUGETLBFS=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NET_ETHERNET=y
+CONFIG_ACPI_BLACKLIST_YEAR=0
+CONFIG_HID_APPLE=y
+CONFIG_TR=y
+CONFIG_X86_RESERVE_LOW_64K=y
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_HID_MONTEREY=y
+CONFIG_NET_SCH_FIFO=y
+CONFIG_SSB_POSSIBLE=y
+CONFIG_HID_PETALYNX=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=5
+CONFIG_USB_LIBUSUAL=y
+CONFIG_VT=y
+CONFIG_TICK_ONESHOT=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_INPUT_TABLET=y
+CONFIG_CONNECTOR=y
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_FONT_8x16=y
+CONFIG_NET_SCHED=y
+CONFIG_BRIDGE=y
+CONFIG_NETFILTER=y
+CONFIG_INET6_ESP=y
+CONFIG_PCMCIA=y
+CONFIG_PCCARD=y
+CONFIG_BASE_FULL=y
+CONFIG_IDEPCI_PCIBUS_ORDER=y
+CONFIG_IP_MULTICAST=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_USB_DEBUG=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_EPIC100=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_HAS_IOMEM=y
+CONFIG_AGP_INTEL=y
+CONFIG_RFKILL_INPUT=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_PM_TRACE_RTC=y
+CONFIG_FW_LOADER=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_TIGON3=y
+CONFIG_IO_DELAY_0X80=y
+CONFIG_NLS_ASCII=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_X86_ACPI_CPUFREQ=y
+CONFIG_ISO9660_FS=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_HID_NTRIG=y
+CONFIG_PACKET=y
+CONFIG_PCI_GOANY=y
+CONFIG_CONSTRUCTORS=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SCHED_SMT=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_FB_EFI=y
+CONFIG_IP6_NF_MATCH_IPV6HEADER=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_FIB_RULES=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_HID_EZKEY=y
+CONFIG_SND_HWDEP=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_IDE_GD=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_BOUNCE=y
+CONFIG_HAVE_AOUT=y
+CONFIG_MOUSE_PS2=y
+CONFIG_SCSI_PROC_FS=y
+CONFIG_I2C=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_RTC_CLASS=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_HIDRAW=y
+CONFIG_HW_RANDOM=y
+CONFIG_CRC_T10DIF=y
+CONFIG_PCCARD_NONSTATIC=y
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_INOTIFY_USER=y
+CONFIG_X86_HT=y
+CONFIG_HZ_1000=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_HID_GREENASIA=y
+CONFIG_CHR_DEV_OSST=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_RFKILL=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_SND_TIMER=y
+CONFIG_TIPC_ADVANCED=y
+CONFIG_RTC_DRV_CMOS=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_X86=y
+CONFIG_JOLIET=y
+CONFIG_8139TOO=y
+CONFIG_PHYLIB=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_DCB=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_DEFAULT_CUBIC=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_SND_HDA_CODEC_INTELHDMI=y
+CONFIG_CFG80211=y
+CONFIG_HID_A4TECH=y
+CONFIG_MAC80211=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_NFS_V3=y
+CONFIG_BLK_DEV_IDECD=y
+CONFIG_X86_REBOOTFIXUPS=y
+CONFIG_NFS_V4=y
+CONFIG_JBD=y
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_BLK_DEV_IDE_SATA=y
+CONFIG_CGROUP_NS=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_IDE=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_FAT_FS=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NET_TULIP=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_IP_MROUTE=y
+CONFIG_EFI=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_DMADEVICES=y
+CONFIG_HID=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_NLATTR=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_E100=y
+CONFIG_ATA=y
+CONFIG_NF_NAT=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_AGP=y
+CONFIG_PRINTK=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_AIO=y
+CONFIG_X86_32_SMP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_DMI=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_SUNRPC=y
+CONFIG_FS_MBCACHE=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_BLK_DEV_PLATFORM=y
+CONFIG_LLC=y
+CONFIG_XFRM_USER=y
+CONFIG_PCI=y
+CONFIG_IPC_NS=y
+CONFIG_AMD8111_ETH=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_PID_NS=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_ZISOFS=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_BUG=y
+CONFIG_CRYPTO_HW=y
+CONFIG_NFS_FS=y
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_PCNET32=y
+CONFIG_MII=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_NAMESPACES=y
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_I2C_COMPAT=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_CRYPTO=y
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_TIPC_SLAVE_NODES=0
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_SYSCTL=y
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_DRM=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_SND=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_NETDEV_1000=y
+CONFIG_IP_PNP=y
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_HT_IRQ=y
+CONFIG_NET_NS=y
+CONFIG_NET=y
+CONFIG_SND_HDA_HWDEP=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_HID_BELKIN=y
+CONFIG_STANDALONE=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_MAC_PARTITION=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_NETDEVICES=y
+CONFIG_IDE_XFER_MODE=y
+CONFIG_USB=y
+CONFIG_YENTA_TOSHIBA=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_X86_PLATFORM_DEVICES=y
+CONFIG_SND_HDA_INTEL=y
+CONFIG_SND_DMA_SGBUF=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_SERIAL_8250=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_PNP=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_TCP_MD5SIG=y
+CONFIG_MMU=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_SMP=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SND_PCMCIA=y
+CONFIG_IDE_GD_ATA=y
+CONFIG_CPU_SUP_CYRIX_32=y
+CONFIG_M686=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_IOSCHED_AS=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_SND_HDA_CODEC_NVHDMI=y
+CONFIG_NET_PCMCIA=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_ACPI_VIDEO=y
+CONFIG_BASE_SMALL=0
+CONFIG_X86_INVLPG=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_BINFMT_ELF=y
+CONFIG_PCI_DIRECT=y
+CONFIG_STP=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SERIO_I8042=y
+CONFIG_NET_EMATCH=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_PCIEAER=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_NETCONSOLE=y
+CONFIG_X86_MCE=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_BITREVERSE=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_SGI_PARTITION=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_UTS_NS=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_USB_HIDDEV=y
+CONFIG_LEDS_CLASS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_I2C_I801=y
+CONFIG_HIGHMEM=y
diff -Naur /home/jara/linux-2.6.32/include/config/auto.conf.cmd /usr/src/linux/include/config/auto.conf.cmd
--- /home/jara/linux-2.6.32/include/config/auto.conf.cmd	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/config/auto.conf.cmd	2014-03-01 13:46:59.000000000 -0300
@@ -0,0 +1,513 @@
+deps_config := \
+	lib/Kconfig \
+	drivers/virtio/Kconfig \
+	drivers/lguest/Kconfig \
+	virt/kvm/Kconfig \
+	arch/x86/kvm/Kconfig \
+	drivers/crypto/Kconfig \
+	crypto/async_tx/Kconfig \
+	crypto/Kconfig \
+	security/integrity/ima/Kconfig \
+	security/tomoyo/Kconfig \
+	security/smack/Kconfig \
+	security/selinux/Kconfig \
+	security/Kconfig \
+	lib/Kconfig.kmemcheck \
+	lib/Kconfig.kgdb \
+	samples/Kconfig \
+	kernel/trace/Kconfig \
+	mm/Kconfig.debug \
+	lib/Kconfig.debug \
+	arch/x86/Kconfig.debug \
+	fs/dlm/Kconfig \
+	fs/nls/Kconfig \
+	fs/partitions/Kconfig \
+	fs/9p/Kconfig \
+	fs/afs/Kconfig \
+	fs/coda/Kconfig \
+	fs/ncpfs/Kconfig \
+	fs/cifs/Kconfig \
+	fs/smbfs/Kconfig \
+	net/sunrpc/Kconfig \
+	fs/nfsd/Kconfig \
+	fs/nfs/Kconfig \
+	fs/exofs/Kconfig \
+	fs/ufs/Kconfig \
+	fs/sysv/Kconfig \
+	fs/romfs/Kconfig \
+	fs/qnx4/Kconfig \
+	fs/hpfs/Kconfig \
+	fs/omfs/Kconfig \
+	fs/minix/Kconfig \
+	fs/freevxfs/Kconfig \
+	fs/squashfs/Kconfig \
+	fs/cramfs/Kconfig \
+	fs/ubifs/Kconfig \
+	fs/jffs2/Kconfig \
+	fs/efs/Kconfig \
+	fs/bfs/Kconfig \
+	fs/befs/Kconfig \
+	fs/hfsplus/Kconfig \
+	fs/hfs/Kconfig \
+	fs/ecryptfs/Kconfig \
+	fs/affs/Kconfig \
+	fs/adfs/Kconfig \
+	fs/configfs/Kconfig \
+	fs/sysfs/Kconfig \
+	fs/proc/Kconfig \
+	fs/ntfs/Kconfig \
+	fs/fat/Kconfig \
+	fs/udf/Kconfig \
+	fs/isofs/Kconfig \
+	fs/cachefiles/Kconfig \
+	fs/fscache/Kconfig \
+	fs/fuse/Kconfig \
+	fs/autofs4/Kconfig \
+	fs/autofs/Kconfig \
+	fs/quota/Kconfig \
+	fs/notify/inotify/Kconfig \
+	fs/notify/dnotify/Kconfig \
+	fs/notify/Kconfig \
+	fs/nilfs2/Kconfig \
+	fs/btrfs/Kconfig \
+	fs/ocfs2/Kconfig \
+	fs/gfs2/Kconfig \
+	fs/xfs/Kconfig \
+	fs/jfs/Kconfig \
+	fs/reiserfs/Kconfig \
+	fs/jbd2/Kconfig \
+	fs/jbd/Kconfig \
+	fs/ext4/Kconfig \
+	fs/ext3/Kconfig \
+	fs/ext2/Kconfig \
+	fs/Kconfig \
+	drivers/firmware/Kconfig \
+	drivers/platform/x86/Kconfig \
+	drivers/platform/Kconfig \
+	drivers/staging/iio/trigger/Kconfig \
+	drivers/staging/iio/light/Kconfig \
+	drivers/staging/iio/adc/Kconfig \
+	drivers/staging/iio/accel/Kconfig \
+	drivers/staging/iio/Kconfig \
+	drivers/staging/sep/Kconfig \
+	drivers/staging/rar/Kconfig \
+	drivers/staging/vme/devices/Kconfig \
+	drivers/staging/vme/bridges/Kconfig \
+	drivers/staging/vme/Kconfig \
+	drivers/staging/hv/Kconfig \
+	drivers/staging/udlfb/Kconfig \
+	drivers/staging/vt6656/Kconfig \
+	drivers/staging/vt6655/Kconfig \
+	drivers/staging/quatech_usb2/Kconfig \
+	drivers/staging/serqt_usb2/Kconfig \
+	drivers/staging/octeon/Kconfig \
+	drivers/gpu/drm/radeon/Kconfig \
+	drivers/staging/line6/Kconfig \
+	drivers/staging/p9auth/Kconfig \
+	drivers/staging/phison/Kconfig \
+	drivers/staging/b3dfg/Kconfig \
+	drivers/staging/pohmelfs/Kconfig \
+	drivers/staging/dst/Kconfig \
+	drivers/staging/dream/camera/Kconfig \
+	drivers/staging/dream/smd/Kconfig \
+	drivers/staging/dream/Kconfig \
+	drivers/staging/android/Kconfig \
+	drivers/staging/frontier/Kconfig \
+	drivers/staging/mimio/Kconfig \
+	drivers/staging/rtl8192e/Kconfig \
+	drivers/staging/rtl8192su/Kconfig \
+	drivers/staging/rtl8187se/Kconfig \
+	drivers/staging/altpciechdma/Kconfig \
+	drivers/staging/panel/Kconfig \
+	drivers/staging/asus_oled/Kconfig \
+	drivers/staging/comedi/Kconfig \
+	drivers/staging/rt3090/Kconfig \
+	drivers/staging/rt2870/Kconfig \
+	drivers/staging/rt2860/Kconfig \
+	drivers/staging/otus/Kconfig \
+	drivers/staging/poch/Kconfig \
+	drivers/staging/echo/Kconfig \
+	drivers/staging/wlan-ng/Kconfig \
+	drivers/staging/winbond/Kconfig \
+	drivers/staging/usbip/Kconfig \
+	drivers/staging/cx25821/Kconfig \
+	drivers/staging/go7007/Kconfig \
+	drivers/staging/slicoss/Kconfig \
+	drivers/staging/et131x/Kconfig \
+	drivers/staging/Kconfig \
+	drivers/xen/Kconfig \
+	drivers/vlynq/Kconfig \
+	drivers/uio/Kconfig \
+	drivers/auxdisplay/Kconfig \
+	drivers/dca/Kconfig \
+	drivers/dma/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/edac/Kconfig \
+	drivers/infiniband/ulp/iser/Kconfig \
+	drivers/infiniband/ulp/srp/Kconfig \
+	drivers/infiniband/ulp/ipoib/Kconfig \
+	drivers/infiniband/hw/nes/Kconfig \
+	drivers/infiniband/hw/mlx4/Kconfig \
+	drivers/infiniband/hw/cxgb3/Kconfig \
+	drivers/infiniband/hw/amso1100/Kconfig \
+	drivers/infiniband/hw/ehca/Kconfig \
+	drivers/infiniband/hw/ipath/Kconfig \
+	drivers/infiniband/hw/mthca/Kconfig \
+	drivers/infiniband/Kconfig \
+	drivers/accessibility/Kconfig \
+	drivers/leds/Kconfig \
+	drivers/memstick/host/Kconfig \
+	drivers/memstick/core/Kconfig \
+	drivers/memstick/Kconfig \
+	drivers/mmc/host/Kconfig \
+	drivers/mmc/card/Kconfig \
+	drivers/mmc/core/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/uwb/Kconfig \
+	drivers/usb/otg/Kconfig \
+	drivers/usb/gadget/Kconfig \
+	drivers/usb/atm/Kconfig \
+	drivers/usb/misc/sisusbvga/Kconfig \
+	drivers/usb/misc/Kconfig \
+	drivers/usb/serial/Kconfig \
+	drivers/usb/image/Kconfig \
+	drivers/usb/storage/Kconfig \
+	drivers/usb/class/Kconfig \
+	drivers/usb/musb/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/wusbcore/Kconfig \
+	drivers/usb/mon/Kconfig \
+	drivers/usb/core/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/hid/usbhid/Kconfig \
+	drivers/hid/Kconfig \
+	sound/oss/Kconfig \
+	sound/soc/codecs/Kconfig \
+	sound/soc/txx9/Kconfig \
+	sound/soc/sh/Kconfig \
+	sound/soc/s6000/Kconfig \
+	sound/soc/s3c24xx/Kconfig \
+	sound/soc/pxa/Kconfig \
+	sound/soc/omap/Kconfig \
+	sound/soc/imx/Kconfig \
+	sound/soc/fsl/Kconfig \
+	sound/soc/davinci/Kconfig \
+	sound/soc/blackfin/Kconfig \
+	sound/soc/au1x/Kconfig \
+	sound/soc/atmel/Kconfig \
+	sound/soc/Kconfig \
+	sound/parisc/Kconfig \
+	sound/sparc/Kconfig \
+	sound/pcmcia/Kconfig \
+	sound/usb/Kconfig \
+	sound/sh/Kconfig \
+	sound/mips/Kconfig \
+	sound/spi/Kconfig \
+	sound/atmel/Kconfig \
+	sound/arm/Kconfig \
+	sound/aoa/soundbus/Kconfig \
+	sound/aoa/codecs/Kconfig \
+	sound/aoa/fabrics/Kconfig \
+	sound/aoa/Kconfig \
+	sound/ppc/Kconfig \
+	sound/pci/hda/Kconfig \
+	sound/pci/Kconfig \
+	sound/isa/Kconfig \
+	sound/drivers/Kconfig \
+	sound/core/seq/Kconfig \
+	sound/core/Kconfig \
+	sound/oss/dmasound/Kconfig \
+	sound/Kconfig \
+	drivers/video/logo/Kconfig \
+	drivers/video/console/Kconfig \
+	drivers/video/display/Kconfig \
+	drivers/video/backlight/Kconfig \
+	drivers/video/omap/Kconfig \
+	drivers/video/geode/Kconfig \
+	drivers/gpu/drm/Kconfig \
+	drivers/gpu/vga/Kconfig \
+	drivers/char/agp/Kconfig \
+	drivers/video/Kconfig \
+	drivers/media/dvb/frontends/Kconfig \
+	drivers/media/dvb/pt1/Kconfig \
+	drivers/media/dvb/firewire/Kconfig \
+	drivers/media/dvb/dm1105/Kconfig \
+	drivers/media/dvb/pluto2/Kconfig \
+	drivers/media/dvb/bt8xx/Kconfig \
+	drivers/media/dvb/b2c2/Kconfig \
+	drivers/media/dvb/siano/Kconfig \
+	drivers/media/dvb/ttusb-dec/Kconfig \
+	drivers/media/dvb/ttusb-budget/Kconfig \
+	drivers/media/dvb/dvb-usb/Kconfig \
+	drivers/media/dvb/ttpci/Kconfig \
+	drivers/media/dvb/Kconfig \
+	drivers/media/radio/si470x/Kconfig \
+	drivers/media/radio/Kconfig \
+	drivers/media/video/pwc/Kconfig \
+	drivers/media/video/zc0301/Kconfig \
+	drivers/media/video/sn9c102/Kconfig \
+	drivers/media/video/et61x251/Kconfig \
+	drivers/media/video/usbvideo/Kconfig \
+	drivers/media/video/usbvision/Kconfig \
+	drivers/media/video/cx231xx/Kconfig \
+	drivers/media/video/em28xx/Kconfig \
+	drivers/media/video/hdpvr/Kconfig \
+	drivers/media/video/pvrusb2/Kconfig \
+	drivers/media/video/gspca/gl860/Kconfig \
+	drivers/media/video/gspca/stv06xx/Kconfig \
+	drivers/media/video/gspca/m5602/Kconfig \
+	drivers/media/video/gspca/Kconfig \
+	drivers/media/video/uvc/Kconfig \
+	drivers/media/video/saa7164/Kconfig \
+	drivers/media/video/cx18/Kconfig \
+	drivers/media/video/ivtv/Kconfig \
+	drivers/media/video/au0828/Kconfig \
+	drivers/media/video/cx23885/Kconfig \
+	drivers/media/video/cx88/Kconfig \
+	drivers/media/video/saa7134/Kconfig \
+	drivers/media/video/zoran/Kconfig \
+	drivers/media/video/cpia2/Kconfig \
+	drivers/media/video/bt8xx/Kconfig \
+	drivers/media/video/cx25840/Kconfig \
+	drivers/media/video/Kconfig \
+	drivers/media/common/tuners/Kconfig \
+	drivers/media/common/Kconfig \
+	drivers/media/Kconfig \
+	drivers/regulator/Kconfig \
+	drivers/mfd/Kconfig \
+	drivers/ssb/Kconfig \
+	drivers/watchdog/Kconfig \
+	drivers/thermal/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/power/Kconfig \
+	drivers/w1/slaves/Kconfig \
+	drivers/w1/masters/Kconfig \
+	drivers/w1/Kconfig \
+	drivers/gpio/Kconfig \
+	drivers/pps/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/i2c/chips/Kconfig \
+	drivers/i2c/busses/Kconfig \
+	drivers/i2c/algos/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/s390/char/Kconfig \
+	drivers/char/tpm/Kconfig \
+	drivers/char/pcmcia/Kconfig \
+	drivers/char/hw_random/Kconfig \
+	drivers/char/ipmi/Kconfig \
+	drivers/serial/Kconfig \
+	drivers/char/Kconfig \
+	drivers/input/gameport/Kconfig \
+	drivers/input/serio/Kconfig \
+	drivers/input/misc/Kconfig \
+	drivers/input/touchscreen/Kconfig \
+	drivers/input/tablet/Kconfig \
+	drivers/input/joystick/iforce/Kconfig \
+	drivers/input/joystick/Kconfig \
+	drivers/input/mouse/Kconfig \
+	drivers/input/keyboard/Kconfig \
+	drivers/input/Kconfig \
+	drivers/telephony/Kconfig \
+	drivers/isdn/gigaset/Kconfig \
+	drivers/isdn/hardware/eicon/Kconfig \
+	drivers/isdn/hardware/avm/Kconfig \
+	drivers/isdn/hardware/Kconfig \
+	drivers/isdn/capi/Kconfig \
+	drivers/isdn/hysdn/Kconfig \
+	drivers/isdn/act2000/Kconfig \
+	drivers/isdn/sc/Kconfig \
+	drivers/isdn/pcbit/Kconfig \
+	drivers/isdn/icn/Kconfig \
+	drivers/isdn/hisax/Kconfig \
+	drivers/isdn/i4l/Kconfig \
+	drivers/isdn/hardware/mISDN/Kconfig \
+	drivers/isdn/mISDN/Kconfig \
+	drivers/isdn/Kconfig \
+	drivers/s390/net/Kconfig \
+	drivers/ieee802154/Kconfig \
+	drivers/atm/Kconfig \
+	drivers/net/wan/Kconfig \
+	drivers/net/pcmcia/Kconfig \
+	drivers/net/usb/Kconfig \
+	drivers/net/wimax/i2400m/Kconfig \
+	drivers/net/wimax/Kconfig \
+	drivers/net/wireless/iwmc3200wifi/Kconfig \
+	drivers/net/wireless/wl12xx/Kconfig \
+	drivers/net/wireless/orinoco/Kconfig \
+	drivers/net/wireless/rt2x00/Kconfig \
+	drivers/net/wireless/zd1211rw/Kconfig \
+	drivers/net/wireless/b43legacy/Kconfig \
+	drivers/net/wireless/b43/Kconfig \
+	drivers/net/wireless/hostap/Kconfig \
+	drivers/net/wireless/iwlwifi/Kconfig \
+	drivers/net/wireless/ipw2x00/Kconfig \
+	drivers/net/wireless/ath/ar9170/Kconfig \
+	drivers/net/wireless/ath/ath9k/Kconfig \
+	drivers/net/wireless/ath/ath5k/Kconfig \
+	drivers/net/wireless/ath/Kconfig \
+	drivers/net/wireless/p54/Kconfig \
+	drivers/net/wireless/Kconfig \
+	drivers/net/tokenring/Kconfig \
+	drivers/net/benet/Kconfig \
+	drivers/net/sfc/Kconfig \
+	drivers/net/stmmac/Kconfig \
+	drivers/net/ixp2000/Kconfig \
+	drivers/net/fs_enet/Kconfig \
+	drivers/net/ibm_newemac/Kconfig \
+	drivers/net/tulip/Kconfig \
+	drivers/net/arm/Kconfig \
+	drivers/net/phy/Kconfig \
+	drivers/net/arcnet/Kconfig \
+	drivers/net/Kconfig \
+	drivers/macintosh/Kconfig \
+	drivers/message/i2o/Kconfig \
+	drivers/firewire/Kconfig \
+	drivers/ieee1394/Kconfig \
+	drivers/message/fusion/Kconfig \
+	drivers/md/Kconfig \
+	drivers/ata/Kconfig \
+	drivers/scsi/osd/Kconfig \
+	drivers/scsi/device_handler/Kconfig \
+	drivers/scsi/pcmcia/Kconfig \
+	drivers/scsi/arm/Kconfig \
+	drivers/scsi/qla4xxx/Kconfig \
+	drivers/scsi/qla2xxx/Kconfig \
+	drivers/scsi/mpt2sas/Kconfig \
+	drivers/scsi/megaraid/Kconfig.megaraid \
+	drivers/scsi/mvsas/Kconfig \
+	drivers/scsi/aic94xx/Kconfig \
+	drivers/scsi/aic7xxx/Kconfig.aic79xx \
+	drivers/scsi/aic7xxx/Kconfig.aic7xxx \
+	drivers/scsi/be2iscsi/Kconfig \
+	drivers/scsi/bnx2i/Kconfig \
+	drivers/scsi/cxgb3i/Kconfig \
+	drivers/scsi/libsas/Kconfig \
+	drivers/scsi/Kconfig \
+	drivers/ide/Kconfig \
+	drivers/misc/cb710/Kconfig \
+	drivers/misc/eeprom/Kconfig \
+	drivers/misc/c2port/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/s390/block/Kconfig \
+	drivers/block/paride/Kconfig \
+	drivers/block/Kconfig \
+	drivers/pnp/pnpacpi/Kconfig \
+	drivers/pnp/pnpbios/Kconfig \
+	drivers/pnp/isapnp/Kconfig \
+	drivers/pnp/Kconfig \
+	drivers/parport/Kconfig \
+	drivers/of/Kconfig \
+	drivers/mtd/ubi/Kconfig.debug \
+	drivers/mtd/ubi/Kconfig \
+	drivers/mtd/lpddr/Kconfig \
+	drivers/mtd/onenand/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/devices/Kconfig \
+	drivers/mtd/maps/Kconfig \
+	drivers/mtd/chips/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/connector/Kconfig \
+	drivers/base/Kconfig \
+	drivers/Kconfig \
+	net/9p/Kconfig \
+	net/rfkill/Kconfig \
+	net/wimax/Kconfig \
+	net/mac80211/Kconfig \
+	net/wireless/Kconfig \
+	net/rxrpc/Kconfig \
+	drivers/bluetooth/Kconfig \
+	net/bluetooth/hidp/Kconfig \
+	net/bluetooth/cmtp/Kconfig \
+	net/bluetooth/bnep/Kconfig \
+	net/bluetooth/rfcomm/Kconfig \
+	net/bluetooth/Kconfig \
+	drivers/net/irda/Kconfig \
+	net/irda/ircomm/Kconfig \
+	net/irda/irnet/Kconfig \
+	net/irda/irlan/Kconfig \
+	net/irda/Kconfig \
+	drivers/net/can/usb/Kconfig \
+	drivers/net/can/sja1000/Kconfig \
+	drivers/net/can/Kconfig \
+	net/can/Kconfig \
+	drivers/net/hamradio/Kconfig \
+	net/ax25/Kconfig \
+	net/dcb/Kconfig \
+	net/sched/Kconfig \
+	net/ieee802154/Kconfig \
+	net/phonet/Kconfig \
+	net/wanrouter/Kconfig \
+	net/econet/Kconfig \
+	net/lapb/Kconfig \
+	net/x25/Kconfig \
+	drivers/net/appletalk/Kconfig \
+	net/ipx/Kconfig \
+	net/llc/Kconfig \
+	net/decnet/Kconfig \
+	net/8021q/Kconfig \
+	net/dsa/Kconfig \
+	net/bridge/Kconfig \
+	net/802/Kconfig \
+	net/atm/Kconfig \
+	net/tipc/Kconfig \
+	net/rds/Kconfig \
+	net/sctp/Kconfig \
+	net/dccp/ccids/Kconfig \
+	net/dccp/Kconfig \
+	net/bridge/netfilter/Kconfig \
+	net/decnet/netfilter/Kconfig \
+	net/ipv6/netfilter/Kconfig \
+	net/ipv4/netfilter/Kconfig \
+	net/netfilter/ipvs/Kconfig \
+	net/netfilter/Kconfig \
+	net/netlabel/Kconfig \
+	net/ipv6/Kconfig \
+	net/ipv4/Kconfig \
+	net/iucv/Kconfig \
+	net/xfrm/Kconfig \
+	net/unix/Kconfig \
+	net/packet/Kconfig \
+	net/Kconfig \
+	fs/Kconfig.binfmt \
+	drivers/pci/hotplug/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/mca/Kconfig \
+	drivers/eisa/Kconfig \
+	drivers/pci/Kconfig \
+	drivers/pci/pcie/aer/Kconfig.debug \
+	drivers/pci/pcie/aer/Kconfig \
+	drivers/pci/pcie/Kconfig \
+	drivers/idle/Kconfig \
+	drivers/cpuidle/Kconfig \
+	drivers/cpufreq/Kconfig \
+	arch/x86/kernel/cpu/cpufreq/Kconfig \
+	drivers/sfi/Kconfig \
+	drivers/acpi/Kconfig \
+	kernel/power/Kconfig \
+	kernel/Kconfig.hz \
+	mm/Kconfig \
+	kernel/Kconfig.preempt \
+	arch/x86/Kconfig.cpu \
+	arch/x86/lguest/Kconfig \
+	arch/x86/xen/Kconfig \
+	kernel/time/Kconfig \
+	kernel/Kconfig.freezer \
+	block/Kconfig.iosched \
+	block/Kconfig \
+	kernel/gcov/Kconfig \
+	arch/Kconfig \
+	usr/Kconfig \
+	init/Kconfig \
+	arch/x86/Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+ifneq "$(KERNELVERSION)" "2.6.32"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(ARCH)" "i386"
+include/config/auto.conf: FORCE
+endif
+
+$(deps_config): ;
diff -Naur /home/jara/linux-2.6.32/include/config/kernel.release /usr/src/linux/include/config/kernel.release
--- /home/jara/linux-2.6.32/include/config/kernel.release	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/config/kernel.release	2015-03-18 09:08:55.000000000 -0300
@@ -0,0 +1 @@
+2.6.32
diff -Naur /home/jara/linux-2.6.32/include/linux/autoconf.h /usr/src/linux/include/linux/autoconf.h
--- /home/jara/linux-2.6.32/include/linux/autoconf.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/linux/autoconf.h	2014-03-01 13:46:59.000000000 -0300
@@ -0,0 +1,905 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: 2.6.32
+ * Sat Mar  1 13:46:59 2014
+ */
+#define AUTOCONF_INCLUDED
+#define CONFIG_ACPI_AC 1
+#define CONFIG_ACPI_SYSFS_POWER 1
+#define CONFIG_PM_STD_PARTITION ""
+#define CONFIG_SECURITY_NETWORK 1
+#define CONFIG_OSF_PARTITION 1
+#define CONFIG_HID_CHERRY 1
+#define CONFIG_FRAME_WARN 2048
+#define CONFIG_TCP_CONG_ADVANCED 1
+#define CONFIG_ARCH_DEFCONFIG "arch/x86/configs/i386_defconfig"
+#define CONFIG_TIPC_CLUSTERS 1
+#define CONFIG_IP6_NF_TARGET_REJECT 1
+#define CONFIG_CARDBUS 1
+#define CONFIG_SND_HDA_CODEC_CIRRUS 1
+#define CONFIG_INPUT_POLLDEV 1
+#define CONFIG_SMSC9420 1
+#define CONFIG_INET6_XFRM_MODE_BEET 1
+#define CONFIG_POSIX_MQUEUE_SYSCTL 1
+#define CONFIG_ARCH_MAY_HAVE_PC_FDC 1
+#define CONFIG_CRYPTO_BLKCIPHER2 1
+#define CONFIG_E1000 1
+#define CONFIG_CRYPTO_MD5 1
+#define CONFIG_CRASH_DUMP 1
+#define CONFIG_FLATMEM 1
+#define CONFIG_X86_MCE_THRESHOLD 1
+#define CONFIG_PROC_KCORE 1
+#define CONFIG_CRYPTO_WORKQUEUE 1
+#define CONFIG_TIPC_NODES 255
+#define CONFIG_CRYPTO_CBC 1
+#define CONFIG_DEVKMEM 1
+#define CONFIG_HIGHPTE 1
+#define CONFIG_HAVE_FUNCTION_TRACER 1
+#define CONFIG_CRYPTO_ECB 1
+#define CONFIG_SECCOMP 1
+#define CONFIG_X86_PAT 1
+#define CONFIG_USE_GENERIC_SMP_HELPERS 1
+#define CONFIG_HAVE_KERNEL_BZIP2 1
+#define CONFIG_SND_SEQ_HRTIMER_DEFAULT 1
+#define CONFIG_SERIAL_8250_SHARE_IRQ 1
+#define CONFIG_PNPACPI 1
+#define CONFIG_TIMERFD 1
+#define CONFIG_ENABLE_MUST_CHECK 1
+#define CONFIG_RTC_INTF_PROC 1
+#define CONFIG_PATA_MPIIX 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_X86_LOCAL_APIC 1
+#define CONFIG_EXT2_FS_XATTR 1
+#define CONFIG_EDAC 1
+#define CONFIG_SND_HDA_CODEC_VIA 1
+#define CONFIG_BLK_DEV_SD 1
+#define CONFIG_HAS_DMA 1
+#define CONFIG_BLK_DEV_UB 1
+#define CONFIG_THERMAL 1
+#define CONFIG_X86_CPU 1
+#define CONFIG_EXT3_FS_XATTR 1
+#define CONFIG_CFG80211_DEFAULT_PS_VALUE 1
+#define CONFIG_NETFILTER_XT_MATCH_MARK 1
+#define CONFIG_SUN_PARTITION 1
+#define CONFIG_NFS_COMMON 1
+#define CONFIG_X86_TSC 1
+#define CONFIG_SERIO_SERPORT 1
+#define CONFIG_HID_PID 1
+#define CONFIG_SOUND_OSS_CORE_PRECLAIM 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_VM86 1
+#define CONFIG_HPET_TIMER 1
+#define CONFIG_CPU_SUP_TRANSMETA_32 1
+#define CONFIG_VGA_ARB 1
+#define CONFIG_X86_CYCLONE_TIMER 1
+#define CONFIG_NF_NAT_IRC 1
+#define CONFIG_FREEZER 1
+#define CONFIG_CONSOLE_TRANSLATIONS 1
+#define CONFIG_ATA_SFF 1
+#define CONFIG_CHR_DEV_SG 1
+#define CONFIG_VMXNET3 1
+#define CONFIG_HAVE_ATOMIC_IOMAP 1
+#define CONFIG_KEYBOARD_ATKBD 1
+#define CONFIG_NETDEV_10000 1
+#define CONFIG_RCU_FANOUT 32
+#define CONFIG_FDDI 1
+#define CONFIG_BLK_DEV 1
+#define CONFIG_NETFILTER_XT_TARGET_TCPMSS 1
+#define CONFIG_X86_MSR 1
+#define CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS 1
+#define CONFIG_HAS_IOPORT 1
+#define CONFIG_SND_SEQ_DUMMY 1
+#define CONFIG_NF_CONNTRACK_IPV4 1
+#define CONFIG_HAVE_ARCH_KGDB 1
+#define CONFIG_SYSCTL_SYSCALL_CHECK 1
+#define CONFIG_QUOTA_TREE 1
+#define CONFIG_CRYPTO_AES 1
+#define CONFIG_WIRELESS_OLD_REGULATORY 1
+#define CONFIG_SPARSE_IRQ 1
+#define CONFIG_MODULES 1
+#define CONFIG_HAVE_SETUP_PER_CPU_AREA 1
+#define CONFIG_OUTPUT_FORMAT "elf32-i386"
+#define CONFIG_USB_ARCH_HAS_EHCI 1
+#define CONFIG_BNX2 1
+#define CONFIG_BLK_DEV_IDEDMA 1
+#define CONFIG_PARPORT_PC 1
+#define CONFIG_NF_CONNTRACK_IPV6 1
+#define CONFIG_CPU_SUP_INTEL 1
+#define CONFIG_PCI_QUIRKS 1
+#define CONFIG_CRYPTO_AES_586 1
+#define CONFIG_EXT2_FS 1
+#define CONFIG_INPUT_MISC 1
+#define CONFIG_MOUSE_PS2_TRACKPOINT 1
+#define CONFIG_BLK_DEV_SR 1
+#define CONFIG_EXT3_FS 1
+#define CONFIG_VT_CONSOLE 1
+#define CONFIG_CRYPTO_DES 1
+#define CONFIG_DNOTIFY 1
+#define CONFIG_HID_KYE 1
+#define CONFIG_SND_MIXER_OSS 1
+#define CONFIG_SCSI_DH 1
+#define CONFIG_ACPI 1
+#define CONFIG_USB_HID 1
+#define CONFIG_NETPOLL 1
+#define CONFIG_TIPC_ZONES 3
+#define CONFIG_NF_DEFRAG_IPV4 1
+#define CONFIG_RELOCATABLE 1
+#define CONFIG_QFMT_V2 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_I2C_ALGOBIT 1
+#define CONFIG_NF_NAT_FTP 1
+#define CONFIG_NETFILTER_XTABLES 1
+#define CONFIG_ACPI_CONTAINER 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_USER_STACKTRACE_SUPPORT 1
+#define CONFIG_CRYPTO_ALGAPI2 1
+#define CONFIG_SND_PCI 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_X86_TRAMPOLINE 1
+#define CONFIG_NF_NAT_SIP 1
+#define CONFIG_NETFILTER_NETLINK 1
+#define CONFIG_HID_DRAGONRISE 1
+#define CONFIG_NET_PCI 1
+#define CONFIG_SUSPEND 1
+#define CONFIG_X86_GENERIC 1
+#define CONFIG_INOTIFY 1
+#define CONFIG_X86_32_LAZY_GS 1
+#define CONFIG_HAVE_LATENCYTOP_SUPPORT 1
+#define CONFIG_FLATMEM_MANUAL 1
+#define CONFIG_HOTPLUG 1
+#define CONFIG_CGROUPS 1
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+#define CONFIG_SND_PCM 1
+#define CONFIG_DEVPORT 1
+#define CONFIG_BLK_DEV_IDEPCI 1
+#define CONFIG_PCI_MSI 1
+#define CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK 1
+#define CONFIG_MAC80211_RC_DEFAULT "minstrel"
+#define CONFIG_IPV6 1
+#define CONFIG_X86_PPRO_FENCE 1
+#define CONFIG_SUNRPC_GSS 1
+#define CONFIG_TIPC_PORTS 8191
+#define CONFIG_PHYSICAL_ALIGN 0x1000000
+#define CONFIG_FLAT_NODE_MEM_MAP 1
+#define CONFIG_CPUSETS 1
+#define CONFIG_OPTIMIZE_INLINING 1
+#define CONFIG_PARPORT 1
+#define CONFIG_NET_CLS 1
+#define CONFIG_VFAT_FS 1
+#define CONFIG_SKY2 1
+#define CONFIG_SERIAL_8250_PCI 1
+#define CONFIG_IP6_NF_TARGET_LOG 1
+#define CONFIG_RD_LZMA 1
+#define CONFIG_LOCALVERSION_AUTO 1
+#define CONFIG_IO_DELAY_TYPE_UDELAY 2
+#define CONFIG_DRM_I915 1
+#define CONFIG_R8169 1
+#define CONFIG_SATA_MV 1
+#define CONFIG_X86_MCE_AMD 1
+#define CONFIG_GENERIC_ACL 1
+#define CONFIG_SATA_NV 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_SND_HDA_CODEC_ATIHDMI 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
+#define CONFIG_ARCH_HAS_CACHE_LINE_SIZE 1
+#define CONFIG_PANTHERLORD_FF 1
+#define CONFIG_SND_USB 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
+#define CONFIG_IDE_GENERIC 1
+#define CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE 1
+#define CONFIG_X86_CMPXCHG 1
+#define CONFIG_RD_GZIP 1
+#define CONFIG_KEYS_DEBUG_PROC_KEYS 1
+#define CONFIG_EARLY_PRINTK_DBGP 1
+#define CONFIG_TIPC 1
+#define CONFIG_INET 1
+#define CONFIG_ARCH_SPARSEMEM_ENABLE 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_LOGO 1
+#define CONFIG_HPET 1
+#define CONFIG_SYSVIPC 1
+#define CONFIG_DEBUG_MEMORY_INIT 1
+#define CONFIG_VGACON_SOFT_SCROLLBACK_SIZE 64
+#define CONFIG_INPUT_TOUCHSCREEN 1
+#define CONFIG_WLAN 1
+#define CONFIG_ATA_GENERIC 1
+#define CONFIG_SCSI 1
+#define CONFIG_CFG80211_DEFAULT_PS 1
+#define CONFIG_TCP_CONG_CUBIC 1
+#define CONFIG_X86_L1_CACHE_SHIFT 5
+#define CONFIG_CGROUP_CPUACCT 1
+#define CONFIG_USB_MON 1
+#define CONFIG_SERIAL_8250_RSA 1
+#define CONFIG_HIBERNATION 1
+#define CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK 1
+#define CONFIG_HID_KENSINGTON 1
+#define CONFIG_ATA_VERBOSE_ERROR 1
+#define CONFIG_HAVE_IOREMAP_PROT 1
+#define CONFIG_SND_HDA_CODEC_REALTEK 1
+#define CONFIG_ACPI_PROCFS_POWER 1
+#define CONFIG_SLUB 1
+#define CONFIG_DOUBLEFAULT 1
+#define CONFIG_PROC_PAGE_MONITOR 1
+#define CONFIG_VETH 1
+#define CONFIG_IOSCHED_CFQ 1
+#define CONFIG_X86_IO_APIC 1
+#define CONFIG_LOGITECH_FF 1
+#define CONFIG_PAGEFLAGS_EXTENDED 1
+#define CONFIG_NR_CPUS 8
+#define CONFIG_X86_EXTENDED_PLATFORM 1
+#define CONFIG_RESOURCE_COUNTERS 1
+#define CONFIG_ARCH_HAS_DEFAULT_IDLE 1
+#define CONFIG_GENERIC_BUG 1
+#define CONFIG_SERIAL_8250_PNP 1
+#define CONFIG_CRYPTO_MANAGER 1
+#define CONFIG_CPU_FREQ_DEBUG 1
+#define CONFIG_X86_L1_CACHE_BYTES 64
+#define CONFIG_SWAP 1
+#define CONFIG_EXT2_FS_POSIX_ACL 1
+#define CONFIG_KEYS 1
+#define CONFIG_CPU_FREQ_TABLE 1
+#define CONFIG_ACPI_PROCESSOR 1
+#define CONFIG_HAVE_MLOCKED_PAGE_BIT 1
+#define CONFIG_EXT3_FS_POSIX_ACL 1
+#define CONFIG_XFRM 1
+#define CONFIG_CRC32 1
+#define CONFIG_X86_MPPARSE 1
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_DEFAULT_CFQ 1
+#define CONFIG_IP_NF_IPTABLES 1
+#define CONFIG_USER_NS 1
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define CONFIG_INPUT_KEYBOARD 1
+#define CONFIG_EXTRA_FIRMWARE ""
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_HID_CHICONY 1
+#define CONFIG_PACKET_MMAP 1
+#define CONFIG_CGROUP_FREEZER 1
+#define CONFIG_HAVE_DMA_ATTRS 1
+#define CONFIG_SND_SEQUENCER_OSS 1
+#define CONFIG_NETFILTER_XT_TARGET_SECMARK 1
+#define CONFIG_PAGE_OFFSET 0xC0000000
+#define CONFIG_EDAC_DECODE_MCE 1
+#define CONFIG_UNIX 1
+#define CONFIG_CPU_IDLE_GOV_MENU 1
+#define CONFIG_SND_HDA_ELD 1
+#define CONFIG_HAMRADIO 1
+#define CONFIG_ARCH_SELECT_MEMORY_MODEL 1
+#define CONFIG_MTRR 1
+#define CONFIG_PCI_DOMAINS 1
+#define CONFIG_X86_XADD 1
+#define CONFIG_NETLABEL 1
+#define CONFIG_ISA_DMA_API 1
+#define CONFIG_VIDEO_OUTPUT_CONTROL 1
+#define CONFIG_CPU_SUP_UMC_32 1
+#define CONFIG_HID_TOPSEED 1
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_BLK_DEV_SR_VENDOR 1
+#define CONFIG_IP_NF_TARGET_ULOG 1
+#define CONFIG_CRYPTO_AUTHENC 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_PDC_ADMA 1
+#define CONFIG_ACPI_PROCFS 1
+#define CONFIG_SCHED_OMIT_FRAME_POINTER 1
+#define CONFIG_UID16 1
+#define CONFIG_LOCK_KERNEL 1
+#define CONFIG_HAVE_SYSCALL_TRACEPOINTS 1
+#define CONFIG_SCSI_WAIT_SCAN_MODULE 1
+#define CONFIG_CRYPTO_ARC4 1
+#define CONFIG_PHYSICAL_START 0x1000000
+#define CONFIG_CRYPTO_AEAD 1
+#define CONFIG_USB_ANNOUNCE_NEW_DEVICES 1
+#define CONFIG_E1000E 1
+#define CONFIG_NE2K_PCI 1
+#define CONFIG_RFKILL_LEDS 1
+#define CONFIG_BINFMT_MISC 1
+#define CONFIG_DRM_KMS_HELPER 1
+#define CONFIG_MOUSE_PS2_ALPS 1
+#define CONFIG_IDE_TIMINGS 1
+#define CONFIG_NF_CONNTRACK_PROC_COMPAT 1
+#define CONFIG_IP_FIB_HASH 1
+#define CONFIG_DEFAULT_MMAP_MIN_ADDR 4096
+#define CONFIG_HID_TWINHAN 1
+#define CONFIG_CRYPTO_SHA1 1
+#define CONFIG_ARCH_USES_PG_UNCACHED 1
+#define CONFIG_ANON_INODES 1
+#define CONFIG_GENERIC_FIND_LAST_BIT 1
+#define CONFIG_SCSI_CONSTANTS 1
+#define CONFIG_INET6_AH 1
+#define CONFIG_SLABINFO 1
+#define CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST 1
+#define CONFIG_PARTITION_ADVANCED 1
+#define CONFIG_LOGO_LINUX_CLUT224 1
+#define CONFIG_CHELSIO_T3_DEPENDS 1
+#define CONFIG_VGA_CONSOLE 1
+#define CONFIG_PCIEPORTBUS 1
+#define CONFIG_PREEMPT_VOLUNTARY 1
+#define CONFIG_NLS_DEFAULT "utf8"
+#define CONFIG_WATCHDOG 1
+#define CONFIG_SERIAL_8250_DETECT_IRQ 1
+#define CONFIG_CPU_FREQ_GOV_PERFORMANCE 1
+#define CONFIG_ACPI_FAN 1
+#define CONFIG_HID_SAMSUNG 1
+#define CONFIG_ATA_ACPI 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 4
+#define CONFIG_BLK_DEV_BSG 1
+#define CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ 1
+#define CONFIG_YENTA_ENE_TUNE 1
+#define CONFIG_GROUP_SCHED 1
+#define CONFIG_MAC80211_LEDS 1
+#define CONFIG_X86_SUPPORTS_MEMORY_FAILURE 1
+#define CONFIG_HAVE_DMA_API_DEBUG 1
+#define CONFIG_ARCH_WANT_FRAME_POINTERS 1
+#define CONFIG_BLK_DEV_IDEDMA_PCI 1
+#define CONFIG_YENTA_RICOH 1
+#define CONFIG_ARCH_SUPPORTS_MSI 1
+#define CONFIG_HAVE_IDE 1
+#define CONFIG_IO_DELAY_TYPE_0X80 0
+#define CONFIG_LOCKD_V4 1
+#define CONFIG_BLK_DEV_RAM 1
+#define CONFIG_SCHED_MC 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_BACKLIGHT_LCD_SUPPORT 1
+#define CONFIG_INPUT_MOUSEDEV 1
+#define CONFIG_PATA_AMD 1
+#define CONFIG_CHR_DEV_SCH 1
+#define CONFIG_BLK_DEV_IDEDMA_SFF 1
+#define CONFIG_ACPI_BUTTON 1
+#define CONFIG_RT_GROUP_SCHED 1
+#define CONFIG_CRYPTO_RNG2 1
+#define CONFIG_BLK_DEV_SX8 1
+#define CONFIG_CRYPTO_HMAC 1
+#define CONFIG_GENERIC_FIND_NEXT_BIT 1
+#define CONFIG_LBDAF 1
+#define CONFIG_X86_CMOV 1
+#define CONFIG_KERNEL_GZIP 1
+#define CONFIG_SOLARIS_X86_PARTITION 1
+#define CONFIG_SERIAL_NONSTANDARD 1
+#define CONFIG_PATA_ALI 1
+#define CONFIG_SCSI_SAS_LIBSAS_DEBUG 1
+#define CONFIG_X86_ANCIENT_MCE 1
+#define CONFIG_SYSCTL_SYSCALL 1
+#define CONFIG_RD_BZIP2 1
+#define CONFIG_UNIXWARE_DISKLABEL 1
+#define CONFIG_HID_CYPRESS 1
+#define CONFIG_IDE_PROC_FS 1
+#define CONFIG_USB_STORAGE 1
+#define CONFIG_HOTPLUG_PCI 1
+#define CONFIG_PROC_VMCORE 1
+#define CONFIG_SND_HRTIMER 1
+#define CONFIG_SERIAL_8250_RUNTIME_UARTS 4
+#define CONFIG_INPUT_JOYSTICK 1
+#define CONFIG_NET_CLS_ACT 1
+#define CONFIG_ELF_CORE 1
+#define CONFIG_DEBUG_FS 1
+#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define CONFIG_SERIAL_8250_CONSOLE 1
+#define CONFIG_YENTA_O2 1
+#define CONFIG_X86_DEBUGCTLMSR 1
+#define CONFIG_PERF_EVENTS 1
+#define CONFIG_MAGIC_SYSRQ 1
+#define CONFIG_NETFILTER_NETLINK_LOG 1
+#define CONFIG_SND_DRIVERS 1
+#define CONFIG_PATA_SCH 1
+#define CONFIG_SCSI_DMA 1
+#define CONFIG_BLK_DEV_AMD74XX 1
+#define CONFIG_PM_DEBUG 1
+#define CONFIG_DEFAULT_IOSCHED "cfq"
+#define CONFIG_CRYPTO_HASH 1
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_SCSI_SAS_HOST_SMP 1
+#define CONFIG_NETFILTER_XT_MATCH_STATE 1
+#define CONFIG_IP_PIMSM_V1 1
+#define CONFIG_IP_PNP_DHCP 1
+#define CONFIG_X86_THERMAL_VECTOR 1
+#define CONFIG_X86_USE_PPRO_CHECKSUM 1
+#define CONFIG_SOUND_OSS_CORE 1
+#define CONFIG_FB_CFB_COPYAREA 1
+#define CONFIG_SCSI_SAS_ATTRS 1
+#define CONFIG_IP_PIMSM_V2 1
+#define CONFIG_INET_TUNNEL 1
+#define CONFIG_CPU_FREQ_GOV_ONDEMAND 1
+#define CONFIG_CPU_IDLE 1
+#define CONFIG_PRINTK_TIME 1
+#define CONFIG_SND_VMASTER 1
+#define CONFIG_FB_CFB_FILLRECT 1
+#define CONFIG_SYN_COOKIES 1
+#define CONFIG_X86_INTERNODE_CACHE_BYTES 64
+#define CONFIG_DMIID 1
+#define CONFIG_MOUSE_PS2_LIFEBOOK 1
+#define CONFIG_SATA_VIA 1
+#define CONFIG_PROC_EVENTS 1
+#define CONFIG_NETFILTER_XT_TARGET_MARK 1
+#define CONFIG_PCI_BIOS 1
+#define CONFIG_X86_NEED_RELOCS 1
+#define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
+#define CONFIG_INPUT_EVDEV 1
+#define CONFIG_SCSI_SPI_ATTRS 1
+#define CONFIG_SCSI_MULTI_LUN 1
+#define CONFIG_PCMCIA_LOAD_CIS 1
+#define CONFIG_HOTPLUG_CPU 1
+#define CONFIG_GENERIC_ISA_DMA 1
+#define CONFIG_DEFAULT_IO_DELAY_TYPE 0
+#define CONFIG_USB_SUSPEND 1
+#define CONFIG_PNP_DEBUG_MESSAGES 1
+#define CONFIG_PM_TRACE 1
+#define CONFIG_BLOCK 1
+#define CONFIG_SND_OSSEMUL 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BUILD 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_CRYPTO_MANAGER2 1
+#define CONFIG_LOCKD 1
+#define CONFIG_QUOTACTL 1
+#define CONFIG_USB_PRINTER 1
+#define CONFIG_SND_HDA_GENERIC 1
+#define CONFIG_BACKLIGHT_CLASS_DEVICE 1
+#define CONFIG_ZONE_DMA 1
+#define CONFIG_HID_SUNPLUS 1
+#define CONFIG_WIRELESS 1
+#define CONFIG_IP_ADVANCED_ROUTER 1
+#define CONFIG_EFI_VARS 1
+#define CONFIG_ZEROPLUS_FF 1
+#define CONFIG_ATA_PIIX 1
+#define CONFIG_RTC_INTF_SYSFS 1
+#define CONFIG_SATA_SIL 1
+#define CONFIG_KEXEC 1
+#define CONFIG_MICROCODE_INTEL 1
+#define CONFIG_CPU_SUP_AMD 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_ARCH_HIBERNATION_POSSIBLE 1
+#define CONFIG_HID_SUPPORT 1
+#define CONFIG_NEW_LEDS 1
+#define CONFIG_TIPC_LOG 0
+#define CONFIG_NETFILTER_XT_TARGET_CONNSECMARK 1
+#define CONFIG_HAVE_KVM 1
+#define CONFIG_FSNOTIFY 1
+#define CONFIG_FB_TILEBLITTING 1
+#define CONFIG_K8_NB 1
+#define CONFIG_SYSVIPC_SYSCTL 1
+#define CONFIG_HAVE_UNSTABLE_SCHED_CLOCK 1
+#define CONFIG_X86_VERBOSE_BOOTUP 1
+#define CONFIG_NLS_UTF8 1
+#define CONFIG_SND_HDA_CODEC_CA0110 1
+#define CONFIG_FIRMWARE_IN_KERNEL 1
+#define CONFIG_AGP_AMD64 1
+#define CONFIG_VT_HW_CONSOLE_BINDING 1
+#define CONFIG_IPV6_SIT 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_I2C_HELPER_AUTO 1
+#define CONFIG_SATA_PMP 1
+#define CONFIG_IP6_NF_IPTABLES 1
+#define CONFIG_CPU_FREQ 1
+#define CONFIG_PM_SLEEP 1
+#define CONFIG_IO_DELAY_TYPE_0XED 1
+#define CONFIG_HID_PANTHERLORD 1
+#define CONFIG_AMIGA_PARTITION 1
+#define CONFIG_SND_PCM_OSS 1
+#define CONFIG_INPUT_MOUSE 1
+#define CONFIG_SECURITY 1
+#define CONFIG_FIRMWARE_MEMMAP 1
+#define CONFIG_SERIAL_8250_MANY_PORTS 1
+#define CONFIG_TREE_RCU 1
+#define CONFIG_IP_PNP_RARP 1
+#define CONFIG_HIGHMEM4G 1
+#define CONFIG_X86_INTEL_USERCOPY 1
+#define CONFIG_SHMEM 1
+#define CONFIG_SCSI_AIC94XX 1
+#define CONFIG_ARCH_HAS_CPU_RELAX 1
+#define CONFIG_INET_LRO 1
+#define CONFIG_EPOLL 1
+#define CONFIG_CRYPTO_AEAD2 1
+#define CONFIG_HID_SONY 1
+#define CONFIG_YENTA_TI 1
+#define CONFIG_RELAY 1
+#define CONFIG_MSDOS_FS 1
+#define CONFIG_FONT_8x8 1
+#define CONFIG_FB_MODE_HELPERS 1
+#define CONFIG_IP_MULTIPLE_TABLES 1
+#define CONFIG_RPCSEC_GSS_KRB5 1
+#define CONFIG_SND_DYNAMIC_MINORS 1
+#define CONFIG_SCSI_TGT 1
+#define CONFIG_BLK_DEV_IDECD_VERBOSE_ERRORS 1
+#define CONFIG_NLS_CODEPAGE_437 1
+#define CONFIG_YENTA 1
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define CONFIG_HW_RANDOM_GEODE 1
+#define CONFIG_SERIO 1
+#define CONFIG_UEVENT_HELPER_PATH "/sbin/hotplug"
+#define CONFIG_HID_LOGITECH 1
+#define CONFIG_SND_HDA_CODEC_SIGMATEL 1
+#define CONFIG_X86_CHECK_BIOS_CORRUPTION 1
+#define CONFIG_NVRAM 1
+#define CONFIG_X86_32_NON_STANDARD 1
+#define CONFIG_MM_OWNER 1
+#define CONFIG_HAVE_KRETPROBES 1
+#define CONFIG_KARMA_PARTITION 1
+#define CONFIG_NET_VENDOR_3COM 1
+#define CONFIG_CGROUP_MEM_RES_CTLR_SWAP 1
+#define CONFIG_FILE_LOCKING 1
+#define CONFIG_USB_SUPPORT 1
+#define CONFIG_SND_VERBOSE_PROCFS 1
+#define CONFIG_SMSC_PHY 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNTRACK 1
+#define CONFIG_HUGETLB_PAGE 1
+#define CONFIG_PCMCIA_IOCTL 1
+#define CONFIG_MINIX_SUBPARTITION 1
+#define CONFIG_FB 1
+#define CONFIG_DECOMPRESS_LZMA 1
+#define CONFIG_HAVE_ARCH_KMEMCHECK 1
+#define CONFIG_SOUND 1
+#define CONFIG_ACPI_THERMAL 1
+#define CONFIG_HWMON 1
+#define CONFIG_HIBERNATION_NVS 1
+#define CONFIG_ARCH_FLATMEM_ENABLE 1
+#define CONFIG_ROOT_NFS 1
+#define CONFIG_QUOTA 1
+#define CONFIG_TMPFS 1
+#define CONFIG_ASK_IP_FIB_HASH 1
+#define CONFIG_X86_32 1
+#define CONFIG_PCI_MMCONFIG 1
+#define CONFIG_SCHED_HRTICK 1
+#define CONFIG_GENERIC_TIME 1
+#define CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST 1
+#define CONFIG_HAVE_FTRACE_MCOUNT_RECORD 1
+#define CONFIG_FUTEX 1
+#define CONFIG_SND_HDA_CODEC_CONEXANT 1
+#define CONFIG_SERIO_LIBPS2 1
+#define CONFIG_MISC_DEVICES 1
+#define CONFIG_MAC80211_RC_MINSTREL 1
+#define CONFIG_DECOMPRESS_GZIP 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_NETWORK_SECMARK 1
+#define CONFIG_KTIME_SCALAR 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BROADCAST 1
+#define CONFIG_USB_EHCI_HCD 1
+#define CONFIG_INPUT 1
+#define CONFIG_VIRT_TO_BUS 1
+#define CONFIG_EEEPC_LAPTOP 1
+#define CONFIG_ACPI_PROC_EVENT 1
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_USB_DEVICEFS 1
+#define CONFIG_X86_POPAD_OK 1
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_FORCEDETH 1
+#define CONFIG_SUSPEND_FREEZER 1
+#define CONFIG_IOSCHED_DEADLINE 1
+#define CONFIG_SND_HDA_CODEC_SI3054 1
+#define CONFIG_SCSI_SAS_LIBSAS 1
+#define CONFIG_MICROCODE 1
+#define CONFIG_CRYPTO_HASH2 1
+#define CONFIG_IO_DELAY_TYPE_NONE 3
+#define CONFIG_NF_CONNTRACK 1
+#define CONFIG_CGROUP_SCHED 1
+#define CONFIG_FRAMEBUFFER_CONSOLE 1
+#define CONFIG_ACPI_BATTERY 1
+#define CONFIG_PCSPKR_PLATFORM 1
+#define CONFIG_VGACON_SOFT_SCROLLBACK 1
+#define CONFIG_SYSFS 1
+#define CONFIG_X86_CMPXCHG64 1
+#define CONFIG_HAVE_KPROBES 1
+#define CONFIG_USB_OHCI_HCD 1
+#define CONFIG_HW_RANDOM_INTEL 1
+#define CONFIG_X86_CPUID 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_STOP_MACHINE 1
+#define CONFIG_CAN_PM_TRACE 1
+#define CONFIG_HIGH_RES_TIMERS 1
+#define CONFIG_HAVE_DYNAMIC_FTRACE 1
+#define CONFIG_SATA_AHCI 1
+#define CONFIG_ACPI_DOCK 1
+#define CONFIG_PM 1
+#define CONFIG_GENERIC_CLOCKEVENTS 1
+#define CONFIG_SERIAL_8250_EXTENDED 1
+#define CONFIG_PATA_OLDPIIX 1
+#define CONFIG_IP_ROUTE_MULTIPATH 1
+#define CONFIG_NO_HZ 1
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_FB_CFB_IMAGEBLIT 1
+#define CONFIG_IP_NF_MANGLE 1
+#define CONFIG_USB_UHCI_HCD 1
+#define CONFIG_IDE_ATAPI 1
+#define CONFIG_HAVE_ARCH_TRACEHOOK 1
+#define CONFIG_THRUSTMASTER_FF 1
+#define CONFIG_HID_GYRATION 1
+#define CONFIG_X86_PM_TIMER 1
+#define CONFIG_HZ 1000
+#define CONFIG_X86_BSWAP 1
+#define CONFIG_GENERIC_FIND_FIRST_BIT 1
+#define CONFIG_PROC_PID_CPUSET 1
+#define CONFIG_HUGETLBFS 1
+#define CONFIG_TRACING_SUPPORT 1
+#define CONFIG_NLS_ISO8859_1 1
+#define CONFIG_NET_ETHERNET 1
+#define CONFIG_ACPI_BLACKLIST_YEAR 0
+#define CONFIG_HID_APPLE 1
+#define CONFIG_TR 1
+#define CONFIG_X86_RESERVE_LOW_64K 1
+#define CONFIG_USB_OHCI_LITTLE_ENDIAN 1
+#define CONFIG_HID_MONTEREY 1
+#define CONFIG_NET_SCH_FIFO 1
+#define CONFIG_SSB_POSSIBLE 1
+#define CONFIG_HID_PETALYNX 1
+#define CONFIG_X86_MINIMUM_CPU_FAMILY 5
+#define CONFIG_USB_LIBUSUAL 1
+#define CONFIG_VT 1
+#define CONFIG_TICK_ONESHOT 1
+#define CONFIG_TMPFS_POSIX_ACL 1
+#define CONFIG_INPUT_TABLET 1
+#define CONFIG_CONNECTOR 1
+#define CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE 1
+#define CONFIG_GENERIC_PENDING_IRQ 1
+#define CONFIG_FONT_8x16 1
+#define CONFIG_NET_SCHED 1
+#define CONFIG_BRIDGE 1
+#define CONFIG_NETFILTER 1
+#define CONFIG_INET6_ESP 1
+#define CONFIG_PCMCIA 1
+#define CONFIG_PCCARD 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_IDEPCI_PCIBUS_ORDER 1
+#define CONFIG_IP_MULTICAST 1
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define CONFIG_USB_DEBUG 1
+#define CONFIG_BLK_DEV_LOOP 1
+#define CONFIG_CPU_SUP_CENTAUR 1
+#define CONFIG_GENERIC_CMOS_UPDATE 1
+#define CONFIG_I2C_BOARDINFO 1
+#define CONFIG_IP_NF_FILTER 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_ARCH_HAS_CPU_IDLE_WAIT 1
+#define CONFIG_NFS_ACL_SUPPORT 1
+#define CONFIG_EPIC100 1
+#define CONFIG_INET6_XFRM_MODE_TRANSPORT 1
+#define CONFIG_HAS_IOMEM 1
+#define CONFIG_AGP_INTEL 1
+#define CONFIG_RFKILL_INPUT 1
+#define CONFIG_NETFILTER_XT_MATCH_POLICY 1
+#define CONFIG_NETFILTER_XT_TARGET_NFLOG 1
+#define CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS 1
+#define CONFIG_PM_TRACE_RTC 1
+#define CONFIG_FW_LOADER 1
+#define CONFIG_EARLY_PRINTK 1
+#define CONFIG_TIGON3 1
+#define CONFIG_IO_DELAY_0X80 1
+#define CONFIG_NLS_ASCII 1
+#define CONFIG_WIRELESS_EXT_SYSFS 1
+#define CONFIG_MODULE_FORCE_UNLOAD 1
+#define CONFIG_RTC_INTF_DEV 1
+#define CONFIG_X86_ACPI_CPUFREQ 1
+#define CONFIG_ISO9660_FS 1
+#define CONFIG_HID_ZEROPLUS 1
+#define CONFIG_HID_NTRIG 1
+#define CONFIG_PACKET 1
+#define CONFIG_PCI_GOANY 1
+#define CONFIG_CONSTRUCTORS 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_FS_POSIX_ACL 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_SCHED_SMT 1
+#define CONFIG_X86_WP_WORKS_OK 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC 1
+#define CONFIG_FB_EFI 1
+#define CONFIG_IP6_NF_MATCH_IPV6HEADER 1
+#define CONFIG_INET6_XFRM_MODE_TUNNEL 1
+#define CONFIG_FIB_RULES 1
+#define CONFIG_CPU_IDLE_GOV_LADDER 1
+#define CONFIG_DECOMPRESS_BZIP2 1
+#define CONFIG_HID_EZKEY 1
+#define CONFIG_SND_HWDEP 1
+#define CONFIG_MOUSE_PS2_LOGIPS2PP 1
+#define CONFIG_IDE_GD 1
+#define CONFIG_IPV6_NDISC_NODETYPE 1
+#define CONFIG_BOUNCE 1
+#define CONFIG_HAVE_AOUT 1
+#define CONFIG_MOUSE_PS2 1
+#define CONFIG_SCSI_PROC_FS 1
+#define CONFIG_I2C 1
+#define CONFIG_WIRELESS_EXT 1
+#define CONFIG_RTC_CLASS 1
+#define CONFIG_CRYPTO_PCOMP 1
+#define CONFIG_HIDRAW 1
+#define CONFIG_HW_RANDOM 1
+#define CONFIG_CRC_T10DIF 1
+#define CONFIG_PCCARD_NONSTATIC 1
+#define CONFIG_HAVE_MMIOTRACE_SUPPORT 1
+#define CONFIG_INOTIFY_USER 1
+#define CONFIG_X86_HT 1
+#define CONFIG_HZ_1000 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_BSD_DISKLABEL 1
+#define CONFIG_HID_GREENASIA 1
+#define CONFIG_CHR_DEV_OSST 1
+#define CONFIG_MICROCODE_OLD_INTERFACE 1
+#define CONFIG_RFKILL 1
+#define CONFIG_PM_SLEEP_SMP 1
+#define CONFIG_POSIX_MQUEUE 1
+#define CONFIG_SND_TIMER 1
+#define CONFIG_TIPC_ADVANCED 1
+#define CONFIG_RTC_DRV_CMOS 1
+#define CONFIG_MICROCODE_AMD 1
+#define CONFIG_X86 1
+#define CONFIG_JOLIET 1
+#define CONFIG_8139TOO 1
+#define CONFIG_PHYLIB 1
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_DCB 1
+#define CONFIG_IP_PNP_BOOTP 1
+#define CONFIG_DEFAULT_CUBIC 1
+#define CONFIG_CPU_FREQ_GOV_USERSPACE 1
+#define CONFIG_SND_HDA_CODEC_INTELHDMI 1
+#define CONFIG_CFG80211 1
+#define CONFIG_HID_A4TECH 1
+#define CONFIG_MAC80211 1
+#define CONFIG_NET_EMATCH_STACK 32
+#define CONFIG_IP_NF_TARGET_REJECT 1
+#define CONFIG_NFS_V3 1
+#define CONFIG_BLK_DEV_IDECD 1
+#define CONFIG_X86_REBOOTFIXUPS 1
+#define CONFIG_NFS_V4 1
+#define CONFIG_JBD 1
+#define CONFIG_SND_HDA_CODEC_CMEDIA 1
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define CONFIG_BLK_DEV_IDE_SATA 1
+#define CONFIG_CGROUP_NS 1
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define CONFIG_BSD_PROCESS_ACCT 1
+#define CONFIG_IDE 1
+#define CONFIG_GENERIC_IOMAP 1
+#define CONFIG_FAT_FS 1
+#define CONFIG_NF_CONNTRACK_IRC 1
+#define CONFIG_NET_TULIP 1
+#define CONFIG_CRYPTO_BLKCIPHER 1
+#define CONFIG_IP_MROUTE 1
+#define CONFIG_EFI 1
+#define CONFIG_SPARSEMEM_STATIC 1
+#define CONFIG_FAIR_GROUP_SCHED 1
+#define CONFIG_DMADEVICES 1
+#define CONFIG_HID 1
+#define CONFIG_IP6_NF_MANGLE 1
+#define CONFIG_NLATTR 1
+#define CONFIG_X86_MCE_INTEL 1
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_E100 1
+#define CONFIG_ATA 1
+#define CONFIG_NF_NAT 1
+#define CONFIG_HAVE_KERNEL_LZMA 1
+#define CONFIG_AGP 1
+#define CONFIG_PRINTK 1
+#define CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING 1
+#define CONFIG_POWER_SUPPLY 1
+#define CONFIG_AIO 1
+#define CONFIG_X86_32_SMP 1
+#define CONFIG_MOUSE_PS2_SYNAPTICS 1
+#define CONFIG_NF_NAT_NEEDED 1
+#define CONFIG_DMI 1
+#define CONFIG_HAVE_FUNCTION_GRAPH_TRACER 1
+#define CONFIG_SUNRPC 1
+#define CONFIG_FS_MBCACHE 1
+#define CONFIG_SERIAL_8250_NR_UARTS 32
+#define CONFIG_BLK_DEV_PLATFORM 1
+#define CONFIG_LLC 1
+#define CONFIG_XFRM_USER 1
+#define CONFIG_PCI 1
+#define CONFIG_IPC_NS 1
+#define CONFIG_AMD8111_ETH 1
+#define CONFIG_INITRAMFS_SOURCE ""
+#define CONFIG_PID_NS 1
+#define CONFIG_HAVE_KERNEL_GZIP 1
+#define CONFIG_ZISOFS 1
+#define CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG 1
+#define CONFIG_BUG 1
+#define CONFIG_CRYPTO_HW 1
+#define CONFIG_NFS_FS 1
+#define CONFIG_SND_HDA_CODEC_ANALOG 1
+#define CONFIG_PCNET32 1
+#define CONFIG_MII 1
+#define CONFIG_NF_CONNTRACK_FTP 1
+#define CONFIG_CGROUP_DEVICE 1
+#define CONFIG_NET_POLL_CONTROLLER 1
+#define CONFIG_NAMESPACES 1
+#define CONFIG_NETWORK_FILESYSTEMS 1
+#define CONFIG_I2C_COMPAT 1
+#define CONFIG_FIX_EARLYCON_MEM 1
+#define CONFIG_NF_CONNTRACK_SIP 1
+#define CONFIG_CRYPTO 1
+#define CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB 1
+#define CONFIG_TIPC_SLAVE_NODES 0
+#define CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_MISC_FILESYSTEMS 1
+#define CONFIG_DRM 1
+#define CONFIG_HAVE_OPROFILE 1
+#define CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK 1
+#define CONFIG_HAVE_PERF_EVENTS 1
+#define CONFIG_BACKLIGHT_GENERIC 1
+#define CONFIG_SND 1
+#define CONFIG_HPET_EMULATE_RTC 1
+#define CONFIG_NETDEV_1000 1
+#define CONFIG_IP_PNP 1
+#define CONFIG_ACPI_HOTPLUG_CPU 1
+#define CONFIG_ZONE_DMA_FLAG 1
+#define CONFIG_RWSEM_XCHGADD_ALGORITHM 1
+#define CONFIG_IP6_NF_FILTER 1
+#define CONFIG_HT_IRQ 1
+#define CONFIG_NET_NS 1
+#define CONFIG_NET 1
+#define CONFIG_SND_HDA_HWDEP 1
+#define CONFIG_MODULE_UNLOAD 1
+#define CONFIG_HID_BELKIN 1
+#define CONFIG_STANDALONE 1
+#define CONFIG_KALLSYMS_EXTRA_PASS 1
+#define CONFIG_MAC_PARTITION 1
+#define CONFIG_HID_THRUSTMASTER 1
+#define CONFIG_HID_MICROSOFT 1
+#define CONFIG_NETDEVICES 1
+#define CONFIG_IDE_XFER_MODE 1
+#define CONFIG_USB 1
+#define CONFIG_YENTA_TOSHIBA 1
+#define CONFIG_CGROUP_MEM_RES_CTLR 1
+#define CONFIG_X86_PLATFORM_DEVICES 1
+#define CONFIG_SND_HDA_INTEL 1
+#define CONFIG_SND_DMA_SGBUF 1
+#define CONFIG_EFI_PARTITION 1
+#define CONFIG_NLS 1
+#define CONFIG_CLOCKSOURCE_WATCHDOG 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_QUOTA_NETLINK_INTERFACE 1
+#define CONFIG_SERIAL_8250 1
+#define CONFIG_LEDS_TRIGGERS 1
+#define CONFIG_PNP 1
+#define CONFIG_SND_SEQUENCER 1
+#define CONFIG_TCP_MD5SIG 1
+#define CONFIG_MMU 1
+#define CONFIG_HW_RANDOM_AMD 1
+#define CONFIG_INPUT_FF_MEMLESS 1
+#define CONFIG_BLK_DEV_RAM_SIZE 16384
+#define CONFIG_SMP 1
+#define CONFIG_HID_SMARTJOYPLUS 1
+#define CONFIG_SND_PCMCIA 1
+#define CONFIG_IDE_GD_ATA 1
+#define CONFIG_CPU_SUP_CYRIX_32 1
+#define CONFIG_M686 1
+#define CONFIG_EXT2_FS_SECURITY 1
+#define CONFIG_MAC80211_RC_DEFAULT_MINSTREL 1
+#define CONFIG_IOSCHED_AS 1
+#define CONFIG_EXT3_FS_SECURITY 1
+#define CONFIG_SND_HDA_CODEC_NVHDMI 1
+#define CONFIG_NET_PCMCIA 1
+#define CONFIG_IP_NF_TARGET_LOG 1
+#define CONFIG_ACPI_VIDEO 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_X86_INVLPG 1
+#define CONFIG_ACPI_SLEEP 1
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_PCI_DIRECT 1
+#define CONFIG_STP 1
+#define CONFIG_SND_SUPPORT_OLD_API 1
+#define CONFIG_SERIO_I8042 1
+#define CONFIG_NET_EMATCH 1
+#define CONFIG_SND_PCM_OSS_PLUGINS 1
+#define CONFIG_IP_NF_TARGET_MASQUERADE 1
+#define CONFIG_PCIEAER 1
+#define CONFIG_HAVE_MLOCK 1
+#define CONFIG_NETCONSOLE 1
+#define CONFIG_X86_MCE 1
+#define CONFIG_SCSI_LOWLEVEL 1
+#define CONFIG_BITREVERSE 1
+#define CONFIG_NF_CONNTRACK_SECMARK 1
+#define CONFIG_LOG_BUF_SHIFT 18
+#define CONFIG_SGI_PARTITION 1
+#define CONFIG_IP_ROUTE_VERBOSE 1
+#define CONFIG_SLUB_DEBUG 1
+#define CONFIG_UTS_NS 1
+#define CONFIG_ARCH_POPULATES_NODE_MAP 1
+#define CONFIG_USB_HIDDEV 1
+#define CONFIG_LEDS_CLASS 1
+#define CONFIG_NFS_V3_ACL 1
+#define CONFIG_AUTOFS4_FS 1
+#define CONFIG_DUMMY_CONSOLE 1
+#define CONFIG_HW_RANDOM_VIA 1
+#define CONFIG_NF_CT_NETLINK 1
+#define CONFIG_I2C_I801 1
+#define CONFIG_HIGHMEM 1
diff -Naur /home/jara/linux-2.6.32/include/linux/init_task.h /usr/src/linux/include/linux/init_task.h
--- /home/jara/linux-2.6.32/include/linux/init_task.h	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/include/linux/init_task.h	2013-01-21 07:40:00.000000000 -0300
@@ -171,7 +171,10 @@
 	.fs_excl	= ATOMIC_INIT(0),				\
 	.pi_lock	= __SPIN_LOCK_UNLOCKED(tsk.pi_lock),		\
 	.timer_slack_ns = 50000, /* 50 usec default slack */		\
-	.pids = {							\
+	.proc_ptr = NULL,			\
+	.proc_mutex =						\
+		 __MUTEX_INITIALIZER(tsk.proc_mutex),		\
+	 .pids = {							\
 		[PIDTYPE_PID]  = INIT_PID_LINK(PIDTYPE_PID),		\
 		[PIDTYPE_PGID] = INIT_PID_LINK(PIDTYPE_PGID),		\
 		[PIDTYPE_SID]  = INIT_PID_LINK(PIDTYPE_SID),		\
diff -Naur /home/jara/linux-2.6.32/include/linux/mm.h /usr/src/linux/include/linux/mm.h
--- /home/jara/linux-2.6.32/include/linux/mm.h	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/include/linux/mm.h	2013-01-08 16:16:00.000000000 -0300
@@ -823,6 +823,10 @@
 			struct page **pages, struct vm_area_struct **vmas);
 int get_user_pages_fast(unsigned long start, int nr_pages, int write,
 			struct page **pages);
+/* MOL IPC */
+int mol_gup_fast(struct mm_struct *mm, unsigned long start, int nr_pages, int write,
+			struct page **pages);
+
 struct page *get_dump_page(unsigned long addr);
 
 extern int try_to_release_page(struct page * page, gfp_t gfp_mask);
diff -Naur /home/jara/linux-2.6.32/include/linux/sched.h /usr/src/linux/include/linux/sched.h
--- /home/jara/linux-2.6.32/include/linux/sched.h	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/include/linux/sched.h	2013-01-21 07:35:00.000000000 -0300
@@ -1539,6 +1539,11 @@
 	unsigned long trace_recursion;
 #endif /* CONFIG_TRACING */
 	unsigned long stack_start;
+	
+/* MOL-IPC proc_t pointer definded as void */
+	void 		*proc_ptr;
+   struct 		mutex proc_mutex;		
+
 };
 
 /* Future-safe accessor for struct task_struct's cpus_allowed. */
diff -Naur /home/jara/linux-2.6.32/include/linux/utsrelease.h /usr/src/linux/include/linux/utsrelease.h
--- /home/jara/linux-2.6.32/include/linux/utsrelease.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/linux/utsrelease.h	2012-08-04 07:03:28.000000000 -0300
@@ -0,0 +1 @@
+#define UTS_RELEASE "2.6.32"
diff -Naur /home/jara/linux-2.6.32/include/linux/version.h /usr/src/linux/include/linux/version.h
--- /home/jara/linux-2.6.32/include/linux/version.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/linux/version.h	2012-08-04 07:03:28.000000000 -0300
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 132640
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff -Naur /home/jara/linux-2.6.32/include/minix/ansi.h /usr/src/linux/include/minix/ansi.h
--- /home/jara/linux-2.6.32/include/minix/ansi.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/ansi.h	2005-09-13 22:59:00.000000000 -0300
@@ -0,0 +1,69 @@
+/* The <ansi.h> header attempts to decide whether the compiler has enough
+ * conformance to Standard C for Minix to take advantage of.  If so, the
+ * symbol _ANSI is defined (as 31459).  Otherwise _ANSI is not defined
+ * here, but it may be defined by applications that want to bend the rules.
+ * The magic number in the definition is to inhibit unnecessary bending
+ * of the rules.  (For consistency with the new '#ifdef _ANSI" tests in
+ * the headers, _ANSI should really be defined as nothing, but that would
+ * break many library routines that use "#if _ANSI".)
+
+ * If _ANSI ends up being defined, a macro
+ *
+ *	_PROTOTYPE(function, params)
+ *
+ * is defined.  This macro expands in different ways, generating either
+ * ANSI Standard C prototypes or old-style K&R (Kernighan & Ritchie)
+ * prototypes, as needed.  Finally, some programs use _CONST, _VOIDSTAR etc
+ * in such a way that they are portable over both ANSI and K&R compilers.
+ * The appropriate macros are defined here.
+ */
+
+#ifndef _ANSI_H
+#define _ANSI_H
+
+#if __STDC__ == 1
+#define _ANSI		31459	/* compiler claims full ANSI conformance */
+#endif
+
+#ifdef __GNUC__
+#define _ANSI		31459	/* gcc conforms enough even in non-ANSI mode */
+#endif
+
+#ifdef _ANSI
+
+/* Keep everything for ANSI prototypes. */
+#define	_PROTOTYPE(function, params)	function params
+#define	_ARGS(params)			params
+
+#define	_VOIDSTAR	void *
+#define	_VOID		void
+#define	_CONST		const
+#define	_VOLATILE	volatile
+#define _SIZET		size_t
+
+#else
+
+/* Throw away the parameters for K&R prototypes. */
+#define	_PROTOTYPE(function, params)	function()
+#define	_ARGS(params)			()
+
+#define	_VOIDSTAR	void *
+#define	_VOID		void
+#define	_CONST
+#define	_VOLATILE
+#define _SIZET		int
+
+#endif /* _ANSI */
+
+/* This should be defined as restrict when a C99 compiler is used. */
+#define _RESTRICT
+
+/* Setting any of _MINIX, _POSIX_C_SOURCE or _POSIX2_SOURCE implies
+ * _POSIX_SOURCE.  (Seems wrong to put this here in ANSI space.)
+ */
+#if defined(_MINIX) || _POSIX_C_SOURCE > 0 || defined(_POSIX2_SOURCE)
+#undef _POSIX_SOURCE
+#define _POSIX_SOURCE	1
+#endif
+
+#endif /* ANSI_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/callnr.h /usr/src/linux/include/minix/callnr.h
--- /home/jara/linux-2.6.32/include/minix/callnr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/callnr.h	2013-08-06 02:18:00.000000000 -0300
@@ -0,0 +1,104 @@
+
+#ifdef MOLAUTOFORK
+#define NCALLS		  97	/* number of system calls allowed */
+#else /*MOLAUTOFORK */
+#define NCALLS		  96	/* number of system calls allowed */
+#endif /*MOLAUTOFORK */
+
+#define MOLUNUSED		0
+#define MOLEXIT		   1 
+#define MOLFORK		   2 
+#define MOLREAD		   3 
+#define MOLWRITE		   4 
+#define MOLOPEN		   5 
+#define MOLCLOSE		   6 
+#define MOLWAIT		   7
+#define MOLCREAT		   8 
+#define MOLLINK		   9 
+#define MOLUNLINK		  10 
+#define MOLWAITPID		  11
+#define MOLCHDIR		  12 
+#define MOLTIME		  13
+#define MOLMKNOD		  14 
+#define MOLCHMOD		  15 
+#define MOLCHOWN		  16 
+#define MOLBRK		  17
+#define MOLSTAT		  18 
+#define MOLLSEEK		  19
+#define MOLGETPID		  20
+#define MOLMOUNT		  21 
+#define MOLUMOUNT		  22 
+#define MOLSETUID		  23
+#define MOLGETUID		  24
+#define MOLSTIME		  25
+#define MOLPTRACE		  26
+#define MOLALARM		  27
+#define MOLFSTAT		  28 
+#define MOLPAUSE		  29
+#define MOLUTIME		  30 
+#define MOLACCESS		  33 
+#define MOLSYNC		  36 
+#define MOLKILL		  37
+#define MOLRENAME		  38
+#define MOLMKDIR		  39
+#define MOLRMDIR		  40
+#define MOLDUP		  41 
+#define MOLPIPE		  42 
+#define MOLTIMES		  43
+#define MOLSYMLINK		  45
+#define MOLSETGID		  46
+#define MOLGETGID		  47
+#define MOLSIGNAL		  48
+#define MOLRDLNK		  49
+#define MOLLSTAT		  50
+#define MOLIOCTL		  54
+#define MOLFCNTL		  55
+#define MOLEXEC		  59
+#define MOLUMASK		  60 
+#define MOLCHROOT		  61 
+#define MOLSETSID		  62
+#define MOLGETPGRP		  63
+
+/* The following are not system calls, but are processed like them. */
+#define MOLUNPAUSE		  65	/* to MM or FS: check for EINTR */
+#define MOLREVIVE	 	  67	/* to FS: revive a sleeping process */
+#define MOLTASK_REPLY	  68	/* to FS: reply code from tty task */
+
+/* Posix signal handling. */
+#define MOLSIGACTION	  71
+#define MOLSIGSUSPEND	  72
+#define MOLSIGPENDING	  73
+#define MOLSIGPROCMASK	  74
+#define MOLSIGRETURN	  75
+
+#define MOLREBOOT		  76	/* to PM */
+
+/* MINIX specific calls, e.g., to support system services. */
+#define MOLSVRCTL		  77
+#define MOLPROCSTAT          78    /* to PM */
+#define MOLGETSYSINFO	  79	/* to PM or FS */
+#define MOLGETPROCNR         80    /* to PM */
+#define MOLDEVCTL		  81    /* to FS */
+#define MOLFSTATFS	 	  82	/* to FS */
+#define MOLALLOCMEM	  83	/* to PM */
+#define MOLFREEMEM		  84	/* to PM */
+#define MOLSELECT            85	/* to FS */
+#define MOLFCHDIR            86	/* to FS */
+#define MOLFSYNC             87	/* to FS */
+#define MOLGETPRIORITY       88	/* to PM */
+#define MOLSETPRIORITY       89	/* to PM */
+#define MOLGETTIMEOFDAY      90	/* to PM */
+#define MOLSETEUID		  91	/* to PM */
+#define MOLSETEGID		  92	/* to PM */
+#define MOLTRUNCATE	  93	/* to FS */
+#define MOLFTRUNCATE	  94	/* to FS */
+
+#ifdef MOLAUTOFORK
+#define MOLFREEPROC	  95	/* to PM: Sent by the parent process when it does fork() */
+#define MOLBINDPROC	  96	/* to PM: Sent by the parent process when it does fork() */
+#else /*MOLAUTOFORK */
+#define MOLBINDPROC	  95	/* to PM: When a registered system process needs to register to PM and SYSTASK  */
+#endif /*MOLAUTOFORK */
+
+
+
diff -Naur /home/jara/linux-2.6.32/include/minix/cmd.h /usr/src/linux/include/minix/cmd.h
--- /home/jara/linux-2.6.32/include/minix/cmd.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/cmd.h	2013-09-29 21:09:00.000000000 -0300
@@ -0,0 +1,69 @@
+
+/* COMMANDS 	*/
+  enum proxy_cmd{
+        CMD_NONE       =  0,	/* NO COMMAND  						*/
+		CMD_SEND_MSG,		/*  Send a message to a process 					*/
+		CMD_NTFY_MSG,		/* Send a NOTIFY message to remote proces  		*/
+		CMD_SNDREC_MSG,		/*  Send a message to a process and wait for reply 		*/
+		CMD_REPLY_MSG,		/*  Send a REPLY message to a process 				*/
+		CMD_COPYIN_DATA,	/* Request and data to copy data to remote process 		*/
+		CMD_COPYOUT_RQST,	/* The remote process send to local process the data requested 	*/
+		CMD_COPYLCL_RQST,
+		CMD_COPYRMT_RQST,	/* REQUESTER to SENDER to copy data out to RECEIVER */
+		CMD_COPYIN_RQST,	/* SENDER to RECEIVER */
+        CMD_HELL0,			/* HELLO COMMAND used by proxies 				*/
+		CMD_SHUTDOWN,		/* Exit the waiting loop with error	EMOLINTR */
+  };
+
+#define CMD_SEND_ACK		(CMD_SEND_MSG | CMD_ACKNOWLEDGE) 
+#define CMD_NTFY_ACK		(CMD_NTFY_MSG | CMD_ACKNOWLEDGE)
+#define CMD_SNDREC_ACK  	(CMD_SNDREC_MSG | CMD_ACKNOWLEDGE)
+#define	CMD_REPLY_ACK   	(CMD_REPLY_MSG  | CMD_ACKNOWLEDGE)
+#define	CMD_COPYIN_ACK 		(CMD_COPYIN_DATA | CMD_ACKNOWLEDGE)
+#define	CMD_COPYOUT_DATA 	(CMD_COPYOUT_RQST | CMD_ACKNOWLEDGE)
+#define	CMD_COPYLCL_ACK		(CMD_COPYLCL_RQST | CMD_ACKNOWLEDGE)
+#define CMD_COPYRMT_ACK 	(CMD_COPYRMT_RQST | CMD_ACKNOWLEDGE) /* From RECEIVER to REQUESTER */
+
+  
+struct vcopy_s {
+	int	v_src;		/* source endpoint		*/
+	int	v_dst;		/* destination endpoint		*/
+  	int	v_rqtr;		/* requester endpoint		*/
+	void 	*v_saddr;	/* virtual address copy from 	*/
+  	void 	*v_daddr;	/* virtual address copy to 	*/
+  	int	v_bytes;	/* bytes to copy		*/
+};
+typedef struct vcopy_s vcopy_t;
+
+struct cmd_s {
+	int	c_cmd;		
+	int 	c_vmid;		/* VM ID				*/
+	int	c_src;		/* source endpoint			*/
+	int	c_dst;		/* destination endpoint			*/
+	int	c_snode;	/* source node				*/
+	int	c_dnode;	/* destination node			*/
+	int 	c_rcode;	/* return code 				*/
+  	int 	c_len;		/* payload len 				*/
+struct timespec c_timestamp;	/* timestamp				*/
+	vcopy_t c_vcopy;	/* struct used only for remote vcopy 	*/
+};
+typedef struct cmd_s cmd_t;
+
+#define CMD_FORMAT "cmd=%d vmid=%d src=%d dst=%d snode=%d dnode=%d rcode=%d len=%d\n" 
+#define CMD_FIELDS(p) 	p->c_cmd, p->c_vmid, p->c_src, p->c_dst, p->c_snode \
+	, p->c_dnode, p->c_rcode, p->c_len 
+
+
+#define VCOPY_FORMAT "src=%d dst=%d rqtr=%d saddr=%p daddr=%p bytes=%d \n"
+#define VCOPY_FIELDS(p) p->c_vcopy.v_src, p->c_vcopy.v_dst, p->c_vcopy.v_rqtr,\
+	 p->c_vcopy.v_saddr, p->c_vcopy.v_daddr, p->c_vcopy.v_bytes
+
+#define	HDR_PAYLOAD_MASK	0x1000	/* it means that thereis another header */
+
+#define HDR_FORMAT 	CMD_FORMAT
+#define HDR_FIELDS(p)	CMD_FIELDS(p)
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/include/minix/com.h /usr/src/linux/include/minix/com.h
--- /home/jara/linux-2.6.32/include/minix/com.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/com.h	2014-06-17 09:12:58.000000000 -0300
@@ -0,0 +1,566 @@
+#ifndef _MINIX_COM_H
+#define _MINIX_COM_H 
+
+#define 	OK		0
+
+#define 	TRUE	1
+#define 	FALSE	0
+
+#define TIMEOUT_NOWAIT			0	
+#define TIMEOUT_FOREVER			(-1)
+
+#define MIGR_START		0
+#define MIGR_COMMIT		1
+#define MIGR_ROLLBACK	2
+
+#define SELF_BIND		0
+#define LCL_BIND		1
+#define RMT_BIND		2
+#define BKUP_BIND		3
+
+/*===========================================================================*
+ *          	    		Magic process numbers			     *
+ *===========================================================================*/
+
+
+/* These may not be any valid endpoint (see <minix/endpoint.h>). */
+#define ANY		0x7ace	/* used to indicate 'any process' */
+#define NONE 		0x6ace  /* used to indicate 'no process at all' */
+#define SELF		0x8ace 	/* used to indicate 'own process' */
+#define _MAX_MAGIC_PROC (SELF)	/* used by <minix/endpoint.h> 
+				   to determine generation size */
+
+#define LOCALNODE		(-1) /* The node id of processes running local */
+
+#define MIN(x,y) 	(x<y)?x:y;
+#define MAX(x,y) 	(x>y)?x:y;
+
+/*===========================================================================*
+ *            	Process numbers of processes in the system image	     *
+ *===========================================================================*/
+
+/* The values of several task numbers depend on whether they or other tasks
+ * are enabled. They are defined as (PREVIOUS_TASK - ENABLE_TASK) in general.
+ * ENABLE_TASK is either 0 or 1, so a task either gets a new number, or gets
+ * the same number as the previous task and is further unused. Note that the
+ * order should correspond to the order in the task table defined in table.c. 
+ */
+
+
+/* Kernel tasks. These all run in the same address space. */
+#define KERNEL           -1			/* pseudo-process for IPC and scheduling */
+#define HARDWARE     KERNEL			/* for hardware interrupt handlers */
+#define SYSTEM           -2			/* request system functionality */
+#define CLOCK  		 (SYSTEM-_NR_SYSTASKS)	/* process number until NR_NODES System tasks */
+#define IDLE             (CLOCK-1)		/* runs when no one else can run */
+
+
+/* Number of tasks. Note that NR_PROCS is defined in <minix/config.h>. */
+/* !!!!!!!!!!!!!!! IT MUST BE LOWER THAN  (-EMOLBUSY) = 16 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11*/
+#define NR_TASKS	  _NR_TASKS 
+
+
+/* User-space processes, that is, device drivers, servers, and INIT. */
+#define PM_PROC_NR	  0			/* process manager */
+#define FS_PROC_NR 	  (PM_PROC_NR+1)	/* file system */
+#define RS_PROC_NR 	  (FS_PROC_NR+1)	/* reincarnation server */
+#define MEM_PROC_NR 	  (RS_PROC_NR+1)	/* memory driver (RAM disk, null, etc.) */
+#define LOG_PROC_NR	  (MEM_PROC_NR+1)	/* log device driver */
+#define TTY_PROC_NR	  (LOG_PROC_NR+1)	/* terminal (TTY) driver */
+#define DS_PROC_NR	  (TTY_PROC_NR+1)	/* data store server */
+#define IS_PROC_NR	  (DS_PROC_NR+1) 	/* Information Server*/
+#define INIT_PROC_NR	  (IS_PROC_NR+1)  	/* init -- goes multiuser */
+
+#define FIRST_USER_NR	   (NR_SYS_PROCS)
+
+/* Number of processes contained in the system image. */
+#define NR_BOOT_PROCS 	(NR_TASKS + INIT_PROC_NR + 1)
+
+/*===========================================================================*
+ *                	   Kernel notification types                         *
+ *===========================================================================*/
+
+/* Kernel notification types. In principle, these can be sent to any process,
+ * so make sure that these types do not interfere with other message types.
+ * Notifications are prioritized because of the way they are unhold() and
+ * blocking notifications are delivered. The lowest numbers go first. The
+ * offset are used for the per-process notification bit maps. 
+ */
+#define NOTIFY_MESSAGE		  0x1000
+#define NOTIFY_FROM(p)	 (NOTIFY_MESSAGE | (p)) 
+#  define PROC_EVENT	NOTIFY_FROM(PM_PROC_NR) /* process status change */
+#  define SYN_ALARM	NOTIFY_FROM(CLOCK) 	/* synchronous alarm */
+#  define SYS_SIG	NOTIFY_FROM(SYSTEM) 	/* system signal */
+#  define HARD_INT	NOTIFY_FROM(HARDWARE) 	/* hardware interrupt */
+#  define NEW_KSIG	NOTIFY_FROM(HARDWARE)  	/* new kernel signal */
+#  define FKEY_PRESSED	NOTIFY_FROM(TTY_PROC_NR)/* function key press */
+#  define DEV_PING	NOTIFY_FROM(RS_PROC_NR) /* driver liveness ping */
+
+/* Shorthands for message parameters passed with notifications. */
+#define NOTIFY_SOURCE		m_source
+#define NOTIFY_TYPE		m_type
+#define NOTIFY_FLAGS		m9_i1
+#define NOTIFY_ARG		m9_l1
+#define NOTIFY_TIMESTAMP	m9_t1  
+
+/*===========================================================================*
+ *                Messages for BUS controller drivers 			     *
+ *===========================================================================*/
+#define BUSC_RQ_BASE	0x300	/* base for request types */
+#define BUSC_RS_BASE	0x380	/* base for response types */
+
+#define BUSC_PCI_INIT		(BUSC_RQ_BASE + 0)	/* First message to
+							 * PCI driver
+							 */
+#define BUSC_PCI_FIRST_DEV	(BUSC_RQ_BASE + 1)	/* Get index (and
+							 * vid/did) of the
+							 * first PCI device
+							 */
+#define BUSC_PCI_NEXT_DEV	(BUSC_RQ_BASE + 2)	/* Get index (and
+							 * vid/did) of the
+							 * next PCI device
+							 */
+#define BUSC_PCI_FIND_DEV	(BUSC_RQ_BASE + 3)	/* Get index of a
+							 * PCI device based on
+							 * bus/dev/function
+							 */
+#define BUSC_PCI_IDS		(BUSC_RQ_BASE + 4)	/* Get vid/did from an
+							 * index
+							 */
+#define BUSC_PCI_DEV_NAME	(BUSC_RQ_BASE + 5)	/* Get the name of a
+							 * PCI device
+							 */
+#define BUSC_PCI_SLOT_NAME	(BUSC_RQ_BASE + 6)	/* Get the name of a
+							 * PCI slot
+							 */
+#define BUSC_PCI_RESERVE	(BUSC_RQ_BASE + 7)	/* Reserve a PCI dev */
+#define BUSC_PCI_ATTR_R8	(BUSC_RQ_BASE + 8)	/* Read 8-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_R16	(BUSC_RQ_BASE + 9)	/* Read 16-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_R32	(BUSC_RQ_BASE + 10)	/* Read 32-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W8	(BUSC_RQ_BASE + 11)	/* Write 8-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W16	(BUSC_RQ_BASE + 12)	/* Write 16-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W32	(BUSC_RQ_BASE + 13)	/* Write 32-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_RESCAN		(BUSC_RQ_BASE + 14)	/* Rescan bus */
+
+/*===========================================================================*
+ *                Messages for BLOCK and CHARACTER device drivers	     *
+ *===========================================================================*/
+
+/* Message types for device drivers. */
+#define DEV_RQ_BASE   0x400	/* base for device request types */
+#define DEV_RS_BASE   0x500	/* base for device response types */
+
+#define CANCEL       	(DEV_RQ_BASE +  0) /* force a task to cancel */
+#define DEV_READ	(DEV_RQ_BASE +  3) /* read from minor device */
+#define DEV_WRITE   	(DEV_RQ_BASE +  4) /* write to minor device */
+#define DEV_IOCTL    	(DEV_RQ_BASE +  5) /* I/O control code */
+#define DEV_OPEN     	(DEV_RQ_BASE +  6) /* open a minor device */
+#define DEV_CLOSE    	(DEV_RQ_BASE +  7) /* close a minor device */
+#define DEV_SCATTER  	(DEV_RQ_BASE +  8) /* write from a vector */
+#define DEV_GATHER   	(DEV_RQ_BASE +  9) /* read into a vector */
+#define TTY_SETPGRP 	(DEV_RQ_BASE + 10) /* set process group */
+#define TTY_EXIT	(DEV_RQ_BASE + 11) /* process group leader exited */	
+#define DEV_SELECT	(DEV_RQ_BASE + 12) /* request select() attention */
+#define DEV_STATUS   	(DEV_RQ_BASE + 13) /* request driver status */
+
+#define DEV_REPLY       (DEV_RS_BASE + 0) /* general task reply */
+#define DEV_CLONED      (DEV_RS_BASE + 1) /* return cloned minor */
+#define DEV_REVIVE      (DEV_RS_BASE + 2) /* driver revives process */
+#define DEV_IO_READY    (DEV_RS_BASE + 3) /* selected device ready */
+#define DEV_NO_STATUS   (DEV_RS_BASE + 4) /* empty status reply */
+
+/* Field names for messages to block and character device drivers. */
+#define DEVICE    	m2_i1	/* major-minor device */
+#define IO_ENDPT	m2_i2	/* which (proc/endpoint) wants I/O? */
+#define COUNT   	m2_i3	/* how many bytes to transfer */
+#define REQUEST 	m2_i3	/* ioctl request code */
+#define POSITION	m2_l1	/* file offset */
+#define ADDRESS 	m2_p1	/* core buffer address */
+
+/* Field names for DEV_SELECT messages to device drivers. */
+#define DEV_MINOR	m2_i1	/* minor device */
+#define DEV_SEL_OPS	m2_i2	/* which select operations are requested */
+#define DEV_SEL_WATCH	m2_i3	/* request notify if no operations are ready */
+
+/* Field names used in reply messages from tasks. */
+#define REP_ENDPT	m2_i1	/* # of proc on whose behalf I/O was done */
+#define REP_STATUS	m2_i2	/* bytes transferred or error number */
+#define SUSPEND 	 -998 	/* status to suspend caller, reply later */
+
+/* Field names for messages to TTY driver. */
+#define TTY_LINE	DEVICE	/* message parameter: terminal line */
+#define TTY_REQUEST	COUNT	/* message parameter: ioctl request code */
+#define TTY_SPEK	POSITION/* message parameter: ioctl speed, erasing */
+#define TTY_FLAGS	m2_l2	/* message parameter: ioctl tty mode */
+#define TTY_PGRP 	m2_i3	/* message parameter: process group */	
+
+/* Field names for the QIC 02 status reply from tape driver */
+#define TAPE_STAT0	m2_l1
+#define TAPE_STAT1	m2_l2
+
+/*===========================================================================*
+ *                  	   Messages for networking layer		     *
+ *===========================================================================*/
+
+/* Message types for network layer requests. This layer acts like a driver. */
+#define NW_OPEN		DEV_OPEN
+#define NW_CLOSE	DEV_CLOSE
+#define NW_READ		DEV_READ
+#define NW_WRITE	DEV_WRITE
+#define NW_IOCTL	DEV_IOCTL
+#define NW_CANCEL	CANCEL
+
+/* Base type for data link layer requests and responses. */
+#define DL_RQ_BASE	0x800		
+#define DL_RS_BASE	0x900		
+
+/* Message types for data link layer requests. */
+#define DL_WRITE	(DL_RQ_BASE + 3)
+#define DL_WRITEV	(DL_RQ_BASE + 4)
+#define DL_READ		(DL_RQ_BASE + 5)
+#define DL_READV	(DL_RQ_BASE + 6)
+#define DL_INIT		(DL_RQ_BASE + 7)
+#define DL_STOP		(DL_RQ_BASE + 8)
+#define DL_GETSTAT	(DL_RQ_BASE + 9)
+#define DL_GETNAME	(DL_RQ_BASE +10)
+
+/* Message type for data link layer replies. */
+#define DL_INIT_REPLY	(DL_RS_BASE + 20)
+#define DL_TASK_REPLY	(DL_RS_BASE + 21)
+#define DL_NAME_REPLY	(DL_RS_BASE + 22)
+
+/* Field names for data link layer messages. */
+#define DL_PORT		m2_i1
+#define DL_PROC		m2_i2	/* endpoint */
+#define DL_COUNT	m2_i3
+#define DL_MODE		m2_l1
+#define DL_CLCK		m2_l2
+#define DL_ADDR		m2_p1
+#define DL_STAT		m2_l1
+#define DL_NAME		m3_ca1
+
+/* Bits in 'DL_STAT' field of DL replies. */
+#  define DL_PACK_SEND		0x01
+#  define DL_PACK_RECV		0x02
+#  define DL_READ_IP		0x04
+
+/* Bits in 'DL_MODE' field of DL requests. */
+#  define DL_NOMODE		0x0
+#  define DL_PROMISC_REQ	0x2
+#  define DL_MULTI_REQ		0x4
+#  define DL_BROAD_REQ		0x8
+
+/*===========================================================================*
+ *                  SYSTASK request types and field names                    *
+ *===========================================================================*/
+
+/* System library calls are dispatched via a call vector, so be careful when 
+ * modifying the system call numbers. The numbers here determine which call
+ * is made from the call vector.
+ */ 
+#define KERNEL_CALL	0x600	/* base for kernel calls to SYSTEM */ 
+
+#  define SYS_FORK       (KERNEL_CALL + 0)	/* sys_fork() */
+#  define SYS_EXEC       (KERNEL_CALL + 1)	/* sys_exec() */
+#  define SYS_EXIT	 (KERNEL_CALL + 2)	/* sys_exit() */
+#  define SYS_NICE       (KERNEL_CALL + 3)	/* sys_nice() */
+#  define SYS_PRIVCTL    (KERNEL_CALL + 4)	/* sys_privctl() */
+#  define SYS_TRACE      (KERNEL_CALL + 5)	/* sys_trace() */
+#  define SYS_KILL       (KERNEL_CALL + 6)	/* sys_kill() */
+
+#  define SYS_GETKSIG    (KERNEL_CALL + 7)	/* sys_getsig() */
+#  define SYS_ENDKSIG    (KERNEL_CALL + 8)	/* sys_endsig() */
+#  define SYS_SIGSEND    (KERNEL_CALL + 9)	/* sys_sigsend() */
+#  define SYS_SIGRETURN  (KERNEL_CALL + 10)	/* sys_sigreturn() */
+
+#  define SYS_NEWMAP     (KERNEL_CALL + 11)	/* sys_newmap() */
+#  define SYS_SEGCTL     (KERNEL_CALL + 12)	/* sys_segctl() */
+#  define SYS_MEMSET     (KERNEL_CALL + 13)	/* sys_memset() */
+
+#  define SYS_UMAP       (KERNEL_CALL + 14)	/* sys_umap() */
+#  define SYS_VIRCOPY    (KERNEL_CALL + 15)	/* sys_vircopy() */
+#  define SYS_PHYSCOPY   (KERNEL_CALL + 16) 	/* sys_physcopy() */
+#  define SYS_VIRVCOPY   (KERNEL_CALL + 17)	/* sys_virvcopy() */
+#  define SYS_PHYSVCOPY  (KERNEL_CALL + 18)	/* sys_physvcopy() */
+
+#  define SYS_IRQCTL     (KERNEL_CALL + 19)	/* sys_irqctl() */
+#  define SYS_INT86      (KERNEL_CALL + 20)	/* sys_int86() */
+#  define SYS_DEVIO      (KERNEL_CALL + 21)	/* sys_devio() */
+#  define SYS_SDEVIO     (KERNEL_CALL + 22)	/* sys_sdevio() */
+#  define SYS_VDEVIO     (KERNEL_CALL + 23)	/* sys_vdevio() */
+
+#  define SYS_SETALARM	 (KERNEL_CALL + 24)	/* sys_setalarm() */
+#  define SYS_TIMES	 (KERNEL_CALL + 25)	/* sys_times() */
+#  define SYS_GETINFO    (KERNEL_CALL + 26) 	/* sys_getinfo() */
+#  define SYS_ABORT      (KERNEL_CALL + 27)	/* sys_abort() */
+#  define SYS_IOPENABLE  (KERNEL_CALL + 28)	/* sys_enable_iop() */
+#  define SYS_VM_SETBUF  (KERNEL_CALL + 29)	/* sys_vm_setbuf() */
+#  define SYS_VM_MAP  	 (KERNEL_CALL + 30)	/* sys_vm_map() */
+#  define SYS_KILLED  	 (KERNEL_CALL + 31)	/* sys_vm_map() */
+
+#  define SYS_BINDPROC 	 (KERNEL_CALL + 32)	/* sys_bindproc() */
+#  define SYS_RFORK 	 (KERNEL_CALL + 33)	/* sys_bindproc() */
+
+#define NR_SYS_CALLS	34	/* number of system calls */ 
+
+/* Subfunctions for SYS_PRIVCTL */
+#define SYS_PRIV_INIT		1	/* Initialize a privilege structure */
+#define SYS_PRIV_ADD_IO		2	/* Add I/O range (struct io_range) */
+#define SYS_PRIV_ADD_MEM	3	/* Add memory range (struct mem_range)
+					 */
+#define SYS_PRIV_ADD_IRQ	4	/* Add IRQ */
+
+/* Field names for SYS_MEMSET, SYS_SEGCTL. */
+#define MEM_PTR		m2_p1	/* base */
+#define MEM_COUNT	m2_l1	/* count */
+#define MEM_PATTERN	m2_l2   /* pattern to write */
+#define MEM_CHUNK_BASE	m4_l1	/* physical base address */
+#define MEM_CHUNK_SIZE	m4_l2	/* size of mem chunk */
+#define MEM_TOT_SIZE	m4_l3	/* total memory size */
+#define MEM_CHUNK_TAG	m4_l4	/* tag to identify chunk of mem */
+
+/* Field names for SYS_DEVIO, SYS_VDEVIO, SYS_SDEVIO. */
+#define DIO_REQUEST	m2_i3	/* device in or output */
+#   define DIO_INPUT	    0	/* input */
+#   define DIO_OUTPUT	    1	/* output */
+#define DIO_TYPE	m2_i1   /* flag indicating byte, word, or long */ 
+#   define DIO_BYTE	  'b'	/* byte type values */
+#   define DIO_WORD	  'w'	/* word type values */
+#   define DIO_LONG	  'l'	/* long type values */
+#define DIO_PORT	m2_l1	/* single port address */
+#define DIO_VALUE	m2_l2	/* single I/O value */
+#define DIO_VEC_ADDR	m2_p1   /* address of buffer or (p,v)-pairs */
+#define DIO_VEC_SIZE	m2_l2   /* number of elements in vector */
+#define DIO_VEC_ENDPT	m2_i2   /* number of process where vector is */
+
+/* Field names for SYS_SIGNARLM, SYS_FLAGARLM, SYS_SYNCALRM. */
+#define ALRM_EXP_TIME   m2_l1	/* expire time for the alarm call */
+#define ALRM_ABS_TIME   m2_i2	/* set to 1 to use absolute alarm time */
+#define ALRM_TIME_LEFT  m2_l1	/* how many ticks were remaining */
+#define ALRM_ENDPT      m2_i1	/* which process wants the alarm? */
+#define ALRM_FLAG_PTR	m2_p1   /* virtual address of timeout flag */ 	
+
+/* Field names for SYS_IRQCTL. */
+#define IRQ_REQUEST     m5_c1	/* what to do? */
+#  define IRQ_SETPOLICY     1	/* manage a slot of the IRQ table */
+#  define IRQ_RMPOLICY      2	/* remove a slot of the IRQ table */
+#  define IRQ_ENABLE        3	/* enable interrupts */
+#  define IRQ_DISABLE       4	/* disable interrupts */
+#define IRQ_VECTOR	m5_c2   /* irq vector */
+#define IRQ_POLICY	m5_i1   /* options for IRQCTL request */
+#  define IRQ_REENABLE  0x001	/* reenable IRQ line after interrupt */
+#  define IRQ_BYTE      0x100	/* byte values */      
+#  define IRQ_WORD      0x200	/* word values */
+#  define IRQ_LONG      0x400	/* long values */
+#define IRQ_ENDPT	m5_i2   /* endpoint number, SELF, NONE */
+#define IRQ_HOOK_ID	m5_l3   /* id of irq hook at kernel */
+
+/* Field names for SYS_SEGCTL. */
+#define SEG_SELECT	m4_l1   /* segment selector returned */ 
+#define SEG_OFFSET	m4_l2	/* offset in segment returned */
+#define SEG_PHYS	m4_l3	/* physical address of segment */
+#define SEG_SIZE	m4_l4	/* segment size */
+#define SEG_INDEX	m4_l5	/* segment index in remote map */
+
+/* Field names for SYS_VIDCOPY. */
+#define VID_REQUEST	m4_l1	/* what to do? */
+#  define VID_VID_COPY	   1	/* request vid_vid_copy() */
+#  define MEM_VID_COPY     2	/* request mem_vid_copy() */
+#define VID_SRC_ADDR	m4_l2	/* virtual address in memory */
+#define VID_SRC_OFFSET	m4_l3	/* offset in video memory */
+#define VID_DST_OFFSET	m4_l4	/* offset in video memory */
+#define VID_CP_COUNT	m4_l5	/* number of words to be copied */
+
+/* Field names for SYS_ABORT. */
+#define ABRT_HOW	m1_i1	/* RBT_REBOOT, RBT_HALT, etc. */
+#define ABRT_MON_ENDPT  m1_i2	/* process where monitor params are */
+#define ABRT_MON_LEN	m1_i3	/* length of monitor params */
+#define ABRT_MON_ADDR   m1_p1	/* virtual address of monitor params */
+
+/* Field names for _UMAP, _VIRCOPY, _PHYSCOPY. */
+#define CP_SRC_SPACE 	m5_c1	/* T or D space (stack is also D) */
+#define CP_SRC_ENDPT	m5_i1	/* process to copy from */
+#define CP_SRC_ADDR	m5_l1	/* address where data come from */
+#define CP_DST_SPACE	m5_c2	/* T or D space (stack is also D) */
+#define CP_DST_ENDPT	m5_i2	/* process to copy to */
+#define CP_DST_ADDR	m5_l2	/* address where data go to */
+#define CP_NR_BYTES	m5_l3	/* number of bytes to copy */
+
+/* Field names for SYS_VCOPY and SYS_VVIRCOPY. */
+#define VCP_NR_OK	m1_i2	/* number of successfull copies */
+#define VCP_VEC_SIZE	m1_i3	/* size of copy vector */
+#define VCP_VEC_ADDR	m1_p1	/* pointer to copy vector */
+
+/* Field names for SYS_GETINFO. */
+#define I_REQUEST      m7_i3	/* what info to get */
+#   define GET_KINFO	   0	/* get kernel information structure */
+#   define GET_IMAGE	   1	/* get system image table */
+#   define GET_PROCTAB	   2	/* get kernel process table */
+#   define GET_RANDOMNESS  3	/* get randomness buffer */
+#   define GET_MONPARAMS   4	/* get monitor parameters */
+#   define GET_KENV	   5	/* get kernel environment string */
+#   define GET_IRQHOOKS	   6	/* get the IRQ table */
+#   define GET_KMESSAGES   7	/* get kernel messages */
+#   define GET_PRIVTAB	   8	/* get kernel privileges table */
+#   define GET_KADDRESSES  9	/* get various kernel addresses */
+#   define GET_SCHEDINFO  10	/* get scheduling queues */
+#   define GET_PROC 	  11	/* get process slot if given process */
+#   define GET_MACHINE 	  12	/* get machine information */
+#   define GET_LOCKTIMING 13	/* get lock()/unlock() latency timing */
+#   define GET_BIOSBUFFER 14	/* get a buffer for BIOS calls */
+#   define GET_LOADINFO   15	/* get load average information */
+#   define GET_SLOTSTAB   16	/* get slot allocation table from systask */
+
+#define I_ENDPT      m7_i4	/* calling process */
+#define I_VAL_PTR      m7_p1	/* virtual address at caller */ 
+#define I_VAL_LEN      m7_i1	/* max length of value */
+#define I_VAL_PTR2     m7_p2	/* second virtual address */ 
+#define I_VAL_LEN2_E   m7_i2	/* second length, or proc nr */
+#   define GET_IRQACTIDS  16	/* get the IRQ masks */
+
+/* Field names for SYS_TIMES. */
+#define T_ENDPT      m4_l1	/* process to request time info for */
+#define T_USER_TIME    m4_l1	/* user time consumed by process */
+#define T_SYSTEM_TIME  m4_l2	/* system time consumed by process */
+#define T_CHILD_UTIME  m4_l3	/* user time consumed by process' children */
+#define T_CHILD_STIME  m4_l4	/* sys time consumed by process' children */
+#define T_BOOT_TICKS   m4_l5	/* number of clock ticks since boot time */
+
+/* vm_map */
+#define VM_MAP_ENDPT		m4_l1
+#define VM_MAP_MAPUNMAP		m4_l2
+#define VM_MAP_BASE		m4_l3
+#define VM_MAP_SIZE		m4_l4
+#define VM_MAP_ADDR		m4_l5
+
+/* Field names for SYS_TRACE, SYS_PRIVCTL. */
+#define CTL_ENDPT    m2_i1	/* process number of the caller */
+#define CTL_REQUEST    m2_i2	/* server control request */
+#define CTL_MM_PRIV    m2_i3	/* privilege as seen by PM */
+#define CTL_ARG_PTR    m2_p1	/* pointer to argument */
+#define CTL_ADDRESS    m2_l1	/* address at traced process' space */
+#define CTL_DATA       m2_l2	/* data field for tracing */
+
+/* Field names for SYS_KILL, SYS_SIGCTL */
+#define SIG_REQUEST    m2_l2	/* PM signal control request */
+#define S_GETSIG 	   0	/* get pending kernel signal */
+#define S_ENDSIG 	   1	/* finish a kernel signal */
+#define S_SENDSIG   	   2	/* POSIX style signal handling */
+#define S_SIGRETURN	   3 	/* return from POSIX handling */
+#define S_KILL		   4 	/* servers kills process with signal */
+#define SIG_ENDPT       m2_i1	/* process number for inform */
+#define SIG_NUMBER     m2_i2	/* signal number to send */
+#define SIG_FLAGS      m2_i3	/* signal flags field */
+#define SIG_MAP        m2_l1	/* used by kernel to pass signal bit map */
+#define SIG_CTXT_PTR   m2_p1	/* pointer to info to restore signal context */
+
+/* Field names for SYS_FORK, _EXEC, _EXIT, _NEWMAP. */
+#define PR_ENDPT       m1_i1	/* indicates a process */
+#define PR_LPID        m1_i1	/* indicates the LINUX PID */
+#define PR_PRIORITY    m1_i2	/* process priority */
+#define PR_PRIV	     m1_i2	/* process privilege level */
+#define PR_SLOT        m1_i2	/* indicates a process slot */
+#define PR_PID	     m1_i3	/* process id at process manager */
+#define PR_STACK_PTR   m1_p1	/* used for stack ptr in sys_exec, sys_getsp */
+#define PR_TRACING     m1_i3	/* flag to indicate tracing is on/ off */
+#define PR_NAME_PTR    m1_p2	/* tells where program name is for dmp */
+#define PR_IP_PTR      m1_p3	/* initial value for ip after exec */
+#define PR_MEM_PTR     m1_p1	/* tells where memory map is for sys_newmap */
+
+#define	M3_LPID		m3_i1
+#define	M3_ENDPT	m3_i2
+#define	M3_SLOT		m3_i2
+	
+
+/* Field names for SYS_INT86 */
+#define INT86_REG86    m1_p1	/* pointer to registers */
+
+/* Field names for SELECT (FS). */
+#define SEL_NFDS       m8_i1
+#define SEL_READFDS    m8_p1
+#define SEL_WRITEFDS   m8_p2
+#define SEL_ERRORFDS   m8_p3
+#define SEL_TIMEOUT    m8_p4
+
+/* What system info to retrieve with sysgetinfo(). */
+#define SI_KINFO	   	   0	/* get kernel info via PM */
+#define SI_PMPROC_TAB	   1	/* copy of entire PM process table */
+#define SI_KPROC_TAB	   2	/* copy of kernel process table */
+#define SI_MACHINE 	   3	/* copy of kernel VM info via PM */
+#define SI_PRIV_TAB	   4	/* copy of kernel priviledge  table */
+#define SI_FSPROC_TAB	   5	/* copy of entire PM process table */
+#define SI_SLOTS_TAB	   6 	/* copy of entire SYSTASK slots allocation table */
+
+
+#define SI_DMAP_TAB	   3	/* get device <-> driver mappings */
+#define SI_MEM_ALLOC	   4	/* get memory allocation data */
+#define SI_DATA_STORE	   5	/* get copy of data store */
+#define SI_LOADINFO	   6	/* get copy of load average structure */
+
+/*===========================================================================*
+ *                Messages for the Reincarnation Server 		     *
+ *===========================================================================*/
+
+#define RS_RQ_BASE		0x700
+
+#define RS_UP		(RS_RQ_BASE + 0)	/* start system service */
+#define RS_DOWN		(RS_RQ_BASE + 1)	/* stop system service */
+#define RS_REFRESH	(RS_RQ_BASE + 2)	/* restart system service */
+#define RS_RESCUE	(RS_RQ_BASE + 3)	/* set rescue directory */
+#define RS_SHUTDOWN	(RS_RQ_BASE + 4)	/* alert about shutdown */
+
+#  define RS_CMD_ADDR		m1_p1		/* command string */
+#  define RS_CMD_LEN		m1_i1		/* length of command */
+#  define RS_PID		m1_i1		/* pid of system service */
+#  define RS_PERIOD 	        m1_i2		/* heartbeat period */
+#  define RS_DEV_MAJOR          m1_i3           /* major device number */
+
+/*===========================================================================*
+ *                Messages for the Data Store Server			     *
+ *===========================================================================*/
+
+#define DS_RQ_BASE		0x800
+
+#define DS_PUBLISH	(DS_RQ_BASE + 0)	/* publish information */
+#define DS_RETRIEVE	(DS_RQ_BASE + 1)	/* retrieve information */
+#define DS_SUBSCRIBE	(DS_RQ_BASE + 2)	/* subscribe to information */
+
+#  define DS_KEY		m2_i1		/* key for the information */
+#  define DS_FLAGS		m2_i2		/* flags provided by caller */
+#  define DS_AUTH		m2_p1		/* authorization of caller */
+#  define DS_VAL_L1		m2_l1		/* first long data value */
+#  define DS_VAL_L2		m2_l2		/* second long data value */
+
+/*===========================================================================*
+ *                Miscellaneous messages used by TTY			     *
+ *===========================================================================*/
+
+/* Miscellaneous request types and field names, e.g. used by IS server. */
+#define FKEY_CONTROL 		98  	/* control a function key at the TTY */
+#  define FKEY_REQUEST	     m2_i1	/* request to perform at TTY */
+#  define    FKEY_MAP		10	/* observe function key */
+#  define    FKEY_UNMAP		11	/* stop observing function key */
+#  define    FKEY_EVENTS	12	/* request open key presses */
+#  define FKEY_FKEYS	      m2_l1	/* F1-F12 keys pressed */
+#  define FKEY_SFKEYS	      m2_l2	/* Shift-F1-F12 keys pressed */
+#define DIAGNOSTICS 	100 	/* output a string without FS in between */
+#  define DIAG_PRINT_BUF      m1_p1
+#  define DIAG_BUF_COUNT      m1_i1
+#  define DIAG_ENDPT          m1_i2
+#define GET_KMESS	101	/* get kmess from TTY */
+#  define GETKM_PTR	      m1_p1
+
+
+#endif /* _MINIX_COM_H */ 
diff -Naur /home/jara/linux-2.6.32/include/minix/config.h /usr/src/linux/include/minix/config.h
--- /home/jara/linux-2.6.32/include/minix/config.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/config.h	2013-10-21 19:32:44.000000000 -0300
@@ -0,0 +1,167 @@
+#ifndef _CONFIG_H
+#define _CONFIG_H
+
+#define MOLIPC	1
+#define MOLPROFILING	0
+
+
+/* Minix release and version numbers. */
+#define OS_RELEASE "3"
+#define OS_VERSION "1.2a-MOLIPC"
+
+#define DRVS_VERSION 2
+#define DRVS_SUBVER  1
+
+#define MAXCOPYBUF	32768 
+#define MAXCOPYLEN	(16 * MAXCOPYBUF)
+
+/* This file sets configuration parameters for the MINIX kernel, FS, and PM.
+ * It is divided up into two main sections.  The first section contains
+ * user-settable parameters.  In the second section, various internal system
+ * parameters are set based on the user-settable parameters.
+ *
+ * Parts of config.h have been moved to sys_config.h, which can be included
+ * by other include files that wish to get at the configuration data, but
+ * don't want to pollute the users namespace. Some editable values have
+ * gone there.
+ *
+ */
+
+/* The MACHINE (called _MINIX_MACHINE) setting can be done
+ * in <minix/machine.h>.
+ */
+#include "sys_config.h"
+
+#define USE_DRVS_RWLOCK	0
+#define USE_DRVS_MUTEX	1
+
+#define USE_VM_RWLOCK	0
+#define USE_VM_MUTEX	1
+#define USE_VM_SEQLOCK	2
+
+#define USE_PROC_RWLOCK	0
+#define USE_PROC_MUTEX	1
+
+#define USE_NODE_RWLOCK	0
+#define USE_NODE_MUTEX	1
+
+#define USE_PROXY_RWLOCK	0
+#define USE_PROXY_MUTEX		1
+
+#define DEBUGALL	0xFFFFFFFF	/* Set all debug levels */
+
+#define LOCK_DRVS_TYPE	USE_DRVS_MUTEX
+#define LOCK_VM_TYPE	USE_VM_MUTEX
+#define LOCK_PROC_TYPE	USE_PROC_MUTEX
+#define LOCK_NODE_TYPE	USE_NODE_MUTEX
+#define LOCK_PROXY_TYPE	USE_PROXY_MUTEX
+
+#define MACHINE      _MINIX_MACHINE
+
+#define IBM_PC       _MACHINE_IBM_PC
+#define SUN_4        _MACHINE_SUN_4
+#define SUN_4_60     _MACHINE_SUN_4_60
+#define ATARI        _MACHINE_ATARI
+#define MACINTOSH    _MACHINE_MACINTOSH
+
+/* Number of slots in the process table for non-kernel processes. The number
+ * of system processes defines how many processes with special privileges 
+ * there can be. User processes share the same properties and count for one. 
+ *
+ * These can be changed in sys_config.h.
+ */
+
+#define NR_FIXED_TASKS  _NR_FIXED_TASKS 
+#define NR_NODES 	_NR_NODES 
+#define NR_SYSTASKS	_NR_SYSTASKS
+#define NR_TASKS	_NR_TASKS
+#define NR_SERVERS	_NR_SERVERS
+#define NR_SYS_PROCS	_NR_SYS_PROCS
+#define NR_USR_PROCS    _NR_USR_PROCS
+#define NR_PROCS	_NR_PROCS
+
+#define NR_VMS 	  	_NR_VMS 
+
+#define MAX_PROF		10 /*Maximum performance profiling entries in process descriptor */
+
+/* The buffer cache should be made as large as you can afford. */
+#if (MACHINE == IBM_PC && _WORD_SIZE == 2)
+#define NR_BUFS           40	/* # blocks in the buffer cache */
+#define NR_BUF_HASH       64	/* size of buf hash table; MUST BE POWER OF 2*/
+#endif
+
+#if (MACHINE == IBM_PC && _WORD_SIZE == 4)
+#define NR_BUFS         1200	/* # blocks in the buffer cache */
+#define NR_BUF_HASH     2048	/* size of buf hash table; MUST BE POWER OF 2*/
+#endif
+
+#if (MACHINE == SUN_4_60)
+#define NR_BUFS		 512	/* # blocks in the buffer cache (<=1536) */
+#define NR_BUF_HASH	 512	/* size of buf hash table; MUST BE POWER OF 2*/
+#endif
+
+/* Number of controller tasks (/dev/cN device classes). */
+#define NR_CTRLRS          2
+
+/* Enable or disable the second level file system cache on the RAM disk. */
+#define ENABLE_CACHE2      0
+
+/* Enable or disable swapping processes to disk. */
+#define ENABLE_SWAP	   1
+
+/* Include or exclude an image of /dev/boot in the boot image. 
+ * Please update the makefile in /usr/src/tools/ as well.
+ */
+#define ENABLE_BOOTDEV	   0	/* load image of /dev/boot at boot time */
+
+/* DMA_SECTORS may be increased to speed up DMA based drivers. */
+#define DMA_SECTORS        1	/* DMA buffer size (must be >= 1) */
+
+/* Include or exclude backwards compatibility code. */
+#define ENABLE_BINCOMPAT   0	/* for binaries using obsolete calls */
+#define ENABLE_SRCCOMPAT   0	/* for sources using obsolete calls */
+
+/* Which processes should receive diagnostics from the kernel and system? 
+ * Directly sending it to TTY only displays the output. Sending it to the
+ * log driver will cause the diagnostics to be buffered and displayed.
+ * Messages are sent by src/lib/sysutil/kputc.c to these processes, in
+ * the order of this array, which must be terminated by NONE. This is used
+ * by drivers and servers that printf().
+ * The kernel does this for its own kprintf() in kernel/utility.c, also using
+ * this array, but a slightly different mechanism.
+ */
+#define OUTPUT_PROCS_ARRAY	{ TTY_PROC_NR, LOG_PROC_NR, NONE }
+
+/* NR_CONS, NR_RS_LINES, and NR_PTYS determine the number of terminals the
+ * system can handle.
+ */
+#define NR_CONS            4	/* # system consoles (1 to 8) */
+#define	NR_RS_LINES	   4	/* # rs232 terminals (0 to 4) */
+#define	NR_PTYS		   32	/* # pseudo terminals (0 to 64) */
+
+/*===========================================================================*
+ *	There are no user-settable parameters after this line		     *
+ *===========================================================================*/
+/* Set the CHIP type based on the machine selected. The symbol CHIP is actually
+ * indicative of more than just the CPU.  For example, machines for which
+ * CHIP == INTEL are expected to have 8259A interrrupt controllers and the
+ * other properties of IBM PC/XT/AT/386 types machines in general. */
+#define INTEL             _CHIP_INTEL	/* CHIP type for PC, XT, AT, 386 and clones */
+#define M68000            _CHIP_M68000	/* CHIP type for Atari, Amiga, Macintosh    */
+#define SPARC             _CHIP_SPARC	/* CHIP type for SUN-4 (e.g. SPARCstation)  */
+
+/* Set the FP_FORMAT type based on the machine selected, either hw or sw    */
+#define FP_NONE	 _FP_NONE	/* no floating point support                */
+#define FP_IEEE	 _FP_IEEE	/* conform IEEE floating point standard     */
+
+/* _MINIX_CHIP is defined in sys_config.h. */
+#define CHIP	_MINIX_CHIP
+
+/* _MINIX_FP_FORMAT is defined in sys_config.h. */
+#define FP_FORMAT	_MINIX_FP_FORMAT
+
+/* _ASKDEV and _FASTLOAD are defined in sys_config.h. */
+#define ASKDEV _ASKDEV
+#define FASTLOAD _FASTLOAD
+
+#endif /* _CONFIG_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/const.h /usr/src/linux/include/minix/const.h
--- /home/jara/linux-2.6.32/include/minix/const.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/const.h	2014-07-10 19:50:30.000000000 -0300
@@ -0,0 +1,48 @@
+#define BITMAP_BITS		(sizeof(unsigned long int)* CHAR_BIT) 
+#define BIT_VM_FREE	1	/* VM is free */
+
+#define VM_RUNNING	0x00			/* VM is RUNNING */
+#define VM_FREE		(1<<BIT_VM_FREE)	/* VM is free */
+
+#define DRVS_RUNNING	0x00	/* DRVS is RUNNING*/
+#define DRVS_NO_INIT	(-1)	/* DRVS has not been initialized */
+#define PROC_NO_PID	(-1)	
+
+#define SUPER_USER (uid_t) 0	/* uid_t of superuser */
+#define MOL_LONG_MAX  2147483647L	/* maximum value of a long */
+
+//Agregado PID MOLFS
+#define NO_BLOCK              ((block_t) 0)	/* absence of a block number */
+#define NO_ENTRY                ((ino_t) 0)	/* absence of a dir entry */
+#define NO_ZONE                ((zone_t) 0)	/* absence of a zone number */
+#define NO_DEV                  ((dev_t) 0)	/* absence of a device numb */
+
+//ESTO VIENE DE dirent.h ver si incluirlo o usar directo la header !!!
+
+/* The block size must be at least 1024 bytes, because otherwise
+ * the superblock (at 1024 bytes) overlaps with other filesystem data.
+ */
+#define _MIN_BLOCK_SIZE		 1024
+
+/* The below is allocated in some parts of the system as the largest
+ * a filesystem block can be. For instance, the boot monitor allocates
+ * 3 of these blocks and has to fit within 64kB, so this can't be
+ * increased without taking that into account.
+ */
+#define _MAX_BLOCK_SIZE		 4096
+
+#define _STATIC_BLOCK_SIZE   1024
+
+#define MINIX_HZ          60	/* clock freq (software settable on IBM-PC) */
+
+/* Miscellaneous */
+//#define TRUE               1	/* used for turning integers into Booleans */
+//#define FALSE              0	/* used for turning integers into Booleans */ 
+#define BYTE            0377	/* mask for 8 bits */
+#define READING            0	/* copy data to user */
+#define WRITING            1	/* copy data from user */
+#define NO_NUM        0x8000	/* used as numerical argument to panic() */
+#define NIL_PTR   (char *) 0	/* generally useful expression */
+#define HAVE_SCATTERED_IO  1	/* scattered I/O is now standard */ 
+
+
diff -Naur /home/jara/linux-2.6.32/include/minix/dir.h /usr/src/linux/include/minix/dir.h
--- /home/jara/linux-2.6.32/include/minix/dir.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/dir.h	2005-04-21 11:55:00.000000000 -0300
@@ -0,0 +1,19 @@
+/* The <dir.h> header gives the layout of a directory. */
+
+#ifndef _DIR_H
+#define _DIR_H
+
+#include <sys/types.h>
+
+#define	DIRBLKSIZ	512	/* size of directory block */
+
+#ifndef DIRSIZ
+#define DIRSIZ	60
+#endif
+
+struct direct {
+  ino_t d_ino;
+  char d_name[DIRSIZ];
+};
+
+#endif /* _DIR_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/drvs_usr.h /usr/src/linux/include/minix/drvs_usr.h
--- /home/jara/linux-2.6.32/include/minix/drvs_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/drvs_usr.h	2013-10-03 11:20:00.000000000 -0300
@@ -0,0 +1,31 @@
+#ifndef DRVS_USR_H
+#define DRVS_USR_H
+
+struct drvs_usr {
+	int	d_nr_vms;
+	int	d_nr_nodes;
+	int 	d_nr_procs;
+	int 	d_nr_tasks;
+	int 	d_nr_sysprocs;
+
+	int 	d_max_copybuf;
+	int 	d_max_copylen;
+
+	unsigned long int d_dbglvl;
+	int	d_version;
+	int	d_subver;
+};
+typedef struct drvs_usr drvs_usr_t;
+
+#define DRVS_USR_FORMAT "d_nr_vms=%d d_nr_nodes=%d d_nr_procs=%d d_nr_tasks=%d d_nr_sysprocs=%d \n"
+#define DRVS_USR_FIELDS(p) p->d_nr_vms,p->d_nr_nodes, p->d_nr_procs, p->d_nr_tasks, p->d_nr_sysprocs  
+
+#define DRVS_MAX_FORMAT "d_max_copybuf=%d d_max_copylen=%d\n"
+#define DRVS_MAX_FIELDS(p) p->d_max_copybuf,p->d_max_copylen  
+
+#define DRVS_VER_FORMAT "d_dbglvl=%lX version=%d.%d\n"
+#define DRVS_VER_FIELDS(p) p->d_dbglvl, p->d_version, p->d_subver  
+
+
+
+#endif /* DRVS_USR_H */
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/include/minix/endpoint.h /usr/src/linux/include/minix/endpoint.h
--- /home/jara/linux-2.6.32/include/minix/endpoint.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/endpoint.h	2012-07-16 22:53:00.000000000 -0300
@@ -0,0 +1,25 @@
+
+#ifndef _MINIX_ENDPOINT_H
+#define _MINIX_ENDPOINT_H 1
+
+#include "sys_config.h"
+#include "com.h"
+
+/* The point of the padding in 'generation size' is to 
+ * allow for certain bogus endpoint numbers such as NONE, ANY, etc.
+ *
+ * The _MAX_MAGIC_PROC is defined by <minix/com.h>. That include
+ * file defines some magic process numbers such as ANY and NONE,
+ * and must never be a valid endpoint number. Therefore we make sure
+ * the generation size is big enough to start the next generation
+ * above the highest magic number.
+ */
+#define _ENDPOINT_GENERATION_SIZE (NR_TASKS+_MAX_MAGIC_PROC+1)
+#define _ENDPOINT_MAX_GENERATION  (INT_MAX/_ENDPOINT_GENERATION_SIZE-1)
+
+/* Generation + Process slot number <-> endpoint. */
+#define _ENDPOINT(g, p) ((g) * _ENDPOINT_GENERATION_SIZE + (p))
+#define _ENDPOINT_G(e) (((e)+NR_TASKS) / _ENDPOINT_GENERATION_SIZE)
+#define _ENDPOINT_P(e) ((((e)+NR_TASKS) % _ENDPOINT_GENERATION_SIZE) - NR_TASKS)
+
+#endif
diff -Naur /home/jara/linux-2.6.32/include/minix/errno.h /usr/src/linux/include/minix/errno.h
--- /home/jara/linux-2.6.32/include/minix/errno.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/errno.h	2012-07-16 22:35:00.000000000 -0300
@@ -0,0 +1,91 @@
+
+#   define _SIGN         -
+
+/* Here are the numerical values of the error numbers. */
+#define _NERROR               70  /* number of errors */  
+
+#define EMOLGENERIC      (_SIGN 99)  /* generic error */
+#define EMOLPERM         (_SIGN  1)  /* operation not permitted */
+#define EMOLNOENT        (_SIGN  2)  /* no such file or directory */
+#define EMOLSRCH         (_SIGN  3)  /* no such process */
+#define EMOLINTR         (_SIGN  4)  /* interrupted function call */
+#define EMOLIO           (_SIGN  5)  /* input/output error */
+#define EMOLNXIO         (_SIGN  6)  /* no such device or address */
+#define EMOL2BIG         (_SIGN  7)  /* arg list too long */
+#define EMOLNOEXEC       (_SIGN  8)  /* exec format error */
+#define EMOLBADF         (_SIGN  9)  /* bad file descriptor */
+#define EMOLCHILD        (_SIGN 10)  /* no child process */
+#define EMOLAGAIN        (_SIGN 11)  /* resource temporarily unavailable */
+#define EMOLNOMEM        (_SIGN 12)  /* not enough space */
+#define EMOLACCES        (_SIGN 13)  /* permission denied */
+#define EMOLFAULT        (_SIGN 14)  /* bad address */
+#define EMOLNOTBLK       (_SIGN 15)  /* Extension: not a block special file */
+#define EMOLBUSY         (_SIGN 16)  /* resource busy */
+#define EMOLEXIST        (_SIGN 17)  /* file exists */
+#define EMOLXDEV         (_SIGN 18)  /* improper link */
+#define EMOLNODEV        (_SIGN 19)  /* no such device */
+#define EMOLNOTDIR       (_SIGN 20)  /* not a directory */
+#define EMOLISDIR        (_SIGN 21)  /* is a directory */
+#define EMOLINVAL        (_SIGN 22)  /* invalid argument */
+#define EMOLNFILE        (_SIGN 23)  /* too many open files in system */
+#define EMOLMFILE        (_SIGN 24)  /* too many open files */
+#define EMOLNOTTY        (_SIGN 25)  /* inappropriate I/O control operation */
+#define EMOLTXTBSY       (_SIGN 26)  /* no longer used */
+#define EMOLFBIG         (_SIGN 27)  /* file too large */
+#define EMOLNOSPC        (_SIGN 28)  /* no space left on device */
+#define EMOLSPIPE        (_SIGN 29)  /* invalid seek */
+#define EMOLROFS         (_SIGN 30)  /* read-only file system */
+#define EMOLMLINK        (_SIGN 31)  /* too many links */
+#define EMOLPIPE         (_SIGN 32)  /* broken pipe */
+#define EMOLDOM          (_SIGN 33)  /* domain error    	(from ANSI C std) */
+#define EMOLRANGE        (_SIGN 34)  /* result too large	(from ANSI C std) */
+#define EMOLDEADLK       (_SIGN 35)  /* resource deadlock avoided */
+#define EMOLNAMETOOLONG  (_SIGN 36)  /* file name too long */
+#define EMOLNOLCK        (_SIGN 37)  /* no locks available */
+#define EMOLNOSYS        (_SIGN 38)  /* function not implemented */
+#define EMOLNOTEMPTY     (_SIGN 39)  /* directory not empty */
+#define EMOLLOOP         (_SIGN 40)  /* too many levels of symlinks detected */
+
+/* The following errors relate to networking. */
+#define EMOLPACKSIZE     (_SIGN 50)  /* invalid packet size for some protocol */
+#define EMOLOUTOFBUFS    (_SIGN 51)  /* not enough buffers left */
+#define EMOLBADIOCTL     (_SIGN 52)  /* illegal ioctl for device */
+#define EMOLBADMODE      (_SIGN 53)  /* badmode in ioctl */
+#define EMOLWOULDBLOCK   (_SIGN 54)
+#define EMOLBADDEST      (_SIGN 55)  /* not a valid destination address */
+#define EMOLDSTNOTRCH    (_SIGN 56)  /* destination not reachable */
+#define EMOLISCONN	      (_SIGN 57)  /* all ready connected */
+#define EMOLADDRINUSE    (_SIGN 58)  /* address in use */
+#define EMOLCONNREFUSED  (_SIGN 59)  /* connection refused */
+#define EMOLCONNRESET    (_SIGN 60)  /* connection reset */
+#define EMOLTIMEDOUT     (_SIGN 61)  /* connection timed out */
+#define EMOLURG	      (_SIGN 62)  /* urgent data present */
+#define EMOLNOURG	      (_SIGN 63)  /* no urgent data present */
+#define EMOLNOTCONN      (_SIGN 64)  /* no connection (yet or anymore) */
+#define EMOLSHUTDOWN     (_SIGN 65)  /* a write call to a shutdown connection */
+#define EMOLNOCONN       (_SIGN 66)  /* no such connection */
+#define EMOLAFNOSUPPORT  (_SIGN 67)  /* address family not supported */
+#define EMOLPROTONOSUPPORT (_SIGN 68) /* protocol not supported by AF */
+#define EMOLPROTOTYPE    (_SIGN 69)  /* Protocol wrong type for socket */
+#define EMOLINPROGRESS   (_SIGN 70)  /* Operation now in progress */
+#define EMOLADDRNOTAVAIL (_SIGN 71)  /* Can't assign requested address */
+#define EMOLALREADY      (_SIGN 72)  /* Connection already in progress */
+#define EMOLMSGSIZE      (_SIGN 73)  /* Message too long */
+#define EMOLNOTSOCK      (_SIGN 74)  /* Socket operation on non-socket */
+#define EMOLNOPROTOOPT   (_SIGN 75)  /* Protocol not available */
+
+/* The following are not POSIX errors, but they can still happen. 
+ * All of these are generated by the kernel and relate to message passing.
+ */
+#define EMOLLOCKED      (_SIGN 101)  /* can't send message due to deadlock */
+#define EMOLBADCALL     (_SIGN 102)  /* illegal system call number */
+#define EMOLBADSRCDST   (_SIGN 103)  /* bad source or destination process */
+#define EMOLCALLDENIED  (_SIGN 104)  /* no permission for system call */
+#define EMOLDEADSRCDST  (_SIGN 105)  /* source or destination is not alive */
+#define EMOLNOTREADY    (_SIGN 106)  /* source or destination is not ready */
+#define EMOLBADREQUEST  (_SIGN 107)  /* destination cannot handle request */
+#define EMOLSRCDIED     (_SIGN 108)  /* source just died */
+#define EMOLDSTDIED     (_SIGN 109)  /* destination just died */
+#define EMOLTRAPDENIED  (_SIGN 110)  /* IPC trap not allowed */
+#define EMOLDONTREPLY   (_SIGN 201)  /* pseudo-code: don't send a reply */
+
diff -Naur /home/jara/linux-2.6.32/include/minix/ipc.h /usr/src/linux/include/minix/ipc.h
--- /home/jara/linux-2.6.32/include/minix/ipc.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/ipc.h	2014-04-13 20:39:06.000000000 -0300
@@ -0,0 +1,127 @@
+#ifndef _IPC_H
+#define _IPC_H
+
+/*==========================================================================* 
+ * Types relating to messages. 						    *
+ *==========================================================================*/ 
+
+#define M1                 1
+#define M3                 3
+#define M4                 4
+#define M3_STRING         14
+
+#define MINIX_MSG	1	/* the payload is a MINIX message */
+
+#define 	SLOTS_BY_MSG		4 /* number of slots that fit in a message */
+
+typedef struct {int m1i1, m1i2, m1i3; char *m1p1, *m1p2, *m1p3;} mess_1;
+typedef struct {int m2i1, m2i2, m2i3; long m2l1, m2l2; char *m2p1;} mess_2;
+typedef struct {int m3i1, m3i2; char *m3p1; char m3ca1[M3_STRING];} mess_3;
+typedef struct {long m4l1, m4l2, m4l3, m4l4, m4l5;} mess_4;
+typedef struct {short m5c1, m5c2; int m5i1, m5i2; long m5l1, m5l2, m5l3;}mess_5;
+typedef struct {char m6ca1[sizeof(mess_3)];} mess_6;
+typedef struct {int m7i1, m7i2, m7i3, m7i4; char *m7p1, *m7p2;} mess_7;
+typedef struct {int m8i1, m8i2; char *m8p1, *m8p2, *m8p3, *m8p4;} mess_8;
+typedef struct {int m9i1, m9l1; struct timespec m9t1;} mess_9;
+typedef struct {int mAdst, mAnr, mAia[SLOTS_BY_MSG];} mess_A;
+
+
+typedef struct {
+  int m_source;			/* who sent the message */
+  int m_type;			/* what kind of message is it */
+  union {
+	mess_1 m_m1;
+	mess_2 m_m2;
+	mess_3 m_m3;
+	mess_4 m_m4;
+	mess_5 m_m5;
+	mess_6 m_m6;
+	mess_7 m_m7;
+	mess_8 m_m8;
+	mess_9 m_m9;
+	mess_A m_mA;
+  } m_u;
+} message;
+
+
+/* The following defines provide names for useful members. */
+#define m1_i1  m_u.m_m1.m1i1
+#define m1_i2  m_u.m_m1.m1i2
+#define m1_i3  m_u.m_m1.m1i3
+#define m1_p1  m_u.m_m1.m1p1
+#define m1_p2  m_u.m_m1.m1p2
+#define m1_p3  m_u.m_m1.m1p3
+
+#define m2_i1  m_u.m_m2.m2i1
+#define m2_i2  m_u.m_m2.m2i2
+#define m2_i3  m_u.m_m2.m2i3
+#define m2_l1  m_u.m_m2.m2l1
+#define m2_l2  m_u.m_m2.m2l2
+#define m2_p1  m_u.m_m2.m2p1
+
+#define m3_i1  m_u.m_m3.m3i1
+#define m3_i2  m_u.m_m3.m3i2
+#define m3_p1  m_u.m_m3.m3p1
+#define m3_ca1 m_u.m_m3.m3ca1
+
+#define m4_l1  m_u.m_m4.m4l1
+#define m4_l2  m_u.m_m4.m4l2
+#define m4_l3  m_u.m_m4.m4l3
+#define m4_l4  m_u.m_m4.m4l4
+#define m4_l5  m_u.m_m4.m4l5
+
+#define m5_c1  m_u.m_m5.m5c1
+#define m5_c2  m_u.m_m5.m5c2
+#define m5_i1  m_u.m_m5.m5i1
+#define m5_i2  m_u.m_m5.m5i2
+#define m5_l1  m_u.m_m5.m5l1
+#define m5_l2  m_u.m_m5.m5l2
+#define m5_l3  m_u.m_m5.m5l3
+
+#define m6_ca1 m_u.m_m6.m6ca1
+
+#define m7_i1  m_u.m_m7.m7i1
+#define m7_i2  m_u.m_m7.m7i2
+#define m7_i3  m_u.m_m7.m7i3
+#define m7_i4  m_u.m_m7.m7i4
+#define m7_p1  m_u.m_m7.m7p1
+#define m7_p2  m_u.m_m7.m7p2
+
+#define m8_i1  m_u.m_m8.m8i1
+#define m8_i2  m_u.m_m8.m8i2
+#define m8_p1  m_u.m_m8.m8p1
+#define m8_p2  m_u.m_m8.m8p2
+#define m8_p3  m_u.m_m8.m8p3
+#define m8_p4  m_u.m_m8.m8p4
+
+#define m9_i1  m_u.m_m9.m9i1
+#define m9_l1  m_u.m_m9.m9l1
+#define m9_t1  m_u.m_m9.m9t1
+
+#define mA_nr  m_u.m_mA.mAnr
+#define mA_dst m_u.m_mA.mAdst
+#define mA_ia  m_u.m_mA.mAia
+
+#define MSG1_FORMAT "source=%d type=%d m1i1=%d m1i2=%d m1i3=%d m1p1=%p m1p2=%p m1p3=%p \n"
+#define MSG2_FORMAT "source=%d type=%d m2i1=%d m2i2=%d m2i3=%d m2l1=%d m2l2=%d m2p1=%p\n"
+#define MSG3_FORMAT "source=%d type=%d m3i1=%d m3i2=%d m3p1=%p m3ca1=[%s]\n"
+#define MSG4_FORMAT "source=%d type=%d m4l1=%d m4l2=%d m4l3=%d m4l4=%d m4l5=%d\n"
+#define MSG5_FORMAT "source=%d type=%d m5c1=%c m5c2=%c m5i1=%d m5i2=%d m5l1=%d m5l2=%d m5l3=%d\n"
+#define MSG6_FORMAT "source=%d type=%d m6ca1=[%s]\n"
+#define MSG7_FORMAT "source=%d type=%d m7i1=%d m7i2=%d m7i3=%d m7i4=%d m7p1=%p m7p2=%p\n"
+#define MSG8_FORMAT "source=%d type=%d m8i1=%d m8i2=%d m8p1=%p m8p2=%p m8p3=%p m8p4=%p\n"
+#define MSG9_FORMAT "source=%d type=%d m9i1=%d m9l1=%d m9t1.tv_sec=%ld m9t1.tv_nsec=%ld\n"
+#define MSGA_FORMAT "source=%d type=%d dest=%d mAnr=%d mAia[0]=%d mAia[1]=%d mAia[2]=%d mAia[3]=%d\n"
+
+#define MSG1_FIELDS(p) 	p->m_source,p->m_type, p->m1_i1, p->m1_i2, p->m1_i3, p->m1_p1, p->m1_p2, p->m1_p3
+#define MSG2_FIELDS(p) 	p->m_source,p->m_type, p->m2_i1, p->m2_i2, p->m2_i3, p->m2_l1, p->m2_l2, p->m2_p1
+#define MSG3_FIELDS(p) 	p->m_source,p->m_type, p->m3_i1, p->m3_i2, p->m3_p1, p->m3_ca1
+#define MSG4_FIELDS(p) 	p->m_source,p->m_type, p->m4_l1, p->m4_l2, p->m4_l3, p->m4_l4, p->m4_l5
+#define MSG5_FIELDS(p) 	p->m_source,p->m_type, p->m5_c1, p->m5_c2, p->m5_i1, p->m5_i2, p->m5_l1, p->m5_l2, p->m5_l3
+#define MSG6_FIELDS(p) 	p->m_source,p->m_type, p->m6_ca1
+#define MSG7_FIELDS(p) 	p->m_source,p->m_type, p->m7_i1, p->m7_i2, p->m7_i3, p->m7_i4, p->m7_p1, p->m7p2
+#define MSG8_FIELDS(p) 	p->m_source,p->m_type, p->m8_i1, p->m8_i2, p->m8_p1, p->m8_p2, p->m8_p3, p->m8_p4
+#define MSG9_FIELDS(p) 	p->m_source,p->m_type, p->m9_i1, p->m9_l1, p->m9_t1.tv_sec, p->m9_t1.tv_nsec
+#define MSGA_FIELDS(p) 	p->m_source,p->m_type, p->mA_dst, p->mA_nr, p->mA_ia[0], p->mA_ia[1], p->mA_ia[2],p->mA_ia[3]
+
+#endif /* _IPC_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/kipc.h /usr/src/linux/include/minix/kipc.h
--- /home/jara/linux-2.6.32/include/minix/kipc.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/kipc.h	2013-10-07 19:23:00.000000000 -0300
@@ -0,0 +1,72 @@
+#ifndef IPC_H
+#define IPC_H
+
+/* This header file defines constants for MINIX inter-process communication.
+ * These definitions are used in the file proc.c.
+ */
+#include "com.h"
+
+/* Masks and flags for system calls. */
+#define SYSCALL_FUNC	0x000F	/* mask for system call function */
+#define SYSCALL_FLAGS   0x00F0  /* mask for system call flags */
+#define NON_BLOCKING    0x0010  /* do not block if target not ready */
+
+/* System call numbers that are passed when trapping to the kernel. The 
+ * numbers are carefully defined so that it can easily be seen (based on 
+ * the bits that are on) which checks should be done in sys_call().
+ */
+#define VMINIT		   	0	
+#define SEND		   	1	/* 0001 : blocking send */
+#define RECEIVE			2	/* 0010 : blocking receive */
+#define MOLVOID3			3
+#define NOTIFY		   	4	/* 0100 : nonblocking notify */
+// #define MOLVOID5		5
+#define SENDREC	 		5  	
+#define RCVRQST			6
+#define REPLY			7
+#define VMEND			8	/* End a VM 			*/
+#define BIND			9	/* Bind a process to IPC  	*/
+#define UNBIND			10	/* UnBind a process to IPC  	*/
+#define VMDUMP			11	/* Dump VM's tables		*/
+#define PROCDUMP		12	/* Dump a VM process table	*/
+#define GETPRIV			13	/* Get process priviledges	*/
+#define SETPRIV			14	/* Set process priviledges	*/
+#define VCOPY 			15   /* Virtual Copy			*/
+#define GETVMINFO		16	/* Get VM information		*/
+#define GETPROCINFO		17	/* Get Proc information		*/
+#define MOLVOID18		18  	/* used by mol_rmtbind()    = molbind(vmid,proc,nodeid) */
+#define RELAY			19	
+#define PROXYBIND		20	
+#define PROXYUNBIND		21	
+#define GETNODEINFO		22	
+#define PUT2LCL			23	/* Used by receiver proxy to send all kind of messages to local processes */	
+#define GET2RMT			24	/* Used by sender  proxy to send all kind of local messages to remote  processes */	
+#define ADDNODE			25	
+#define DELNODE			26	
+#define DRVSINIT		27	
+#define DRVSEND			28
+#define GETEP			29	/* Get process endpoint 	*/
+#define GETDRVSINFO		30	
+#define PROXYCONN		31	
+#define WAIT4BIND		32	
+#define MIGRATE			33	
+#define NODEUP			34	
+#define NODEDOWN		35	
+#define GETPROXYINFO	36	
+
+#define NR_MOLCALLS	 	37   /* Numero de IPCs/DRVMM Calls habilitadas */ 
+
+#define IPCMASK			0x08	/* mask to test IPC calls */
+
+#define MINIX_ECHO	   8	/* 1000 : echo a message */
+#define IPC_REQUEST	   5	/* 0101 : blocking request */
+#define IPC_REPLY	   6    /* 0110 : nonblocking reply */
+#define IPC_NOTIFY	   7    /* 0111 : nonblocking notification */
+#define IPC_RECEIVE	   9	/* 1001 : blocking receive */
+
+/* The following bit masks determine what checks that should be done. */
+#define CHECK_PTR       0xBB	/* 1011 1011 : validate message buffer */
+#define CHECK_DST       0x55	/* 0101 0101 : validate message destination */
+#define CHECK_DEADLOCK  0x93	/* 1001 0011 : check for deadlock */
+
+#endif /* IPC_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/limits.h /usr/src/linux/include/minix/limits.h
--- /home/jara/linux-2.6.32/include/minix/limits.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/limits.h	2013-07-12 16:43:00.000000000 -0300
@@ -0,0 +1,92 @@
+/* The <limits.h> header defines some basic sizes, both of the language types 
+ * (e.g., the number of bits in an integer), and of the operating system (e.g.
+ * the number of characters in a file name.
+ */
+
+#ifndef _LIMITS_H
+#define _LIMITS_H
+
+#define PATH_MAX           255	/* # chars in a path name */
+
+#ifdef ANULADO
+
+/* Definitions about chars (8 bits in MINIX, and signed). */
+#define CHAR_BIT           8	/* # bits in a char */
+#define CHAR_MIN        -128	/* minimum value of a char */
+#define CHAR_MAX         127	/* maximum value of a char */
+#define SCHAR_MIN       -128	/* minimum value of a signed char */
+#define SCHAR_MAX        127	/* maximum value of a signed char */
+#define UCHAR_MAX        255	/* maximum value of an unsigned char */
+#define MB_LEN_MAX         1	/* maximum length of a multibyte char */
+
+/* Definitions about shorts (16 bits in MINIX). */
+#define SHRT_MIN  (-32767-1)	/* minimum value of a short */
+#define SHRT_MAX       32767	/* maximum value of a short */
+#define USHRT_MAX     0xFFFF	/* maximum value of unsigned short */
+
+/* _EM_WSIZE is a compiler-generated symbol giving the word size in bytes. */
+#if _EM_WSIZE == 2
+#define INT_MIN   (-32767-1)	/* minimum value of a 16-bit int */
+#define INT_MAX        32767	/* maximum value of a 16-bit int */
+#define UINT_MAX      0xFFFF	/* maximum value of an unsigned 16-bit int */
+#endif
+
+#if _EM_WSIZE == 4
+#define INT_MIN (-2147483647-1)	/* minimum value of a 32-bit int */
+#define INT_MAX   2147483647	/* maximum value of a 32-bit int */
+#define UINT_MAX  0xFFFFFFFF	/* maximum value of an unsigned 32-bit int */
+#endif
+
+/*Definitions about longs (32 bits in MINIX). */
+#define LONG_MIN (-2147483647L-1)/* minimum value of a long */
+#define LONG_MAX  2147483647L	/* maximum value of a long */
+#define ULONG_MAX 0xFFFFFFFFL	/* maximum value of an unsigned long */
+
+#include <sys/dir.h>
+
+/* Minimum sizes required by the POSIX P1003.1 standard (Table 2-3). */
+#ifdef _POSIX_SOURCE		/* these are only visible for POSIX */
+#define _POSIX_ARG_MAX    4096	/* exec() may have 4K worth of args */
+#define _POSIX_CHILD_MAX     6	/* a process may have 6 children */
+#define _POSIX_LINK_MAX      8	/* a file may have 8 links */
+#define _POSIX_MAX_CANON   255	/* size of the canonical input queue */
+#define _POSIX_MAX_INPUT   255	/* you can type 255 chars ahead */
+#define _POSIX_NAME_MAX DIRSIZ	/* max. file name length */
+#define _POSIX_NGROUPS_MAX   0	/* supplementary group IDs are optional */
+#define _POSIX_OPEN_MAX     16	/* a process may have 16 files open */
+#define _POSIX_PATH_MAX    255	/* a pathname may contain 255 chars */
+#define _POSIX_PIPE_BUF    512	/* pipes writes of 512 bytes must be atomic */
+#define _POSIX_STREAM_MAX    8	/* at least 8 FILEs can be open at once */
+#define _POSIX_TZNAME_MAX    3	/* time zone names can be at least 3 chars */
+#define _POSIX_SSIZE_MAX 32767	/* read() must support 32767 byte reads */
+
+/* Values actually implemented by MINIX (Tables 2-4, 2-5, 2-6, and 2-7). */
+/* Some of these old names had better be defined when not POSIX. */
+#define _NO_LIMIT          100	/* arbitrary number; limit not enforced */
+
+#define NGROUPS_MAX          0	/* supplemental group IDs not available */
+#if _EM_WSIZE > 2
+#define ARG_MAX          16384	/* # bytes of args + environ for exec() */
+#else
+#define ARG_MAX           4096	/* args + environ on small machines */
+#endif
+#define CHILD_MAX    _NO_LIMIT	/* MINIX does not limit children */
+#define OPEN_MAX            30	/* # open files a process may have */
+#if 0			/* V1 file system */
+#define LINK_MAX      CHAR_MAX	/* # links a file may have */
+#else			/* V2 or better file system */
+#define LINK_MAX      SHRT_MAX	/* # links a file may have */
+#endif
+#define MAX_CANON          255	/* size of the canonical input queue */
+#define MAX_INPUT          255	/* size of the type-ahead buffer */
+#define NAME_MAX        DIRSIZ	/* # chars in a file name */
+#define PIPE_BUF          7168	/* # bytes in atomic write to a pipe */
+#define STREAM_MAX          20	/* must be the same as FOPEN_MAX in stdio.h */
+#define TZNAME_MAX           3	/* maximum bytes in a time zone name is 3 */
+#define SSIZE_MAX        32767	/* max defined byte count for read() */
+
+#endif /* _POSIX_SOURCE */
+
+#endif /* ANULADO */
+
+#endif /* _LIMITS_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/macros.h /usr/src/linux/include/minix/macros.h
--- /home/jara/linux-2.6.32/include/minix/macros.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/macros.h	2013-09-18 10:07:00.000000000 -0300
@@ -0,0 +1,18 @@
+/* Constants and macros for bit map manipulation. */
+#define MAP_CHUNK(map,bit) (map)[((bit)/BITCHUNK_BITS)]
+#define CHUNK_OFFSET(bit) ((bit)%BITCHUNK_BITS))
+#define GET_BIT(map,bit) ( MAP_CHUNK(map,bit) & (1 << CHUNK_OFFSET(bit) )
+#define SET_BIT(map,bit) ( MAP_CHUNK(map,bit) |= (1 << CHUNK_OFFSET(bit) )
+#define UNSET_BIT(map,bit) ( MAP_CHUNK(map,bit) &= ~(1 << CHUNK_OFFSET(bit) )
+
+#define get_node_bit(x,y) 	get_sys_bit(x,y)
+#define set_node_bit(x,y) 	set_sys_bit(x,y)
+#define unset_node_bit(x,y) 	unset_sys_bit(x,y)
+
+#define get_sys_bit(map,bit) \
+	( MAP_CHUNK(map.chunk,bit) & (1 << CHUNK_OFFSET(bit) )
+#define set_sys_bit(map,bit) \
+	( MAP_CHUNK(map.chunk,bit) |= (1 << CHUNK_OFFSET(bit) )
+#define unset_sys_bit(map,bit) \
+	( MAP_CHUNK(map.chunk,bit) &= ~(1 << CHUNK_OFFSET(bit) )
+#define NR_SYS_CHUNKS	BITMAP_CHUNKS(NR_SYS_PROCS)
diff -Naur /home/jara/linux-2.6.32/include/minix/moldebug.h /usr/src/linux/include/minix/moldebug.h
--- /home/jara/linux-2.6.32/include/minix/moldebug.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/moldebug.h	2013-10-12 15:57:00.000000000 -0300
@@ -0,0 +1,83 @@
+
+#define MOLDBG		1
+
+#define NODEBUG  	0x00000000
+#define DBGLVL0  	0x00000001
+#define GENERIC  	0x00000002
+#define INTERNAL  	0x00000004
+#define DBGLVL3  	0x00000008
+#define DBGLVL4  	0x00000010
+#define DBGLVL5  	0x00000020
+#define DBGLVL6  	0x00000040
+#define DBGLVL7  	0x00000080
+
+#define DBGPROCLOCK  0x00000100
+#define DBGVMLOCK  	 0x00000200
+#define DBGNODELOCK  0x00000400
+#define DBGTASKLOCK  0x00000800
+
+#define DBGMESSAGE	0x00001000
+#define DBGCMD		0x00002000
+#define DBGVCOPY	0x00004000
+#define DBGPARAMS	0x00008000
+
+#define DBGPROC		0x00010000
+#define DBGPRIV		0x00020000
+#define DBGPROCSEM	0x00040000
+#define DBGNODE		0x00080000
+#define DBGPROXYLOCK	0x00100000
+#define DBGREFCOUNT	0x00200000
+
+
+#ifdef MOLDBG
+ #define MOLDEBUG(dbglvl, text, args ...) \
+ do { \
+ if(dbglvl & drvs.d_dbglvl) \
+     printk("DEBUG %d:%s:%u: " \
+             text, current->pid, __FUNCTION__ ,__LINE__, ## args); \
+ }while(0);
+#else 
+#define MOLDEBUG(x, args ...)
+#endif 
+
+#if MOLPROFILING != 0
+#define MOLPROFVAR(tmp) uint64_t tmp;
+#else 
+#define MOLPROFVAR(tmp) 
+#endif 
+
+#if MOLPROFILING != 0
+#define MOLPROFINIT(tmp) tmp = get_cicles()
+#else 
+#define MOLPROFINIT(tmp) 
+#endif 
+
+#if MOLPROFILING != 0
+#define MOLPROFLOG(p,n) do { p->p_profiling[n]= get_cicles();  p->p_profline[n] = __LINE__;} while(0)
+#else 
+#define MOLPROFLOG(p,n)
+#endif 
+
+#if MOLPROFILING != 0
+#define MOLPROFPRT(p,tmp) do { \
+	int index;\
+	p->p_profiling[0]= tmp;\
+	p->p_profline[0]= 0;\
+	printk("PROF %d:%s:%u:0:%lld:0\n", \
+		current->pid, __FUNCTION__ ,p->p_profline[0], p->p_profiling[0]);\
+	for ( index = 1; index < MAX_PROF; index++) \
+	     printk("PROF %d:%s:%u:%d:%lld:%lld\n",\
+		current->pid, __FUNCTION__ ,p->p_profline[index], index, p->p_profiling[index],\
+		(p->p_profiling[index]- p->p_profiling[index-1]) ); \
+	} while(0);
+#else 
+#define MOLPROFPRT(p,tmp)
+#endif 
+
+
+
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/include/minix/molerrno.h /usr/src/linux/include/minix/molerrno.h
--- /home/jara/linux-2.6.32/include/minix/molerrno.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/molerrno.h	2015-03-18 12:18:37.000000000 -0300
@@ -0,0 +1,153 @@
+
+#define _SIGN         -
+
+/* Here are the numerical values of the error numbers. */
+#define _NERROR               70  /* number of errors */  
+
+#define EMOLGENERIC      (_SIGN 99)  /* generic error */
+#define EMOLPERM         (_SIGN  1)  /* operation not permitted */
+#define EMOLNOENT        (_SIGN  2)  /* no such file or directory */
+#define EMOLSRCH         (_SIGN  3)  /* no such process */
+#define EMOLINTR         (_SIGN  4)  /* interrupted function call */
+#define EMOLIO           (_SIGN  5)  /* input/output error */
+#define EMOLNXIO         (_SIGN  6)  /* no such device or address */
+#define EMOL2BIG         (_SIGN  7)  /* arg list too long */
+#define EMOLNOEXEC       (_SIGN  8)  /* exec format error */
+#define EMOLBADF         (_SIGN  9)  /* bad file descriptor */
+#define EMOLCHILD        (_SIGN 10)  /* no child process */
+#define EMOLAGAIN        (_SIGN 11)  /* resource temporarily unavailable */
+#define EMOLNOMEM        (_SIGN 12)  /* not enough space */
+#define EMOLACCES        (_SIGN 13)  /* permission denied */
+#define EMOLFAULT        (_SIGN 14)  /* bad address */
+#define EMOLNOTBLK       (_SIGN 15)  /* Extension: not a block special file */
+#define EMOLBUSY         (_SIGN 16)  /* resource busy */
+#define EMOLEXIST        (_SIGN 17)  /* file exists */
+#define EMOLXDEV         (_SIGN 18)  /* improper link */
+#define EMOLNODEV        (_SIGN 19)  /* no such device */
+#define EMOLNOTDIR       (_SIGN 20)  /* not a directory */
+#define EMOLISDIR        (_SIGN 21)  /* is a directory */
+#define EMOLINVAL        (_SIGN 22)  /* invalid argument */
+#define EMOLNFILE        (_SIGN 23)  /* too many open files in system */
+#define EMOLMFILE        (_SIGN 24)  /* too many open files */
+#define EMOLNOTTY        (_SIGN 25)  /* inappropriate I/O control operation */
+#define EMOLTXTBSY       (_SIGN 26)  /* no longer used */
+#define EMOLFBIG         (_SIGN 27)  /* file too large */
+#define EMOLNOSPC        (_SIGN 28)  /* no space left on device */
+#define EMOLSPIPE        (_SIGN 29)  /* invalid seek */
+#define EMOLROFS         (_SIGN 30)  /* read-only file system */
+#define EMOLMLINK        (_SIGN 31)  /* too many links */
+#define EMOLPIPE         (_SIGN 32)  /* broken pipe */
+#define EMOLDOM          (_SIGN 33)  /* domain error    	(from ANSI C std) */
+#define EMOLRANGE        (_SIGN 34)  /* result too large	(from ANSI C std) */
+#define EMOLDEADLK       (_SIGN 35)  /* resource deadlock avoided */
+#define EMOLNAMETOOLONG  (_SIGN 36)  /* file name too long */
+#define EMOLNOLCK        (_SIGN 37)  /* no locks available */
+#define EMOLNOSYS        (_SIGN 38)  /* function not implemented */
+#define EMOLNOTEMPTY     (_SIGN 39)  /* directory not empty */
+#define EMOLLOOP         (_SIGN 40)  /* too many levels of symlinks detected */
+
+/* The following errors relate to networking. */
+#define EMOLPACKSIZE     (_SIGN 50)  /* invalid packet size for some protocol */
+#define EMOLOUTOFBUFS    (_SIGN 51)  /* not enough buffers left */
+#define EMOLBADIOCTL     (_SIGN 52)  /* illegal ioctl for device */
+#define EMOLBADMODE      (_SIGN 53)  /* badmode in ioctl */
+#define EMOLWOULDBLOCK   (_SIGN 54)
+#define EMOLBADDEST      (_SIGN 55)  /* not a valid destination address */
+#define EMOLDSTNOTRCH    (_SIGN 56)  /* destination not reachable */
+#define EMOLISCONN	      (_SIGN 57)  /* all ready connected */
+#define EMOLADDRINUSE    (_SIGN 58)  /* address in use */
+#define EMOLCONNREFUSED  (_SIGN 59)  /* connection refused */
+#define EMOLCONNRESET    (_SIGN 60)  /* connection reset */
+#define EMOLTIMEDOUT     (_SIGN 61)  /* connection timed out */
+#define EMOLURG	      (_SIGN 62)  /* urgent data present */
+#define EMOLNOURG	      (_SIGN 63)  /* no urgent data present */
+#define EMOLNOTCONN      (_SIGN 64)  /* no connection (yet or anymore) */
+#define EMOLSHUTDOWN     (_SIGN 65)  /* a write call to a shutdown connection */
+#define EMOLNOCONN       (_SIGN 66)  /* no such connection */
+#define EMOLAFNOSUPPORT  (_SIGN 67)  /* address family not supported */
+#define EMOLPROTONOSUPPORT (_SIGN 68) /* protocol not supported by AF */
+#define EMOLPROTOTYPE    (_SIGN 69)  /* Protocol wrong type for socket */
+#define EMOLINPROGRESS   (_SIGN 70)  /* Operation now in progress */
+#define EMOLADDRNOTAVAIL (_SIGN 71)  /* Can't assign requested address */
+#define EMOLALREADY      (_SIGN 72)  /* Connection already in progress */
+#define EMOLMSGSIZE      (_SIGN 73)  /* Message too long */
+#define EMOLNOTSOCK      (_SIGN 74)  /* Socket operation on non-socket */
+#define EMOLNOPROTOOPT   (_SIGN 75)  /* Protocol not available */
+
+/* The following are not POSIX errors, but they can still happen. 
+ * All of these are generated by the kernel and relate to message passing.
+ */
+#define EMOLLOCKED      (_SIGN 101)  /* can't send message due to deadlock */
+#define EMOLBADCALL     (_SIGN 102)  /* illegal system call number */
+#define EMOLBADSRCDST   (_SIGN 103)  /* bad source or destination process */
+#define EMOLCALLDENIED  (_SIGN 104)  /* no permission for system call */
+#define EMOLDEADSRCDST  (_SIGN 105)  /* source or destination is not alive */
+#define EMOLNOTREADY    (_SIGN 106)  /* source or destination is not ready */
+#define EMOLBADREQUEST  (_SIGN 107)  /* destination cannot handle request */
+#define EMOLSRCDIED     (_SIGN 108)  /* source just died */
+#define EMOLDSTDIED     (_SIGN 109)  /* destination just died */
+#define EMOLTRAPDENIED  (_SIGN 110)  /* IPC trap not allowed */
+#define EMOLDONTREPLY   (_SIGN 201)  /* pseudo-code: don't send a reply */
+
+/* the following ar MOL error codes */
+#define EMOLERRCODE 	(_SIGN 300) 
+#define EMOLBADNODEID 	(_SIGN 301)  /* Bad NODE ID */
+#define EMOLBADVMID 	(_SIGN 302)  /* Bad VM ID */
+#define EMOLVMNOTRUN 	(_SIGN 303)  /* The VM is not running */
+#define EMOLBADPROC  	(_SIGN 304)  /* Bad Process Number */
+#define EMOLBADPID  	(_SIGN 305)  /* Bad Process ID */
+#define EMOLENDPOINT  	(_SIGN 306)  /* Bad Process Endpoint */
+#define EMOLNOPROXY 	(_SIGN 307)  /* The IPC proxy is not running */
+#define EMOLRMTPROC 	(_SIGN 308)  /* The process is REMOTE */
+#define EMOLLCLPROC 	(_SIGN 309)  /* The process is LOCAL */
+#define EMOLNOTBIND 	(_SIGN 310)  /* The process has not BINDed */
+#define EMOLPROXYRUN 	(_SIGN 311)  /* The IPC proxy is already running */
+#define EMOLACKDST 	(_SIGN 312)  /* The IPC proxy sent local process a BAD destination ACK  */
+#define EMOLACKSRC 	(_SIGN 313)  /* The IPC proxy sent local process a BAD source ACK  */
+#define EMOLACKWAIT 	(_SIGN 314)  /* The IPC proxy sent local process that is not waiting for it  */
+#define EMOLNODEBUSY 	(_SIGN 315)  /* NODE is BUSY */
+#define EMOLNONODE 	(_SIGN 316)  /* NODE does not exists or is not in list */
+#define EMOLDRVSBUSY 	(_SIGN 317)  /* The DRVS is BUSY - Can't assign new local node ID */
+#define EMOLDRVSINIT 	(_SIGN 318)  /* The DRVS has not been initialized */
+#define EMOLNOVMNODE 	(_SIGN 319)  /* The NODE is not included into the VM list of nodes */
+#define EMOLPROCRUN 	(_SIGN 320)  /* The copy source/destination process is running */
+#define EMOLNOMSG 	(_SIGN 321)  /*  No message  - list empty	*/
+#define EMOLVMRUN 	(_SIGN 323)  /* The VM is already running */
+#define EMOLPROCSTS (_SIGN 324)  	/* Bad process status  */
+#define EMOLNODEFREE (_SIGN 325)  /* NODE is FREE */
+#define EMOLVMNODE 	(_SIGN 326)  /* The NODE is ALREADY included into the VM list of nodes */
+#define EMOLBADPROXY (_SIGN 327)  /* The NODE is ALREADY included into the VM list of nodes */
+#define EMOLONCOPY	 (_SIGN 328)  	/* The process is in ONCOPY state  */
+#define EMOLENQUEUED	 (_SIGN 329)  	/* The process descriptor is enqueued and cant be used */
+#define EMOLOVERRUN	 (_SIGN 330)  	/* An operation couse an overrun of some system resource */
+#define EMOLBADOWNER	 (_SIGN 331)  	/* A bind operation try to alloc a slot with other owner */
+#define EMOLMIGRATE 	 (_SIGN 332)  	/* The process is migrating */
+#define EMOLPROXYFREE 	 (_SIGN 333)  	/* The proxy pair is free  */
+#define EMOLGRPLEADER 	 (_SIGN 334)  	/* The process is a child thread, it is not the thread group leader */
+#define EMOLPRIVILEGES 	 (_SIGN 335)  	/* The process has no privileges for the call */
+#define EMOLBINDTYPE 	 (_SIGN 336)  	/* Bad BIND TYPE */
+#define EMOLSLOTUSED 	 (_SIGN 337)  	/* BIND the slot is already used */
+#define EMOLBADRANGE 	 (_SIGN 338)  	/* Bad range of a value  */
+#define EMOLBADVALUE 	 (_SIGN 339)  	/* Bad value  */
+#define EMOLBADDIR 		 (_SIGN 340)  	/* Bad Directory  */
+#define EMOLBADFILE		 (_SIGN 341)  	/* Bad File  */
+#define EMOLRSCBUSY		 (_SIGN 342)  	/* Resources busy  */
+#define EMOLNAMESIZE 	 (_SIGN 343)  	/* Name size too long  */
+#define EMOLALLOCMEM	 (_SIGN 344)  	/* Error on allocating memory  */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/include/minix/mollib.h /usr/src/linux/include/minix/mollib.h
--- /home/jara/linux-2.6.32/include/minix/mollib.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/mollib.h	2014-06-17 09:12:03.000000000 -0300
@@ -0,0 +1,10 @@
+int getsysinfo(int who, int what, void *where);
+int molsyscall(int who, int syscallnr, message *msgptr);
+
+#define mol_getkinfo(ptr) 	getsysinfo(PM_PROC_NR, SI_KINFO, ptr)
+#define mol_getmachine(ptr) 	getsysinfo(PM_PROC_NR, SI_MACHINE, ptr)
+#define mol_getkproctab(ptr) 	getsysinfo(PM_PROC_NR, SI_KPROC_TAB, ptr)
+#define mol_getpmproctab(ptr) getsysinfo(PM_PROC_NR, SI_PMPROC_TAB, ptr)
+#define mol_getprivtab(ptr)   getsysinfo(PM_PROC_NR, SI_PRIV_TAB, ptr)
+#define mol_getslotstab(ptr)   getsysinfo(PM_PROC_NR, SI_SLOTS_TAB, ptr)
+
diff -Naur /home/jara/linux-2.6.32/include/minix/mol-macros.h /usr/src/linux/include/minix/mol-macros.h
--- /home/jara/linux-2.6.32/include/minix/mol-macros.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/mol-macros.h	2013-10-12 14:10:04.000000000 -0300
@@ -0,0 +1,590 @@
+/****************************************************************/
+/*			MOL MACROS   			*/
+/****************************************************************/
+
+/*----------------------------------------------------------------*/
+/*				ERROR CHECKING MACROS 				*/
+/*----------------------------------------------------------------*/
+
+#define CHECK_VMID(vmid) 	if( vmid < 0 || vmid >= drvs.d_nr_vms) 	ERROR_RETURN(EMOLBADVMID);
+#define CHECK_NODEID(nodeid) 	if( nodeid < 0 || nodeid >= drvs.d_nr_nodes) 	ERROR_RETURN(EMOLBADNODEID);
+#define CHECK_PID(pid, p_ptr)	if (pid != p_ptr->p_usr.p_lpid) 		ERROR_RETURN(EMOLBADPID);
+
+#define CHECK_IF_VM_RUN(v_ptr) 	if( v_ptr->vm_usr.vm_flags) 			ERROR_RUNLOCK_VM(v_ptr,EMOLVMNOTRUN);
+
+#define VM_PROC(vm_ptr,i)	((struct proc *) (((char *) vm_ptr->vm_proc) + ( i << log2_proc_size)))
+#define IT_IS_REMOTE(proc)	test_bit(BIT_REMOTE, &proc->p_usr.p_rts_flags)
+#define IT_IS_LOCAL(proc)	!test_bit(BIT_REMOTE, &proc->p_usr.p_rts_flags)
+
+#define ENDPOINT2PTR(vm_ptr, ep) VM_PROC(vm_ptr,(_ENDPOINT_P(ep)+vm_ptr->vm_usr.vm_nr_tasks))
+#define NBR2PTR(vm_ptr, nr)	VM_PROC(vm_ptr,(nr+vm_ptr->vm_usr.vm_nr_tasks))
+#define DRVS_NOT_INIT()		(atomic_read(&local_nodeid) == DRVS_NO_INIT)
+
+#define VM_INCREF(v)		kref_get(&v->vm_kref); 
+#define VM_DECREF(v)		kref_put(&v->vm_kref, vm_release); 
+
+#define NODE2SPROXY(n) 	  &proxies[node[n].n_usr.n_proxies].px_sproxy
+#define NODE2RPROXY(n) 	  &proxies[node[n].n_usr.n_proxies].px_rproxy
+
+#define KREF_GET(rc) do { \
+  	MOLDEBUG(DBGREFCOUNT ,"KREF_GET counter=%d\n",atomic_read(rc.refcount));\
+	kref_get(rc);\
+}while(0);
+
+#define KREF_PUT(rc, function) do { \
+  	MOLDEBUG(DBGREFCOUNT ,"KREF_PUT counter=%d\n",atomic_read(rc.refcount));\
+	kref_put(rc, function);\
+}while(0);
+
+/*----------------------------------------------------------------*/
+/*				MACROS 				*/
+/*----------------------------------------------------------------*/
+#define ERROR_PRINT(rcode) \
+ do { \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__,rcode); \
+ }while(0);
+ 
+#define ERROR_RETURN(rcode) \
+ do { \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__,rcode); \
+	return(rcode); \
+ }while(0);
+
+
+#define ERROR_RUNLOCK_VM(v,rcode) \
+ do { \
+	RUNLOCK_VM(v); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+
+#define ERROR_WUNLOCK_VM(v,rcode) \
+ do { \
+	WUNLOCK_VM(v); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+ 
+#define ERROR_RUNLOCK_PROC(p,rcode) \
+ do { \
+	RUNLOCK_PROC(p); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+
+#define ERROR_WUNLOCK_PROC(p,rcode) \
+ do { \
+	WUNLOCK_PROC(p); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+
+#define ERROR_UNLOCK_TASK(task, rcode) \
+ do { \
+	UNLOCK_TASK(task);\
+	ERROR_RETURN(rcode);\
+ }while(0);
+ 
+#define LOCAL_PROC_UP(proc, rcode) \
+ do { \
+	inherit_cpu(proc) \
+ 	proc->p_rcode = rcode; \
+MOLDEBUG(DBGPROCSEM,"BEFORE UP lpid=%d p_sem=%d rcode=%d\n",proc->p_usr.p_lpid,proc->p_pseudosem, rcode); \
+	proc->p_pseudosem += 1; \
+	wake_up_interruptible(&proc->p_wqhead); \
+}while(0);
+
+#define READY_UP_SHUTDOWN(proc) \
+ do { \
+ 	inherit_cpu(proc) \
+   	proc->p_rcode = EMOLSHUTDOWN; \
+MOLDEBUG(DBGPROCSEM,"BEFORE UP lpid=%d p_sem=%d\n",proc->p_usr.p_lpid,proc->p_pseudosem); \
+	proc->p_pseudosem += 1; \
+	wake_up_interruptible(&proc->p_wqhead); \
+	}\
+ }while(0);
+
+#define READY_UP_RCODE(proc, cmd, rcode) \
+ do { \
+ 	inherit_cpu(proc) \
+	proc->p_rcode = rcode; \
+MOLDEBUG(DBGPROCSEM,"BEFORE UP lpid=%d p_sem=%d\n",proc->p_usr.p_lpid,proc->p_pseudosem); \
+	proc->p_pseudosem += 1; \
+	wake_up_interruptible(&proc->p_wqhead); \
+ }while(0); 
+
+#define BUILD_NOTIFY_MSG(v, p, ep) \
+ do { \
+	p->p_message.m_source 	= ep;\
+	p->p_message.m_type 	= NOTIFY_FROM(p->p_usr.p_nr+v->vm_usr.vm_nr_tasks);\
+	p->p_message.NOTIFY_TIMESTAMP = current_kernel_time();\
+	switch (p->p_usr.p_nr) {\
+		case HARDWARE:\
+		p->p_message.NOTIFY_ARG = (long) p->p_priv.s_int_pending;\
+			p->p_priv.s_int_pending = 0;\
+			break;\
+		case SYSTEM:\
+			p->p_message.NOTIFY_ARG = (long) p->p_priv.s_sig_pending;\
+			p->p_priv.s_sig_pending = 0;\
+			break;\
+		}\
+ }while(0); 
+
+
+#define WLOCK_PROC2(p,q)		\
+do {\
+	if( p->p_usr.p_nr < q->p_usr.p_nr) { \
+		WLOCK_PROC(p);\
+		WLOCK_PROC(q);\
+	}else{\
+		WLOCK_PROC(q);\
+		WLOCK_PROC(p);\
+	}\
+}while(0);
+
+#define WUNLOCK_PROC2(p,q)	\
+do {\
+	WUNLOCK_PROC(p);\
+	WUNLOCK_PROC(q);\
+}while(0); 
+
+#define WLOCK_PROC3(p,q,r)		\
+do {\
+	if( p->p_usr.p_nr < q->p_usr.p_nr) { \
+		if( r->p_usr.p_nr < q->p_usr.p_nr) {\
+			WLOCK_PROC2(p,r);\
+			WLOCK_PROC(q);\
+		}else{ \
+			WLOCK_PROC2(p,q);\
+			WLOCK_PROC(r);\
+		}\
+	}else{\
+		if( r->p_usr.p_nr < p->p_usr.p_nr) {\
+			WLOCK_PROC2(q,r);\
+			WLOCK_PROC(p);\
+		}else{ \
+			WLOCK_PROC2(q,p);\
+			WLOCK_PROC(r);\
+		}\
+	}\
+}while(0);
+
+#define WUNLOCK_PROC3(p,q,r)	\
+do {\
+	WUNLOCK_PROC(p);\
+	WUNLOCK_PROC(q);\
+	WUNLOCK_PROC(r);\
+}while(0);
+
+#define LOCK_TASK(task) 	\
+do {\
+	mutex_lock(&task->proc_mutex);\
+MOLDEBUG(DBGTASKLOCK ,"LOCK_TASK pid=%d count=%d\n",task->pid,atomic_read(&task->proc_mutex.count));\
+}while(0);
+
+#define UNLOCK_TASK(task) 	\
+do {\
+MOLDEBUG(DBGTASKLOCK ,"UNLOCK_TASK pid=%d count=%d\n",task->pid,atomic_read(&task->proc_mutex.count));\
+	mutex_unlock(&task->proc_mutex);\
+}while(0);
+
+#define CHECK_ENDPOINT(t, p_ptr,ep) \
+do {\
+	if( p_ptr->p_usr.p_endpoint != ep) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLENDPOINT);\
+	}\
+}while(0)
+
+#define CHECK_IF_NULL(t, p_ptr)	\
+do {\
+	if( p_ptr == NULL ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLBADPROC);\
+	}\
+}while(0)
+
+#define CHECK_IF_REMOTE(t, p_ptr)	\
+do {\
+	if( IT_IS_REMOTE(p_ptr) ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLRMTPROC);\
+	}\
+}while(0)
+
+#define CHECK_IF_LOCAL(t, p_ptr)	\
+do {\
+	if( !IT_IS_REMOTE(p_ptr) ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLLCLPROC);\
+	}\
+}while(0)
+
+#define CHECK_IF_EMPTY(t, p_ptr)	\
+do {\
+	if( p_ptr->p_usr.p_rts_flags == SLOT_FREE ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLDSTDIED);\
+	}\
+}while(0)
+
+#define CHECK_P_NR(t, v_ptr, p_nr)		\
+do {\
+	if( p_nr < (-v_ptr->vm_usr.vm_nr_tasks) || p_nr >= v_ptr->vm_usr.vm_nr_procs) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLRANGE);\
+	}\
+}while(0)
+
+
+/*--------------------------------------------------------- USE_PROC_RWLOCKS ---------------------------------------*/
+#if LOCK_PROC_TYPE == USE_PROC_RWLOCK
+
+#define RUNLOCK_PROC(p)	\
+	do {\
+MOLDEBUG(DBGPROCLOCK,"RUNLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint, atomic_read(&p->p_mutex.count));\
+		read_unlock(&p->p_rwlock);\
+	}while(0); 
+
+#define WUNLOCK_PROC(p)	\
+do {\
+MOLDEBUG(DBGPROCLOCK,"WUNLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+	write_unlock(&p->p_rwlock);\
+}while(0); 
+
+#define WLOCK_PROC(p)		\
+do {\
+	write_lock(&p->p_rwlock);\
+MOLDEBUG(DBGPROCLOCK,"WLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+}while(0);
+
+#define RLOCK_PROC(p)		\
+do {\
+	read_lock(&p->p_rwlock);\
+MOLDEBUG(DBGPROCLOCK,"RLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+	 	ret = copy_to_user(uaddr, kaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#define COPY_FROM_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+ 	ret = copy_from_user(kaddr, uaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#define COPY_USR2USR_PROC(ret, endpoint, src, srcaddr, dst, dstaddr, len )		\
+do {\
+		preempt_enable();\
+	ret = copy_usr2usr(endpoint, src, srcaddr, dst, dstaddr, len);\
+		preempt_disable();\
+}while(0)
+
+
+#else 
+/*--------------------------------------------------------- USE_PROC_MUTEX  ---------------------------------------*/
+#define RUNLOCK_PROC(p)	\
+	do {\
+MOLDEBUG(DBGPROCLOCK,"RUNLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint, atomic_read(&p->p_mutex.count));\
+		mutex_unlock(&p->p_mutex);\
+	}while(0); 
+
+#define WUNLOCK_PROC(p)	\
+do {\
+MOLDEBUG(DBGPROCLOCK,"WUNLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+	mutex_unlock(&p->p_mutex);\
+}while(0); 
+
+#define WLOCK_PROC(p)		\
+do {\
+	mutex_lock(&p->p_mutex);\
+MOLDEBUG(DBGPROCLOCK,"WLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+}while(0);
+
+#define RLOCK_PROC(p)		\
+do {\
+	mutex_lock(&p->p_mutex);\
+MOLDEBUG(DBGPROCLOCK,"RLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+	 	ret = copy_to_user(uaddr, kaddr, len);\
+}while(0)
+
+#define COPY_FROM_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+ 	ret = copy_from_user(kaddr, uaddr, len);\
+}while(0)
+
+#define COPY_USR2USR_PROC(ret, endpoint, src, srcaddr, dst, dstaddr, len )		\
+do {\
+	ret = copy_usr2usr(endpoint, src, srcaddr, dst, dstaddr, len);\
+}while(0)
+
+#endif
+
+#define LOCK_ALL_PROCS(vm_ptr, proc_ptr, i) do { \
+MOLDEBUG(INTERNAL,"Locking all processes of VM=%d\n",vm_ptr->vm_usr.vm_vmid); \
+	for (i = 0; i < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs); i++) {\
+		tmp_ptr = VM_PROC(vm_ptr,i);\
+		WLOCK_PROC(tmp_ptr); \
+	}\
+}while(0)
+
+#define UNLOCK_ALL_PROCS(vm_ptr, proc_ptr,i) do{ \
+MOLDEBUG(INTERNAL,"Unlocking all processes of VM=%d\n",vm_ptr->vm_usr.vm_vmid);\
+	for (i = 0; i < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs); i++) {\
+		tmp_ptr = VM_PROC(vm_ptr,i);\
+		WUNLOCK_PROC(tmp_ptr); \
+	}\
+}while(0)
+
+#define FOR_EACH_PROC(vm_ptr, i) \
+	for (i = 0; i < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs); i++) \
+
+
+/*--------------------------------------------------------- USE_VM_RWLOCKS ---------------------------------------*/
+#if LOCK_VM_TYPE == USE_VM_RWLOCK
+#define WUNLOCK_VM(v)	\
+do {\
+MOLDEBUG(DBGVMLOCK,"WUNLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+	write_unlock(&v->vm_rwlock);\
+}while(0); 
+
+#define RUNLOCK_VM(v)	\
+do {\
+MOLDEBUG(DBGVMLOCK,"RUNLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+	read_unlock(&v->vm_rwlock);\
+}while(0); 
+	
+#define WLOCK_VM(v)		\
+do {\
+	write_lock(&v->vm_rwlock);\
+MOLDEBUG(DBGVMLOCK,"WLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+}while(0);
+
+#define RLOCK_VM(v)		\
+do {\
+	read_lock(&v->vm_rwlock);\
+MOLDEBUG(DBGVMLOCK,"RLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_VM(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#else
+/*--------------------------------------------------------- USE_VM_MUTEX  ---------------------------------------*/
+#define WUNLOCK_VM(v)	\
+do {\
+MOLDEBUG(DBGVMLOCK,"WUNLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+	mutex_unlock(&v->vm_mutex);\
+}while(0); 
+
+#define RUNLOCK_VM(v)	\
+do {\
+MOLDEBUG(DBGVMLOCK,"RUNLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+	mutex_unlock(&v->vm_mutex);\
+}while(0); 
+	
+#define WLOCK_VM(v)		\
+do {\
+	mutex_lock(&v->vm_mutex);\
+MOLDEBUG(DBGVMLOCK,"WLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+}while(0);
+
+#define RLOCK_VM(v)		\
+do {\
+	mutex_lock(&v->vm_mutex);\
+MOLDEBUG(DBGVMLOCK,"RLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_VM(ret, kaddr, uaddr, len )		\
+do {\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+}while(0)
+
+#endif
+
+/*--------------------------------------------------------- USE_DRVS_RWLOCKS ---------------------------------------*/
+#if LOCK_DRVS_TYPE == USE_DRVS_RWLOCK
+#define WUNLOCK_DRVS	\
+do {\
+	write_unlock(&drvs_rwlock);\
+}while(0); 
+
+#define RUNLOCK_DRVS	\
+do {\
+	read_unlock(&drvs_rwlock);\
+}while(0); 
+	
+#define WLOCK_DRVS		\
+do {\
+	write_lock(&drvs_rwlock);\
+}while(0);
+
+#define RLOCK_DRVS		\
+do {\
+	read_lock(&drvs_rwlock);\
+}while(0);
+
+
+#else
+/*--------------------------------------------------------- USE_DRVS_MUTEX  ---------------------------------------*/
+#define WUNLOCK_DRVS	\
+do {\
+	mutex_unlock(&drvs_mutex);\
+}while(0); 
+
+#define RUNLOCK_DRVS	\
+do {\
+	mutex_unlock(&drvs_mutex);\
+}while(0); 
+	
+#define WLOCK_DRVS		\
+do {\
+	mutex_lock(&drvs_mutex);\
+}while(0);
+
+#define RLOCK_DRVS		\
+do {\
+	mutex_lock(&drvs_mutex);\
+}while(0);
+
+
+#endif
+
+/*--------------------------------------------------------- USE_NODE_RWLOCKS ---------------------------------------*/
+#if LOCK_NODE_TYPE == USE_NODE_RWLOCK
+#define WUNLOCK_NODE(n)	\
+do {\
+MOLDEBUG(DBGNODELOCK,"WUNLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+	write_unlock(&n->n_rwlock);\
+}while(0); 
+
+#define RUNLOCK_NODE(n)	\
+do {\
+MOLDEBUG(DBGNODELOCK,"RUNLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+	read_unlock(&n->n_rwlock);\
+}while(0); 
+	
+#define WLOCK_NODE(n)		\
+do {\
+	write_lock(&n->n_rwlock);\
+MOLDEBUG(DBGNODELOCK,"WLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+}while(0);
+
+#define RLOCK_NODE(n)		\
+do {\
+	read_lock(&n->n_rwlock);\
+MOLDEBUG(DBGNODELOCK,"RLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_NODE(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#else
+/*--------------------------------------------------------- USE_NODE_MUTEX  ---------------------------------------*/
+#define WUNLOCK_NODE(n)	\
+do {\
+MOLDEBUG(DBGNODELOCK,"WUNLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+	mutex_unlock(&n->n_mutex);\
+}while(0); 
+
+#define RUNLOCK_NODE(n)	\
+do {\
+MOLDEBUG(DBGNODELOCK,"RUNLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+	mutex_unlock(&n->n_mutex);\
+}while(0); 
+	
+#define WLOCK_NODE(n)		\
+do {\
+	mutex_lock(&n->n_mutex);\
+MOLDEBUG(DBGNODELOCK,"WLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+}while(0);
+
+#define RLOCK_NODE(n)		\
+do {\
+	mutex_lock(&n->n_mutex);\
+MOLDEBUG(DBGNODELOCK,"RLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_NODE(ret, kaddr, uaddr, len )		\
+do {\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+}while(0)
+
+#endif
+
+/*--------------------------------------------------------- USE_PROXY_RWLOCKS ---------------------------------------*/
+#if LOCK_PROXY_TYPE == USE_PROXY_RWLOCK
+#define WUNLOCK_PROXY(px)	\
+do {\
+MOLDEBUG(DBGPROXYLOCK,"WUNLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+	write_unlock(&px->px_rwlock);\
+}while(0); 
+
+#define RUNLOCK_PROXY(px)	\
+do {\
+MOLDEBUG(DBGPROXYLOCK,"RUNLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+	read_unlock(&px->px_rwlock);\
+}while(0); 
+	
+#define WLOCK_PROXY(px)		\
+do {\
+	write_lock(&px->px_rwlock);\
+MOLDEBUG(DBGPROXYLOCK,"WLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+}while(0);
+
+#define RLOCK_PROXY(px)		\
+do {\
+	read_lock(&px->px_rwlock);\
+MOLDEBUG(DBGPROXYLOCK,"RLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+}while(0);
+
+
+#else
+/*--------------------------------------------------------- USE_PROXY_MUTEX  ---------------------------------------*/
+#define WUNLOCK_PROXY(px)	\
+do {\
+MOLDEBUG(DBGPROXYLOCK,"WUNLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+	mutex_unlock(&px->px_mutex);\
+}while(0); 
+
+#define RUNLOCK_PROXY(px)	\
+do {\
+MOLDEBUG(DBGPROXYLOCK,"RUNLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+	mutex_unlock(&px->px_mutex);\
+}while(0); 
+	
+#define WLOCK_PROXY(px)		\
+do {\
+	mutex_lock(&px->px_mutex);\
+MOLDEBUG(DBGPROXYLOCK,"WLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+}while(0);
+
+#define RLOCK_PROXY(px)		\
+do {\
+	mutex_lock(&px->px_mutex);\
+MOLDEBUG(DBGPROXYLOCK,"RLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+}while(0);
+
+#endif
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/include/minix/node_usr.h /usr/src/linux/include/minix/node_usr.h
--- /home/jara/linux-2.6.32/include/minix/node_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/node_usr.h	2013-10-10 11:13:00.000000000 -0300
@@ -0,0 +1,35 @@
+#ifndef NODE_USR_H
+#define NODE_USR_H
+
+#define MAXNODENAME	16
+
+
+#define NODE_BIT_ATTACHED		1	/* The node is attached to a pair of proxies 	*/
+#define NODE_BIT_SCONNECTED		2	/* The proxy sender is connected		*/
+#define NODE_BIT_RCONNECTED		3	/* The proxy receiver is connected		*/
+
+#define NODE_FREE		0
+#define NODE_ATTACHED	(1<<NODE_BIT_ATTACHED)
+#define NODE_SCONNECTED	(1<<NODE_BIT_SCONNECTED)
+#define NODE_RCONNECTED	(1<<NODE_BIT_RCONNECTED)
+
+struct node_usr {
+	int			n_nodeid;
+	volatile unsigned long	n_flags;
+	int			n_proxies;		/* proxies ID for this node		*/
+	unsigned long int  	n_vms; 			/* BITMAP 				*/
+	struct timespec 	n_stimestamp;		/* timestamp of the last sent  msg	*/
+	struct timespec 	n_rtimestamp;		/* timestamp of the last received msg	*/
+	char			n_name[MAXNODENAME];
+};
+
+typedef struct node_usr node_usr_t;
+
+#define NODE_USR_FORMAT "n_nodeid=%d n_proxies=%d n_flags=%lX n_vms=%lX n_name=%s\n"
+#define NODE_USR_FIELDS(p) p->n_nodeid, p->n_proxies, p->n_flags, p->n_vms, p->n_name
+
+#define NODE_TIME_FORMAT "n_nodeid=%d n_name=%s n_stime_sec=%ld n_stime_nsec=%ld n_rtime_sec=%ld n_rtime_nsec=%ld\n"
+#define NODE_TIME_FIELDS(p) p->n_nodeid, p->n_name, p->n_stimestamp.tv_sec, p->n_stimestamp.tv_nsec, \
+			p->n_rtimestamp.tv_sec, p->n_rtimestamp.tv_nsec
+
+#endif /* NODE_USR_H */
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/include/minix/priv.h /usr/src/linux/include/minix/priv.h
--- /home/jara/linux-2.6.32/include/minix/priv.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/priv.h	2013-05-30 09:50:00.000000000 -0300
@@ -0,0 +1,23 @@
+
+#ifndef PRIV_H
+#define PRIV_H
+
+#define SYS_PROC	0x10	/* system processes have own priv structure */
+
+/* =================================*/
+/* USER SPACE INCLUDE FILES         */
+/* =================================*/
+#include "priv_usr.h"
+
+struct priv {
+
+  priv_usr_t s_usr;		/* Privileges user fields 		*/
+
+  sys_map_t s_notify_pending; /* bit map with pending notifications */
+  irq_id_t s_int_pending;	/* pending hardware interrupts */
+  ksigset_t s_sig_pending;	/* pending signals */
+
+};
+typedef struct priv priv_t;
+
+#endif /* PRIV_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/priv_usr.h /usr/src/linux/include/minix/priv_usr.h
--- /home/jara/linux-2.6.32/include/minix/priv_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/priv_usr.h	2014-05-02 15:09:14.000000000 -0300
@@ -0,0 +1,30 @@
+#ifndef PRIV_USR_H
+#define PRIV_USR_H
+
+#define USER_PRIV	0x0000
+#define SERVER_PRIV	0x0001
+#define TASK_PRIV	0x0002
+#define SYSTEM_PRIV	0x0003
+#define KERNEL_PRIV	0x0004
+#define PROXY_PRIV	0x0005
+
+struct priv_usr {
+
+  sys_id_t s_id;		/* index of this system structure */
+  int	s_warn;			/* process to warn when the process exit/fork */
+  int	s_level;		/* privilege level		*/
+
+  short s_trap_mask;		/* allowed system call traps */
+  sys_map_t s_ipc_from;		/* allowed callers to receive from */
+  sys_map_t s_ipc_to;		/* allowed destination processes */
+  long s_call_mask;		/* allowed kernel calls */
+
+  moltimer_t s_alarm_timer;	/* synchronous alarm timer */ 
+
+};
+typedef struct priv_usr priv_usr_t;
+
+#define PRIV_USR_FORMAT "s_id=%d s_warn=%d s_level=%d trap=%X call=%X\n"
+#define PRIV_USR_FIELDS(p) p->s_id, p->s_warn, p->s_level,(unsigned int)p->s_trap_mask,(unsigned int) p->s_call_mask
+
+#endif /* PRIV_USR_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/proc.h /usr/src/linux/include/minix/proc.h
--- /home/jara/linux-2.6.32/include/minix/proc.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/proc.h	2013-10-08 15:40:00.000000000 -0300
@@ -0,0 +1,103 @@
+#ifndef PROC_H
+#define PROC_H
+
+/* =================================*/
+/* USER SPACE INCLUDE FILES         */
+/* =================================*/
+#include "types.h"
+#include "macros.h"
+#include "const.h"
+#include "proc_usr.h"
+#include "proc_sts.h"
+#include "vm_usr.h"
+#include "node_usr.h"
+#include "priv.h"
+
+/* =================================*/
+/* PROCESS DESCRIPTOR	             */
+/* =================================*/
+struct proc {
+
+  proc_usr_t	 	p_usr;
+
+  char *p_name_ptr;		/* for local processes is pointer to task_ptr->comm */		
+  int p_rcode;			/* return code of an IPC operation */
+
+  priv_t  p_priv;		/* privileges structure */
+
+  struct list_head p_list;	/* head of list of procs wishing to send 	*/
+  struct list_head p_link;	/* link of the list of procceses whishing to send to other process */
+
+  struct list_head p_mlist;	/* head of list of procs waiting to send to a migrating process 	*/
+  struct list_head p_mlink;	/* link of the list of procceses whishing to send to migrating process */
+  
+  message p_message;		/* buffer to store messages  			*/
+  message *p_umsg;		/* Pointer to message buffer in user space */
+  wait_queue_head_t p_wqhead;	/* LINUX process wait queue head		*/
+  int p_pseudosem;		/* pseudo semaphore 				*/	
+  cmd_t	   p_rmtcmd;	/* remote command 				*/ 
+
+// struct timer_list p_timer; 	/* IPC timeout TIMER	*/
+
+  #if LOCK_PROC_TYPE == USE_PROC_RWLOCK
+  rwlock_t   	p_rwlock;	/* LINUX spinlock to protect this proc	*/	
+  #else	/* USE_PROC_MUTEX*/
+   struct mutex p_mutex;	/* LINUX mutex to protect this proc	*/	
+  #endif 
+  
+  struct task_struct *p_task;	/* pointer to LINUX task structure */
+
+  #if MOLPROFILING != 0
+	int		 p_profline[MAX_PROF];
+	uint64_t p_profiling[MAX_PROF];
+  #endif
+
+};
+typedef struct proc proc_t;
+
+
+/* =================================*/
+/* CLUSTER NODE DESCRIPTOR	      */
+/* =================================*/
+struct cluster_node {
+
+	node_usr_t n_usr;
+	struct proc_dir_entry *n_node_dir;		/* nodeX directory under /proc/drvs 	*/
+	struct proc_dir_entry *n_info_entry;		/* info file under /proc/drvs/nodeX 	*/
+	struct proc_dir_entry *n_stats_entry;		/* stats file under /proc/drvs/nodeX 	*/
+#if LOCK_NODE_TYPE == USE_NODE_RWLOCK
+	rwlock_t   	n_rwlock;	/* LINUX spinlock to protect this NODE	*/	
+#else	/* USE_PROC_MUTEX*/
+	struct mutex n_mutex;	/* LINUX mutex to protect this NODE	*/	
+#endif
+};
+typedef struct cluster_node cluster_node_t;
+
+/* =================================*/
+/* VIRTUAL MACHINE DESCRIPTOR	      */
+/* =================================*/
+struct VM_struct {
+
+	VM_usr_t vm_usr;
+
+	struct kref vm_kref;
+
+#if LOCK_VM_TYPE == USE_VM_RWLOCK
+	rwlock_t  vm_rwlock;
+#else	/* USE_VM_MUTEX*/
+ 	struct mutex vm_mutex;
+#endif
+
+	struct proc_dir_entry *vm_VM_dir;		/* VMx directory under /proc/drvs */
+	struct proc_dir_entry *vm_info_entry;	/* /proc/drvs/VMx/info */
+	struct proc_dir_entry *vm_procs_entry;	/* /proc/drvs/VMx/procs */
+	struct proc_dir_entry *vm_stats_entry;	/* /proc/drvs/VMx/stats */
+
+	struct proc *vm_proc;			/* Dynamic memory pointer to VM process table */ 
+	struct proc **vm_sid2proc;
+};
+typedef struct VM_struct VM_desc_t;
+
+
+	
+#endif /* PROC_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/proc_sts.h /usr/src/linux/include/minix/proc_sts.h
--- /home/jara/linux-2.6.32/include/minix/proc_sts.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/proc_sts.h	2014-09-03 10:03:22.000000000 -0300
@@ -0,0 +1,58 @@
+#ifndef PROC_STS_H
+#define PROC_STS_H
+
+/* =================================*/
+/* PROCESS DESCRIPTOR STATUS        */
+/* =================================*/
+
+/* Bits for the runtime flags. A process is runnable iff p_rts_flags == 0. 	*/
+#define PROC_RUNNING	0x00000000
+
+#define BIT_SLOT_FREE	0
+#define BIT_NO_MAP	1
+#define BIT_SENDING	2
+#define BIT_RECEIVING	3
+
+#define BIT_SIGNALED	4	
+#define BIT_SIG_PENDING	5
+#define BIT_P_STOP	6
+#define BIT_NO_PRIV	7
+
+#define BIT_NO_PRIORITY 8
+#define BIT_NO_ENDPOINT 9
+#define BIT_ONCOPY	10
+#define BIT_MIGRATE	11
+
+#define BIT_REMOTE	12
+#define BIT_RMTOPER	13		
+
+#define BIT_WAITMIGR	15
+		
+#define BIT_DONATING	16
+
+enum proc_status {
+		SLOT_FREE	= (1<<BIT_SLOT_FREE),	/* process slot is free 				*/
+		NO_MAP		= (1<<BIT_NO_MAP),		/* keeps unmapped forked child from running 	*/
+		SENDING		= (1<<BIT_SENDING),		/* process blocked trying to send 			*/
+		RECEIVING	= (1<<BIT_RECEIVING), 	/* process blocked trying to receive 		*/
+		
+		SIGNALED	= (1<<BIT_SIGNALED),	/* set when new kernel signal arrives 		*/
+		SIG_PENDING	= (1<<BIT_SIG_PENDING),	/* unready while signal being processed 	*/
+		P_STOP		= (1<<BIT_P_STOP),		/* set when process is being traced 		*/
+		NO_PRIV		= (1<<BIT_NO_PRIV),		/* keep forked system process from running 	*/
+		
+		NO_PRIORITY	= (1<<BIT_NO_PRIORITY),	/* process has been stopped 			*/
+		NO_ENDPOINT = (1<<BIT_NO_ENDPOINT),	/* process cannot send or receive messages 	*/
+		ONCOPY	    = (1<<BIT_ONCOPY), 		/* A copy request is pending				*/
+		MIGRATING   = (1<<BIT_MIGRATE),		/* the process is waiting that a process ends its MIGRATION */
+		
+		REMOTE	    = (1<<BIT_REMOTE),		/* the process is running on a remote host	*/
+		RMTOPER		= (1<<BIT_RMTOPER),	/*  a process descriptor is just used for a remote operation until the Sender PROXY completes the request */
+		WAITMIGR	= (1<<BIT_WAITMIGR),	/*  a destination process is MIGRATING, the sender must be blocked and enqueued into the mig a REMOTE process descriptor is just used for a remote operation until the Sender PROXY completes the request */
+		DONATING     = (1<<BIT_DONATING),	/* the process descriptor is reserved to be donated to other node */
+};
+
+/* Bits for the p_misc_flags  */
+#define GENERIC_PROC	0
+
+#endif /* PROC_STS_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/proc_usr.h /usr/src/linux/include/minix/proc_usr.h
--- /home/jara/linux-2.6.32/include/minix/proc_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/proc_usr.h	2014-04-20 11:04:05.000000000 -0300
@@ -0,0 +1,51 @@
+#ifndef PROC_USR_H
+#define PROC_USR_H
+
+#define MAXPROCNAME	16
+#define PRIV_KERNEL	0
+#define PRIV_SYSTEM	1
+#define PRIV_SYSTEM	1
+
+/* =================================*/
+/* PROCESS DESCRIPTOR	             */
+/* =================================*/
+struct proc_usr {
+
+  int p_nr;				/* process number				*/
+  int p_endpoint;			/* process endpoint				*/
+  int p_vmid;				/* process VMID					*/
+  volatile unsigned long p_rts_flags;	/* process is runnable only if zero 		*/
+  int p_lpid;				/* local LINUX PID 				*/
+  int p_nodeid;				/* Node ID where the process PRIMARY replica is running  */
+  unsigned long p_nodemap;		/* bitmap of nodes where replicas of this process exists UNTIL 32 NODES!!! */
+//  node_map_t p_nodemap;		/* bitmap of nodes where replicas of this process exists */
+
+volatile unsigned long  p_misc_flags;	/* miselaneous flags				*/
+
+  int p_getfrom;			/* from whom does process want to receive?	*/
+  int p_sendto;				/* to whom does process want to send? 		*/
+  int p_waitmigr;			/* waiting the migration of a process 		*/
+  int p_proxy;				/* the descriptor is enqueued on a proxy 	*/
+
+  unsigned long p_lclsent; 		/* counter of LOCAL messages sent	*/
+  unsigned long p_rmtsent; 		/* counter of REMOTE messages sent	*/ 
+
+  char p_name[MAXPROCNAME]; 	
+
+#ifdef MOL_USERSPACE
+	cpu_set_t p_cpumask;
+#else
+	cpumask_t p_cpumask;
+#endif 
+  
+};
+typedef struct proc_usr proc_usr_t;
+
+#define PROC_USR_FORMAT "nr=%d endp=%d vmid=%d flags=%lX misc=%lX lpid=%d nodeid=%d nodemap=%lX name=%s \n"
+#define PROC_USR_FIELDS(p) p->p_nr,p->p_endpoint, p->p_vmid, p->p_rts_flags, p->p_misc_flags, \
+			 p->p_lpid, p->p_nodeid, p->p_nodemap, p->p_name
+
+#define PROC_CPU_FORMAT "nr=%d endp=%d vmid=%d lpid=%d p_cpumask=%lX name=%s \n"
+#define PROC_CPU_FIELDS(p) p->p_nr,p->p_endpoint, p->p_vmid, p->p_lpid, p->p_cpumask.bits[0], p->p_name
+			 
+#endif /* PROC_USR_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/proxy.h /usr/src/linux/include/minix/proxy.h
--- /home/jara/linux-2.6.32/include/minix/proxy.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/proxy.h	2013-10-08 15:43:00.000000000 -0300
@@ -0,0 +1,21 @@
+
+
+
+struct proxies_s {
+	proxies_usr_t	px_usr;		
+	struct proc 	px_sproxy;	/* sender proxy 			*/
+	struct proc 	px_rproxy;	/* receiver proxy 			*/
+#if LOCK_PROXY_TYPE == USE_PROXY_RWLOCK
+	rwlock_t   	px_rwlock;	/* LINUX spinlock to protect this PAIR OF PROXIES */	
+#else	/* USE_PROC_MUTEX*/
+	struct mutex 	px_mutex;	/* LINUX mutex to protect this PAIR OF PROXIES	*/	
+#endif
+};
+typedef struct proxies_s proxies_t;
+
+
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/include/minix/proxy_sts.h /usr/src/linux/include/minix/proxy_sts.h
--- /home/jara/linux-2.6.32/include/minix/proxy_sts.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/proxy_sts.h	2013-10-19 01:11:14.000000000 -0300
@@ -0,0 +1,32 @@
+
+#define MIS_BIT_PROXY		0
+#define MIS_BIT_CONNECTED	1
+#define MIS_BIT_NOTIFY		2
+#define MIS_BIT_NEEDMIGR	3
+#define MIS_BIT_RMTBACKUP	4
+#define MIS_BIT_GRPLEADER	5
+
+
+enum mis_status {
+		MIS_PROXY	= (1<<MIS_BIT_PROXY),	/* the process is a proxy 			*/
+		MIS_CONNECTED	= (1<<MIS_BIT_CONNECTED),	/* The proxy is connected 	*/
+		MIS_NOTIFY	= (1<<MIS_BIT_NOTIFY),	/* A notify is pending 	 			*/
+		MIS_NEEDMIG	= (1<<MIS_BIT_NEEDMIGR), /* The proccess need to migrate		*/
+		MIS_RMTBACKUP	= (1<<MIS_BIT_RMTBACKUP), /* The proccess is a remote process' backup 	*/
+		MIS_GRPLEADER	= (1<<MIS_BIT_GRPLEADER), /* The proccess is the thread group leader 	*/	
+};
+
+#define PX_BIT_INUSE		0
+#define PX_BIT_SCONNECTED	1
+#define PX_BIT_RCONNECTED	2
+
+#define PROXIES_FREE		0x0000
+enum px_status {
+		PROXIES_INUSE	= (1<<PX_BIT_INUSE),		/* the proxy pair is in use 		*/
+		PROXIES_SCONNECTED= (1<<PX_BIT_SCONNECTED),	
+		PROXIES_RCONNECTED= (1<<PX_BIT_RCONNECTED),	
+};
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/include/minix/proxy_usr.h /usr/src/linux/include/minix/proxy_usr.h
--- /home/jara/linux-2.6.32/include/minix/proxy_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/proxy_usr.h	2013-10-03 17:19:00.000000000 -0300
@@ -0,0 +1,48 @@
+#define MAXPROXYNAME	16
+
+#define	CONNECT_SPROXY		1
+#define	CONNECT_RPROXY		2
+#define	DISCONNECT_SPROXY	3
+#define	DISCONNECT_RPROXY	4
+
+#define PROXY_NO_VM				(-1)	/* The proxy has not a VM		*/
+
+#define	proxy_hdr_t	cmd_t 
+
+#define ETHERNET_MTU	1500
+#define IPV4_HEADER		20
+#define UPD_HEADER		8
+#define PROXY_HEADER	(sizeof(proxy_hdr_t)+sizeof(int))
+#define MAXMTUSIZE	(ETHERNET_MTU - (IPV4_HEADER+UPD_HEADER) )
+#define MAXBUFSIZE	(ETHERNET_MTU - (IPV4_HEADER+UPD_HEADER+PROXY_HEADER) ) 
+
+#define PROXY_NO_REPLY 		0
+#define PROXY_REPLY		1
+
+#define BIT_ACKNOWLEDGE		13
+#define CMD_ACKNOWLEDGE 	(1<<BIT_ACKNOWLEDGE)
+
+#define HELLO_PERIOD		(30*1000)	/* 30 Seconds */
+
+#define	NO_PROXIES		(-1)
+
+
+typedef union {
+	message pay_msg;		/* Minix message		*/
+	char 	pay_data[MAXCOPYBUF];	/* buffer space to copy data	*/  
+} proxy_payload_t;
+
+#define TIME_FORMAT "TIMESTAMP sec=%ld nsec=%ld\n"
+#define TIME_FIELDS(p) p->tv_sec, p->tv_nsec
+
+struct proxies_usr_s {
+	unsigned int	px_id; 		/* The number of pair of proxies	*/
+unsigned long int	px_flags; 	/* The status of the pair of proxies 	*/
+	char		px_name[MAXPROXYNAME];
+
+};
+typedef struct proxies_usr_s proxies_usr_t;
+
+#define PX_USR_FORMAT 		"px_id=%d px_flags=%d px_name=%s\n" 
+#define PX_USR_FIELDS(p) 	p->px_id, p->px_flags, p->px_name
+
diff -Naur /home/jara/linux-2.6.32/include/minix/resource.h /usr/src/linux/include/minix/resource.h
--- /home/jara/linux-2.6.32/include/minix/resource.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/resource.h	2013-05-24 15:25:00.000000000 -0300
@@ -0,0 +1,5 @@
+#define PRIO_SYSTASK	-19
+#define PRIO_PROXY	-19
+#define PRIO_TASK	-15
+#define PRIO_SERVER	-10
+#define PRIO_USERPROC	 0
diff -Naur /home/jara/linux-2.6.32/include/minix/signal.h /usr/src/linux/include/minix/signal.h
--- /home/jara/linux-2.6.32/include/minix/signal.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/signal.h	2014-05-02 18:17:18.000000000 -0300
@@ -0,0 +1,10 @@
+/* MINIX specific signals. These signals are not used by user proceses, 
+ * but meant to inform system processes, like the PM, about system events.
+ */
+ 
+typedef unsigned long mnxsigset_t;
+typedef  mnxsigset_t molsigset_t;
+
+#define SIGKMESS   	  29	/* new kernel message */
+#define SIGKSIG    	  30	/* kernel signal pending */
+#define SIGKSTOP      31	/* kernel shutting down */
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/include/minix/slots.h /usr/src/linux/include/minix/slots.h
--- /home/jara/linux-2.6.32/include/minix/slots.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/slots.h	2014-08-16 10:16:36.000000000 -0300
@@ -0,0 +1,17 @@
+/* =================================*/
+/* SLOT STATUS DESCRIPTOR	             */
+/* =================================*/
+#ifndef SLOTS_H
+#define SLOTS_H
+
+struct slot_s {
+  int s_endpoint;			/* process endpoint					*/
+  int s_owner;				/* Node ID where the process is running 	*/
+  char s_name[MAXPROCNAME]; 	
+};
+typedef struct slot_s slot_t;
+
+#define SLOTS_FORMAT "s_endpoint=%d s_owner=%d s_name=%s\n"
+#define SLOTS_FIELDS(p) p->s_endpoint,p->s_owner, p->s_name
+
+#endif /* SLOTS_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/sys_config.h /usr/src/linux/include/minix/sys_config.h
--- /home/jara/linux-2.6.32/include/minix/sys_config.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/sys_config.h	2013-08-14 10:07:00.000000000 -0300
@@ -0,0 +1,78 @@
+
+#ifndef _MINIX_SYS_CONFIG_H
+#define _MINIX_SYS_CONFIG_H 1
+
+/*===========================================================================*
+ *		This section contains user-settable parameters		     *
+ *===========================================================================*/
+#define _MINIX_MACHINE       _MACHINE_IBM_PC
+#define	_WORD_SIZE 			4
+
+#define _MACHINE_IBM_PC             1	/* any  8088 or 80x86-based system */
+#define _MACHINE_SUN_4             40	/* any Sun SPARC-based system */
+#define _MACHINE_SUN_4_60	   40	/* Sun-4/60 (aka SparcStation 1 or Campus) */
+#define _MACHINE_ATARI             60	/* ATARI ST/STe/TT (68000/68030) */
+#define _MACHINE_MACINTOSH         62	/* Apple Macintosh (68000) */
+
+#define _NR_FIXED_TASKS 3
+#define _NR_NODES 	32
+#define _NR_SYSTASKS	(2*_NR_NODES)			/* 2 Threads por SYSTASK (64) */
+#define _NR_TASKS	(_NR_FIXED_TASKS+_NR_SYSTASKS)	/* HARDWARE, CLOCK, IDLE + 32xSYSTASKS (64+3) */
+#define _NR_SERVERS	(32-_NR_FIXED_TASKS)		/* (32-3) = 29*/
+#define _NR_SYS_PROCS	(_NR_SERVERS+_NR_TASKS)   	/* 64+3+32-3 = 64+32 = 96 */
+#define _NR_USR_PROCS   (256-_NR_SYS_PROCS)		/* (256-96) = 160 */
+#define _NR_PROCS	(_NR_SERVERS+_NR_USR_PROCS) 	/* 29 +  160 =  189 => (NR_PROCS+NR_TASKS) = (189+ 64+3) = 256 !!!! */
+
+#define _NR_HOLES (2*_NR_PROCS+4)  /* No. of memory holes maintained by PM */
+#define _NR_VMS	     32
+
+/* Set the CHIP type based on the machine selected. The symbol CHIP is actually
+ * indicative of more than just the CPU.  For example, machines for which
+ * CHIP == INTEL are expected to have 8259A interrrupt controllers and the
+ * other properties of IBM PC/XT/AT/386 types machines in general. */
+#define _CHIP_INTEL             1	/* CHIP type for PC, XT, AT, 386 and clones */
+#define _CHIP_M68000            2	/* CHIP type for Atari, Amiga, Macintosh    */
+#define _CHIP_SPARC             3	/* CHIP type for SUN-4 (e.g. SPARCstation)  */
+
+/* Set the FP_FORMAT type based on the machine selected, either hw or sw    */
+#define _FP_NONE		  0	/* no floating point support                */
+#define _FP_IEEE		  1	/* conform IEEE floating point standard     */
+
+#if (_MINIX_MACHINE == _MACHINE_IBM_PC)
+#define _MINIX_CHIP          _CHIP_INTEL
+#endif
+
+#if (_MINIX_MACHINE == _MACHINE_ATARI) || (_MINIX_MACHINE == _MACHINE_MACINTOSH)
+#define _MINIX_CHIP         _CHIP_M68000
+#endif
+
+#if (_MINIX_MACHINE == _MACHINE_SUN_4) || (_MINIX_MACHINE == _MACHINE_SUN_4_60)
+#define _MINIX_CHIP          _CHIP_SPARC
+#define _MINIX_FP_FORMAT   _FP_IEEE
+#endif
+
+#if (_MINIX_MACHINE == _MACHINE_ATARI) || (_MINIX_MACHINE == _MACHINE_SUN_4)
+#define _ASKDEV            1	/* ask for boot device */
+#define _FASTLOAD          1	/* use multiple block transfers to init ram */
+#endif
+
+#ifndef _MINIX_FP_FORMAT
+#define _MINIX_FP_FORMAT   _FP_NONE
+#endif
+
+#ifndef _MINIX_MACHINE
+error "In <minix/sys_config.h> please define _MINIX_MACHINE"
+#endif
+
+#ifndef _MINIX_CHIP
+error "In <minix/sys_config.h> please define _MINIX_MACHINE to have a legal value"
+#endif
+
+#if (_MINIX_MACHINE == 0)
+error "_MINIX_MACHINE has incorrect value (0)"
+#endif
+
+/* Kernel debug checks */
+#define DEBUG_LOCK_CHECK 0	/* Interrupt Lock/unlock sanity checking. */
+
+#endif /* _MINIX_SYS_CONFIG_H */
diff -Naur /home/jara/linux-2.6.32/include/minix/syslib.h /usr/src/linux/include/minix/syslib.h
--- /home/jara/linux-2.6.32/include/minix/syslib.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/syslib.h	2013-09-03 10:24:00.000000000 -0300
@@ -0,0 +1,46 @@
+/* Prototypes for system library functions. */
+
+#ifndef _SYSLIB_H
+#define _SYSLIB_H
+
+#define SYSTASK SYSTEM
+
+/*==========================================================================* 
+ * Minix system library. 						    *
+ *==========================================================================*/ 
+int _taskcall(int who, int syscallnr, message *msgptr);
+int sys_fork(int child_lpid);
+int sys_exit(int proc);
+int sys_privctl(int endpoint, int priv_type);
+int sys_getinfo(int request, void *ptr, int len, void *ptr2, int len2);
+int sys_bindproc(int sysproc_nr, int lpid);
+int sys_rfork(int endpoint, int nodeid, char *name);
+int sys_times(int proc_nr, molclock_t *ptr);
+int sys_setalarm(molclock_t exp_time, int abs_time);
+int sys_vircopy(int src_proc, void *src_vir, int dst_proc, void *dst_vir, int bytes);
+int sys_getuptime(molclock_t *ticks);
+int sys_memset(unsigned long pattern, char *base, int bytes);
+		
+/* Shorthands for sys_getinfo() system call. */
+#define sys_getkinfo(dst)	sys_getinfo(GET_KINFO, dst, 0,0,0)
+#define sys_getproctab(dst)	sys_getinfo(GET_PROCTAB, dst, 0,0,0)
+#define sys_getprivtab(dst)	sys_getinfo(GET_PRIVTAB, dst, 0,0,0)
+#define sys_getmachine(dst)	sys_getinfo(GET_MACHINE, dst, 0,0,0)
+
+#define sys_getkmessages(dst)	sys_getinfo(GET_KMESSAGES, dst, 0,0,0)
+#define sys_getkinfo(dst)	sys_getinfo(GET_KINFO, dst, 0,0,0)
+#define sys_getloadinfo(dst)	sys_getinfo(GET_LOADINFO, dst, 0,0,0)
+#define sys_getproc(dst,nr)	sys_getinfo(GET_PROC, dst, 0,0, nr)
+#define sys_getrandomness(dst)	sys_getinfo(GET_RANDOMNESS, dst, 0,0,0)
+#define sys_getimage(dst)	sys_getinfo(GET_IMAGE, dst, 0,0,0)
+#define sys_getirqhooks(dst)	sys_getinfo(GET_IRQHOOKS, dst, 0,0,0)
+#define sys_getirqactids(dst)	sys_getinfo(GET_IRQACTIDS, dst, 0,0,0)
+#define sys_getmonparams(v,vl)	sys_getinfo(GET_MONPARAMS, v,vl, 0,0)
+#define sys_getschedinfo(v1,v2)	sys_getinfo(GET_SCHEDINFO, v1,0, v2,0)
+#define sys_getlocktimings(dst)	sys_getinfo(GET_LOCKTIMING, dst, 0,0,0)
+#define sys_getbiosbuffer(virp, sizep) sys_getinfo(GET_BIOSBUFFER, virp, \
+	sizeof(*virp), sizep, sizeof(*sizep))
+
+#endif /* _SYSLIB_H */
+
+
diff -Naur /home/jara/linux-2.6.32/include/minix/timers.h /usr/src/linux/include/minix/timers.h
--- /home/jara/linux-2.6.32/include/minix/timers.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/timers.h	2013-08-20 15:46:00.000000000 -0300
@@ -0,0 +1,53 @@
+/* This library provides generic watchdog timer management functionality.
+ * The functions operate on a timer queue provided by the caller. Note that
+ * the timers must use absolute time to allow sorting. The library provides:
+ *
+ *    tmrs_settimer:     (re)set a new watchdog timer in the timers queue 
+ *    tmrs_clrtimer:     remove a timer from both the timers queue 
+ *    tmrs_exptimers:    check for expired timers and run watchdog functions
+ *
+ * Author:
+ *    Jorrit N. Herder <jnherder@cs.vu.nl>
+ *    Adapted from tmr_settimer and tmr_clrtimer in src/kernel/clock.c. 
+ *    Last modified: September 30, 2004.
+ */
+
+#ifndef _TIMERS_H
+#define _TIMERS_H
+
+typedef unsigned long molclock_t;	
+
+struct moltimer;
+typedef void (*tmr_func_t)(struct moltimer *tp);
+typedef union { int ta_int; long ta_long; void *ta_ptr; } tmr_arg_t;
+
+/* A timer_t variable must be declare for each distinct timer to be used.
+ * The timers watchdog function and expiration time are automatically set
+ * by the library function tmrs_settimer, but its argument is not.
+ */
+typedef struct moltimer
+{
+  struct moltimer	*tmr_next;	/* next in a timer chain */
+  molclock_t 	tmr_exp_time;	/* expiration time */
+  tmr_func_t	tmr_func;	/* function to call when expired */
+  tmr_arg_t	tmr_arg;	/* random argument */
+} moltimer_t;
+
+/* Used when the timer is not active. */
+#define TMR_NEVER    ((molclock_t) -1 < 0) ? ((molclock_t) MOL_MOL_LONG_MAX) : ((molclock_t) -1)
+#undef TMR_NEVER
+#define TMR_NEVER	((molclock_t) MOL_LONG_MAX)
+
+/* These definitions can be used to set or get data from a timer variable. */ 
+#define tmr_arg(tp) (&(tp)->tmr_arg)
+#define tmr_exp_time(tp) (&(tp)->tmr_exp_time)
+
+/* Timers should be initialized once before they are being used. Be careful
+ * not to reinitialize a timer that is in a list of timers, or the chain
+ * will be broken.
+ */
+#define tmr_inittimer(tp) (void)((tp)->tmr_exp_time = TMR_NEVER, \
+	(tp)->tmr_next = NULL)
+
+#endif /* _TIMERS_H */
+
diff -Naur /home/jara/linux-2.6.32/include/minix/types.h /usr/src/linux/include/minix/types.h
--- /home/jara/linux-2.6.32/include/minix/types.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/types.h	2013-08-20 15:46:00.000000000 -0300
@@ -0,0 +1,91 @@
+#define CHAR_BIT           8		/* # bits in a char */
+#define TIMEOUT_MS		60000	/* IPC Timeout in Miliseconds */
+
+typedef unsigned long irq_id_t;	
+typedef short sys_id_t;			/* system process index */
+typedef unsigned short bitchunk_t; /* collection of bits in a bitmap */
+typedef unsigned long ksigset_t;
+
+#define BITCHUNK_BITS   (sizeof(bitchunk_t) * CHAR_BIT)
+#define BITMAP_CHUNKS(nr_bits) (((nr_bits)+BITCHUNK_BITS-1)/BITCHUNK_BITS)
+
+typedef struct {			/* bitmap for system indexes */
+  bitchunk_t chunk[BITMAP_CHUNKS(NR_SYS_PROCS)];
+} sys_map_t;
+
+typedef struct {			/* bitmap for VM indexes */
+  bitchunk_t chunk[BITMAP_CHUNKS(NR_VMS)];
+} vm_map_t;
+
+typedef struct {			/* bitmap for NODES indexes */
+  bitchunk_t chunk[BITMAP_CHUNKS(NR_NODES)];
+} node_map_t;
+
+
+/* Signal handler type, e.g. SIG_IGN */
+typedef void (*sighandler_t)(int);
+
+/* Types used in disk, inode, etc. data structures. */
+typedef short          mnx_dev_t;	   /* holds (major|minor) device pair */
+typedef char           mnx_gid_t;	   /* group id */
+typedef unsigned long  mnx_ino_t; 	   /* i-node number (V3 filesystem) */
+typedef unsigned short mnx_mode_t;	   /* file type and permissions bits */
+typedef short          mnx_nlink_t;	   /* number of links to a file */
+typedef unsigned long  mnx_off_t;	   /* offset within a file */
+typedef int            mnx_pid_t;	   /* process id (must be signed) */
+typedef short          mnx_uid_t;	   /* user id */
+typedef unsigned long  mnx_zone_t;	   /* zone number */
+typedef unsigned long  mnx_block_t;	   /* block number */
+typedef unsigned long  mnx_bit_t;	   /* bit number in a bit map */
+typedef unsigned short mnx_zone1_t;	   /* zone number for V1 file systems */
+typedef unsigned short mnx_bitchunk_t; /* collection of bits in a bitmap */
+
+typedef unsigned char   u8_t;	   /* 8 bit type */
+typedef unsigned short u16_t;	   /* 16 bit type */
+typedef unsigned long  u32_t;	   /* 32 bit type */
+
+typedef char            i8_t;      /* 8 bit signed type */
+typedef short          i16_t;      /* 16 bit signed type */
+typedef long           i32_t;      /* 32 bit signed type */
+
+typedef struct { u32_t _[2]; } u64_t;
+
+typedef unsigned long  Ino_t;
+
+#define  _EM_WSIZE  4
+
+#if _EM_WSIZE == 2
+/*typedef unsigned int      Ino_t; Ino_t is now 32 bits */
+typedef unsigned int    Zone1_t;
+typedef unsigned int Bitchunk_t;
+typedef unsigned int      U16_t;
+typedef unsigned int  _mnx_Mode_t;
+
+
+#else /* _EM_WSIZE == 4, or _EM_WSIZE undefined */
+/*typedef int	          Ino_t; Ino_t is now 32 bits */
+typedef int 	        Zone1_t;
+typedef int	     Bitchunk_t;
+typedef int	          U16_t;
+typedef int         _mnx_Mode_t;
+
+#endif /* _EM_WSIZE == 2, etc */
+
+typedef int            Dev_t;
+
+/* Devices. */   
+#define MNX_MAJOR              8    /* major device = (dev>>MAJOR) & 0377 */
+#define MNX_MINOR              0    /* minor device = (dev>>MINOR) & 0377 */
+
+#ifndef minor
+#define minor(dev)      (((dev) >> MNX_MINOR) & 0xff)
+#endif
+
+#ifndef major
+#define major(dev)      (((dev) >> MNX_MAJOR) & 0xff)
+#endif
+
+#ifndef makedev
+#define makedev(major, minor)   \
+                        ((dev_t) (((major) << MNX_MAJOR) | ((minor) << MNX_MINOR)))
+#endif
diff -Naur /home/jara/linux-2.6.32/include/minix/vmu.h /usr/src/linux/include/minix/vmu.h
--- /home/jara/linux-2.6.32/include/minix/vmu.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/vmu.h	2013-01-02 08:31:00.000000000 -0300
@@ -0,0 +1,11 @@
+#define MAXVMNAME	16
+
+struct VM_user {
+	int		vm_vmid;
+	int		vm_flags;
+	int 	vm_nr_procs;
+	int 	vm_nr_tasks;
+	int 	vm_nr_sysprocs;
+	char	vm_name[MAXVMNAME];
+};
+typedef struct VM_user VM_user_t;
diff -Naur /home/jara/linux-2.6.32/include/minix/vm_usr.h /usr/src/linux/include/minix/vm_usr.h
--- /home/jara/linux-2.6.32/include/minix/vm_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/include/minix/vm_usr.h	2014-03-23 10:27:41.000000000 -0300
@@ -0,0 +1,33 @@
+#ifndef VM_USR_H
+#define VM_USR_H
+
+#define MAXVMNAME	16
+
+struct VM_usr {
+	int	vm_vmid;
+	int	vm_flags;
+	int 	vm_nr_procs;
+	int 	vm_nr_tasks;
+	int 	vm_nr_sysprocs;
+	int 	vm_nr_nodes;
+	unsigned long int vm_nodes; 		
+	char	vm_name[MAXVMNAME];
+#ifdef MOL_USERSPACE
+	cpu_set_t vm_cpumask;
+#else
+	cpumask_t vm_cpumask;
+#endif 
+};
+typedef struct VM_usr VM_usr_t;
+
+#define VM_USR_FORMAT "vm_vmid=%d vm_nr_procs=%d vm_nr_tasks=%d vm_nr_sysprocs=%d vm_nr_nodes=%d flags=%X vm_nodes=%X vm_name=%s\n"
+#define VM_USR_FIELDS(p) p->vm_vmid,p->vm_nr_procs, p->vm_nr_tasks, p->vm_nr_sysprocs, p->vm_nr_nodes,p->vm_flags, p->vm_nodes, p->vm_name
+
+//http://lxr.free-electrons.com/source/include/linux/types.h#L9
+// #define DECLARE_BITMAP(name,bits)    unsigned long name[BITS_TO_LONGS(bits)]
+//http://lxr.free-electrons.com/source/include/linux/cpumask.h
+// typedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS); } cpumask_t; 
+#define VM_CPU_FORMAT "vm_vmid=%d vm_cpumask=%X vm_name=%s \n"
+#define VM_CPU_FIELDS(p) p->vm_vmid,  (unsigned int) p->vm_cpumask.bits[0], p->vm_name
+
+#endif /* VM_USR_H */
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/init/main.c /usr/src/linux/init/main.c
--- /home/jara/linux-2.6.32/init/main.c	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/init/main.c	2013-09-07 08:50:40.000000000 -0300
@@ -71,6 +71,7 @@
 #include <linux/shmem_fs.h>
 #include <trace/boot.h>
 
+
 #include <asm/io.h>
 #include <asm/bugs.h>
 #include <asm/setup.h>
@@ -81,6 +82,9 @@
 #include <asm/smp.h>
 #endif
 
+#include "../kernel/minix/drvs_usr.h"
+#include "../kernel/minix/const.h"
+
 static int kernel_init(void *);
 
 extern void init_IRQ(void);
@@ -90,6 +94,10 @@
 extern void prio_tree_init(void);
 extern void radix_tree_init(void);
 extern void free_initmem(void);
+
+extern asmlinkage long mol_drvs_init(int nodeid, drvs_usr_t *drvs_addr);
+unsigned int drvs_nodeid = DRVS_NO_INIT;
+
 #ifndef CONFIG_DEBUG_RODATA
 static inline void mark_rodata_ro(void) { }
 #endif
@@ -111,6 +119,7 @@
 /* Default late time init is NULL. archs can override this later. */
 void (*__initdata late_time_init)(void);
 extern void softirq_init(void);
+static int __init do_early_param(char *param, char *val);
 
 /* Untouched command line saved by arch-specific code. */
 char __initdata boot_command_line[COMMAND_LINE_SIZE];
@@ -338,6 +347,14 @@
 }
 __setup("rdinit=", rdinit_setup);
 
+static int __init nodeid_setup(char *str)
+{
+    get_option(&str, &drvs_nodeid);
+    return 1;
+}
+__setup("nodeid=", nodeid_setup);
+
+
 #ifndef CONFIG_SMP
 
 #ifdef CONFIG_X86_LOCAL_APIC
@@ -418,6 +435,9 @@
 {
 	int pid;
 
+	if( drvs_nodeid >= 0)
+		mol_drvs_init(drvs_nodeid, NULL);
+
 	rcu_scheduler_starting();
 	kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
 	numa_default_policy();
@@ -683,6 +703,7 @@
 
 	ftrace_init();
 
+
 	/* Do the rest non-__init'ed, we're now alive */
 	rest_init();
 }
diff -Naur /home/jara/linux-2.6.32/ipc/msg.c /usr/src/linux/ipc/msg.c
--- /home/jara/linux-2.6.32/ipc/msg.c	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/ipc/msg.c	2012-09-09 01:46:14.000000000 -0300
@@ -68,10 +68,12 @@
 #define SEARCH_NOTEQUAL		3
 #define SEARCH_LESSEQUAL	4
 
+
 #define msg_ids(ns)	((ns)->ids[IPC_MSG_IDS])
 
 #define msg_unlock(msq)		ipc_unlock(&(msq)->q_perm)
 
+	
 static void freeque(struct ipc_namespace *, struct kern_ipc_perm *);
 static int newque(struct ipc_namespace *, struct ipc_params *);
 #ifdef CONFIG_PROC_FS
diff -Naur /home/jara/linux-2.6.32/ipc/msgutil.c /usr/src/linux/ipc/msgutil.c
--- /home/jara/linux-2.6.32/ipc/msgutil.c	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/ipc/msgutil.c	2012-09-09 01:46:39.000000000 -0300
@@ -103,6 +103,7 @@
 	return ERR_PTR(err);
 }
 
+
 int store_msg(void __user *dest, struct msg_msg *msg, int len)
 {
 	int alen;
@@ -130,6 +131,8 @@
 	return 0;
 }
 
+
+
 void free_msg(struct msg_msg *msg)
 {
 	struct msg_msgseg *seg;
diff -Naur /home/jara/linux-2.6.32/kernel/error.txt /usr/src/linux/kernel/error.txt
--- /home/jara/linux-2.6.32/kernel/error.txt	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/error.txt	2013-01-13 18:53:23.000000000 -0300
@@ -0,0 +1,53 @@
+make[1]: Warning: File `kernel/exit.c' has modification time 1.1e+04 s in the future
+kernel/mol-hyper.c: In function do_vm_end:
+kernel/mol-hyper.c:566: warning: unused variable p
+kernel/mol-hyper.c:562: warning: unused variable tmp_ptr
+kernel/mol-hyper.c:562: warning: unused variable xcp
+kernel/mol-hyper.c: In function do_unbind:
+kernel/mol-hyper.c:755: warning: suggest explicit braces to avoid ambiguous else
+kernel/mol-hyper.c:725: warning: unused variable caller_ep
+kernel/mol-hyper.c:725: warning: unused variable caller_nr
+kernel/mol-hyper.c:724: warning: unused variable tmp_ep
+kernel/mol-hyper.c:724: warning: unused variable ret
+kernel/mol-hyper.c:723: warning: unused variable t_ptr
+kernel/mol-hyper.c:723: warning: unused variable xcp
+kernel/mol-hyper.c:723: warning: unused variable cmd_ptr
+kernel/mol-hyper.c:721: warning: unused variable xpp
+kernel/mol-hyper.c:758: warning: dst_ptr may be used uninitialized in this function
+kernel/mol-hyper.c:781: warning: vmid may be used uninitialized in this function
+kernel/mol-ipc.c: In function mol_mini_receive:
+kernel/mol-ipc.c:187: warning: unused variable tmp_ep
+kernel/mol-ipc.c: In function mol_mini_notify:
+kernel/mol-ipc.c:514: warning: dst_nr is used uninitialized in this function
+kernel/mol-ipc.c: In function mol_mini_send:
+kernel/mol-ipc.c:56: warning: dst_nr is used uninitialized in this function
+kernel/mol-ipc.c: In function mol_mini_sendrec:
+kernel/mol-ipc.c:376: warning: srcdst_nr is used uninitialized in this function
+kernel/mol-ipc.c: In function mol_mini_send:
+kernel/mol-ipc.c:84: warning: caller_nr may be used uninitialized in this function
+kernel/mol-ipc.c:84: warning: caller_ep may be used uninitialized in this function
+kernel/mol-ipc.c: In function mol_mini_sendrec:
+kernel/mol-ipc.c:403: warning: caller_nr may be used uninitialized in this function
+kernel/mol-ipc.c:403: warning: caller_ep may be used uninitialized in this function
+kernel/mol-ipc.c: In function mol_mini_receive:
+kernel/mol-ipc.c:181: warning: src_ptr may be used uninitialized in this function
+kernel/mol-utils.c: In function send_remote:
+kernel/mol-utils.c:171: warning: unused variable tmp_ptr
+kernel/mol-utils.c:171: warning: unused variable xpp
+kernel/mol-proxy.c: In function send_to_local:
+kernel/mol-proxy.c:45: warning: unused variable cmd_ptr
+kernel/mol-proxy.c: In function notify_to_local:
+kernel/mol-proxy.c:90: warning: unused variable cmd_ptr
+kernel/mol-proxy.c: In function send_ack_local:
+kernel/mol-proxy.c:138: warning: unused variable cmd_ptr
+kernel/mol-proxy.c: In function mol_get2rmt:
+kernel/mol-proxy.c:325: warning: unused variable m_ptr
+kernel/mol-proxy.c: In function send_to_local:
+kernel/mol-proxy.c:53: warning: m_ptr may be used uninitialized in this function
+kernel/mol-proxy.c: In function mol_put2lcl:
+kernel/mol-proxy.c:262: warning: cmd_ptr may be used uninitialized in this function
+make[1]: warning:  Clock skew detected.  Your build may be incomplete.
+Root device is (8, 1)
+Setup is 11740 bytes (padded to 11776 bytes).
+System is 4132 kB
+CRC 3302d7bd
diff -Naur /home/jara/linux-2.6.32/kernel/exit.c /usr/src/linux/kernel/exit.c
--- /home/jara/linux-2.6.32/kernel/exit.c	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/kernel/exit.c	2015-03-10 22:30:20.000000000 -0300
@@ -3,7 +3,6 @@
  *
  *  Copyright (C) 1991, 1992  Linus Torvalds
  */
-
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
@@ -56,6 +55,96 @@
 #include <asm/mmu_context.h>
 #include "cred-internals.h"
 
+
+/*********MOLIPC*****************/
+#include "./minix/config.h"
+#include "./minix/ipc.h"
+#include "./minix/kipc.h"
+#include "./minix/timers.h"
+#include "./minix/cmd.h"
+#include "./minix/proc.h"
+#include "./minix/proxy_sts.h"
+#include "./minix/proxy_usr.h"
+#include "./minix/proxy.h"
+#include "./minix/drvs_usr.h"
+#include "./minix/molerrno.h"
+#include "./minix/endpoint.h"
+#include "./minix/moldebug.h"
+
+#include "mol-const.h"
+#include "mol-proto.h"
+#include "mol-glo.h"
+#include "mol-macros.h"
+
+
+/*********MOLIPC*****************/
+static void exit_unbind(void)
+{
+	struct proc *caller_ptr;
+	struct proc *sproc_ptr, *rproc_ptr;
+	int rcode, px_nr;
+	proxies_t *px_ptr;
+	VM_desc_t *vm_ptr;
+
+	/*---------------------- FIRST: Verify if the process is DRVSD--------------------------------
+	*  1- Make do_drvs_end
+	--------------------------------------------------------------------------------------------------------*/
+
+	LOCK_TASK(current);
+	caller_ptr = (struct proc *) current->proc_ptr;	/* only the main thread or a binded thread could unbind */
+	UNLOCK_TASK(current);
+
+	if( caller_ptr != NULL) {
+		WLOCK_PROC(caller_ptr);
+		if(test_bit(MIS_BIT_PROXY, &caller_ptr->p_usr.p_misc_flags)) {
+			MOLDEBUG(INTERNAL," Exiting PROXY px_nr=%d lpid=%d\n", 
+				caller_ptr->p_usr.p_nr, caller_ptr->p_usr.p_lpid);
+			if( caller_ptr->p_usr.p_nr >= 0 && caller_ptr->p_usr.p_nr < drvs.d_nr_nodes) {
+				px_nr = caller_ptr->p_usr.p_nr;
+				px_ptr = &proxies[px_nr];
+				WUNLOCK_PROC(caller_ptr);
+				WLOCK_PROXY(px_ptr);
+				sproc_ptr = &px_ptr->px_sproxy;
+				rproc_ptr = &px_ptr->px_rproxy;
+				LOCK_TASK(current);
+				WLOCK_PROC(sproc_ptr);
+				WLOCK_PROC(rproc_ptr);
+				rcode = do_proxies_unbind(caller_ptr);
+				UNLOCK_TASK(current);
+				WUNLOCK_PROC(rproc_ptr);
+				WUNLOCK_PROC(sproc_ptr);
+				WUNLOCK_PROXY(px_ptr);
+			}
+		} else if ( caller_ptr->p_usr.p_vmid >= 0 &&  caller_ptr->p_usr.p_vmid < drvs.d_nr_vms) {
+			MOLDEBUG(INTERNAL," Exiting endpoint=%d lpid=%d\n", 	
+				caller_ptr->p_usr.p_endpoint, caller_ptr->p_usr.p_lpid);
+			vm_ptr = &vm[caller_ptr->p_usr.p_vmid];
+			WUNLOCK_PROC(caller_ptr);
+			WLOCK_VM(vm_ptr);
+			if(vm_ptr->vm_usr.vm_flags) {
+				printk("ERROR: %d:%s:%u: VM %d is not running but it process %d is exiting\n",
+						current->pid, __FUNCTION__ ,__LINE__,vm_ptr->vm_usr.vm_vmid, caller_ptr->p_usr.p_endpoint); 
+			}else {
+				WLOCK_PROC(caller_ptr);
+				MOLDEBUG(INTERNAL," endpoint=%d lpid=%d\n", 
+					caller_ptr->p_usr.p_endpoint, caller_ptr->p_usr.p_lpid);
+				rcode = do_unbind(vm_ptr, caller_ptr, caller_ptr->p_usr.p_nodeid);
+				if(rcode)
+					printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); 
+				WUNLOCK_PROC(caller_ptr);
+			}
+			WUNLOCK_VM(vm_ptr);
+		}else {
+			printk("WARNING: %d:%s:%u: This process seems to be binded but its descriptor is inconsistent\n", 
+				current->pid, __FUNCTION__ ,__LINE__); 
+		}
+	}
+}
+/*********MOLIPC*****************/
+
+
+
+
 static void exit_mm(struct task_struct * tsk);
 
 static void __unhash_process(struct task_struct *p)
@@ -671,7 +760,7 @@
 			complete(&core_state->startup);
 
 		for (;;) {
-			set_task_state(tsk, TASK_UNINTERRUPTIBLE);
+			set_task_state(tsk, TASK_UNINTERRUPTIBLE );
 			if (!self.task) /* see coredump_finish() */
 				break;
 			schedule();
@@ -924,6 +1013,9 @@
 		schedule();
 	}
 
+	if(!DRVS_NOT_INIT()) 
+		exit_unbind();
+
 	exit_irq_thread();
 
 	exit_signals(tsk);  /* sets PF_EXITING */
diff -Naur /home/jara/linux-2.6.32/kernel/fork.c /usr/src/linux/kernel/fork.c
--- /home/jara/linux-2.6.32/kernel/fork.c	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/kernel/fork.c	2013-09-21 10:56:00.000000000 -0300
@@ -74,6 +74,28 @@
 
 #include <trace/events/sched.h>
 
+/*********MOLAUTOFORK*****************/
+
+#include "./minix/config.h"
+#include "./minix/ipc.h"
+#include "./minix/kipc.h"
+#include "./minix/timers.h"
+#include "./minix/cmd.h"
+#include "./minix/proc.h"
+#include "./minix/proxy_sts.h"
+#include "./minix/proxy_usr.h"
+#include "./minix/proxy.h"
+#include "./minix/drvs_usr.h"
+#include "./minix/molerrno.h"
+#include "./minix/endpoint.h"
+#include "./minix/moldebug.h"
+
+#include "mol-const.h"
+#include "mol-proto.h"
+#include "mol-glo.h"
+#include "mol-macros.h"
+
+
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
@@ -980,6 +1002,9 @@
 	int retval;
 	struct task_struct *p;
 	int cgroup_callbacks_done = 0;
+#ifdef MOLAUTOFORK
+	struct proc *proc_ptr, *child_ptr;
+#endif /* MOLAUTOFORK */
 
 	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
 		return ERR_PTR(-EINVAL);
@@ -1057,6 +1082,9 @@
 	INIT_LIST_HEAD(&p->sibling);
 	rcu_copy_process(p);
 	p->vfork_done = NULL;
+
+	mutex_init(&p->proc_mutex);
+
 	spin_lock_init(&p->alloc_lock);
 
 	init_sigpending(&p->pending);
@@ -1169,6 +1197,7 @@
 	}
 
 	p->pid = pid_nr(pid);
+
 	p->tgid = p->pid;
 	if (clone_flags & CLONE_THREAD)
 		p->tgid = current->tgid;
@@ -1298,6 +1327,27 @@
 		nr_threads++;
 	}
 
+#ifdef MOLAUTOFORK
+	/************************** FALTA LOCK de proc_ptr **********************/
+	if( current->proc_ptr != NULL) {
+		proc_ptr = current->proc_ptr;
+		if( proc_ptr->p_priv.s_usr.s_warn != NONE) {
+			child_ptr = fork_bind(proc_ptr, p->tgid);
+			if( child_ptr != NULL) {
+				child_ptr->p_priv.s_usr.s_warn = proc_ptr->p_priv.s_usr.s_warn;
+				get_task_struct(p);	/* increment the reference count of the task struct */
+ 			}
+		}else{
+			child_ptr = NULL;
+		}
+		p->proc_ptr = child_ptr;
+	} else {
+		p->proc_ptr   = NULL; /* MOLAUTOFORK proc pointer */
+	}	
+#else
+	p->proc_ptr   = NULL;
+#endif /*MOLAUTOFORK */
+
 	total_forks++;
 	spin_unlock(&current->sighand->siglock);
 	write_unlock_irq(&tasklist_lock);
diff -Naur /home/jara/linux-2.6.32/kernel/Makefile /usr/src/linux/kernel/Makefile
--- /home/jara/linux-2.6.32/kernel/Makefile	2009-12-03 00:51:21.000000000 -0300
+++ /usr/src/linux/kernel/Makefile	2013-09-08 09:55:00.000000000 -0300
@@ -9,8 +9,10 @@
 	    rcupdate.o extable.o params.o posix-timers.o \
 	    kthread.o wait.o kfifo.o sys_ni.o posix-cpu-timers.o mutex.o \
 	    hrtimer.o rwsem.o nsproxy.o srcu.o semaphore.o \
-	    notifier.o ksysfs.o pm_qos_params.o sched_clock.o cred.o \
-	    async.o
+	    notifier.o ksysfs.o pm_qos_params.o sched_clock.o cred.o async.o \
+	    mol-hyper.o mol-ipc.o mol-utils.o mol-procfs.o \
+	    mol-rproxy.o mol-sproxy.o  mol-acks.o mol-migrate.o
+		
 obj-y += groups.o
 
 ifdef CONFIG_FUNCTION_TRACER
diff -Naur /home/jara/linux-2.6.32/kernel/Makefile~ /usr/src/linux/kernel/Makefile~
--- /home/jara/linux-2.6.32/kernel/Makefile~	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/Makefile~	2009-12-03 00:51:21.000000000 -0300
@@ -0,0 +1,129 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y     = sched.o fork.o exec_domain.o panic.o printk.o \
+	    cpu.o exit.o itimer.o time.o softirq.o resource.o \
+	    sysctl.o capability.o ptrace.o timer.o user.o \
+	    signal.o sys.o kmod.o workqueue.o pid.o \
+	    rcupdate.o extable.o params.o posix-timers.o \
+	    kthread.o wait.o kfifo.o sys_ni.o posix-cpu-timers.o mutex.o \
+	    hrtimer.o rwsem.o nsproxy.o srcu.o semaphore.o \
+	    notifier.o ksysfs.o pm_qos_params.o sched_clock.o cred.o \
+	    async.o
+obj-y += groups.o
+
+ifdef CONFIG_FUNCTION_TRACER
+# Do not trace debug files and internal ftrace files
+CFLAGS_REMOVE_lockdep.o = -pg
+CFLAGS_REMOVE_lockdep_proc.o = -pg
+CFLAGS_REMOVE_mutex-debug.o = -pg
+CFLAGS_REMOVE_rtmutex-debug.o = -pg
+CFLAGS_REMOVE_cgroup-debug.o = -pg
+CFLAGS_REMOVE_sched_clock.o = -pg
+endif
+
+obj-$(CONFIG_FREEZER) += freezer.o
+obj-$(CONFIG_PROFILING) += profile.o
+obj-$(CONFIG_SYSCTL_SYSCALL_CHECK) += sysctl_check.o
+obj-$(CONFIG_STACKTRACE) += stacktrace.o
+obj-y += time/
+obj-$(CONFIG_DEBUG_MUTEXES) += mutex-debug.o
+obj-$(CONFIG_LOCKDEP) += lockdep.o
+ifeq ($(CONFIG_PROC_FS),y)
+obj-$(CONFIG_LOCKDEP) += lockdep_proc.o
+endif
+obj-$(CONFIG_FUTEX) += futex.o
+ifeq ($(CONFIG_COMPAT),y)
+obj-$(CONFIG_FUTEX) += futex_compat.o
+endif
+obj-$(CONFIG_RT_MUTEXES) += rtmutex.o
+obj-$(CONFIG_DEBUG_RT_MUTEXES) += rtmutex-debug.o
+obj-$(CONFIG_RT_MUTEX_TESTER) += rtmutex-tester.o
+obj-$(CONFIG_GENERIC_ISA_DMA) += dma.o
+obj-$(CONFIG_USE_GENERIC_SMP_HELPERS) += smp.o
+ifneq ($(CONFIG_SMP),y)
+obj-y += up.o
+endif
+obj-$(CONFIG_SMP) += spinlock.o
+obj-$(CONFIG_DEBUG_SPINLOCK) += spinlock.o
+obj-$(CONFIG_PROVE_LOCKING) += spinlock.o
+obj-$(CONFIG_UID16) += uid16.o
+obj-$(CONFIG_MODULES) += module.o
+obj-$(CONFIG_KALLSYMS) += kallsyms.o
+obj-$(CONFIG_PM) += power/
+obj-$(CONFIG_FREEZER) += power/
+obj-$(CONFIG_BSD_PROCESS_ACCT) += acct.o
+obj-$(CONFIG_KEXEC) += kexec.o
+obj-$(CONFIG_BACKTRACE_SELF_TEST) += backtracetest.o
+obj-$(CONFIG_COMPAT) += compat.o
+obj-$(CONFIG_CGROUPS) += cgroup.o
+obj-$(CONFIG_CGROUP_FREEZER) += cgroup_freezer.o
+obj-$(CONFIG_CPUSETS) += cpuset.o
+obj-$(CONFIG_CGROUP_NS) += ns_cgroup.o
+obj-$(CONFIG_UTS_NS) += utsname.o
+obj-$(CONFIG_USER_NS) += user_namespace.o
+obj-$(CONFIG_PID_NS) += pid_namespace.o
+obj-$(CONFIG_IKCONFIG) += configs.o
+obj-$(CONFIG_RESOURCE_COUNTERS) += res_counter.o
+obj-$(CONFIG_STOP_MACHINE) += stop_machine.o
+obj-$(CONFIG_KPROBES_SANITY_TEST) += test_kprobes.o
+obj-$(CONFIG_AUDIT) += audit.o auditfilter.o audit_watch.o
+obj-$(CONFIG_AUDITSYSCALL) += auditsc.o
+obj-$(CONFIG_GCOV_KERNEL) += gcov/
+obj-$(CONFIG_AUDIT_TREE) += audit_tree.o
+obj-$(CONFIG_KPROBES) += kprobes.o
+obj-$(CONFIG_KGDB) += kgdb.o
+obj-$(CONFIG_DETECT_SOFTLOCKUP) += softlockup.o
+obj-$(CONFIG_DETECT_HUNG_TASK) += hung_task.o
+obj-$(CONFIG_GENERIC_HARDIRQS) += irq/
+obj-$(CONFIG_SECCOMP) += seccomp.o
+obj-$(CONFIG_RCU_TORTURE_TEST) += rcutorture.o
+obj-$(CONFIG_TREE_RCU) += rcutree.o
+obj-$(CONFIG_TREE_PREEMPT_RCU) += rcutree.o
+obj-$(CONFIG_TREE_RCU_TRACE) += rcutree_trace.o
+obj-$(CONFIG_RELAY) += relay.o
+obj-$(CONFIG_SYSCTL) += utsname_sysctl.o
+obj-$(CONFIG_TASK_DELAY_ACCT) += delayacct.o
+obj-$(CONFIG_TASKSTATS) += taskstats.o tsacct.o
+obj-$(CONFIG_TRACEPOINTS) += tracepoint.o
+obj-$(CONFIG_LATENCYTOP) += latencytop.o
+obj-$(CONFIG_FUNCTION_TRACER) += trace/
+obj-$(CONFIG_TRACING) += trace/
+obj-$(CONFIG_X86_DS) += trace/
+obj-$(CONFIG_RING_BUFFER) += trace/
+obj-$(CONFIG_SMP) += sched_cpupri.o
+obj-$(CONFIG_SLOW_WORK) += slow-work.o
+obj-$(CONFIG_SLOW_WORK_DEBUG) += slow-work-debugfs.o
+obj-$(CONFIG_PERF_EVENTS) += perf_event.o
+
+ifneq ($(CONFIG_SCHED_OMIT_FRAME_POINTER),y)
+# According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
+# needed for x86 only.  Why this used to be enabled for all architectures is beyond
+# me.  I suspect most platforms don't need this, but until we know that for sure
+# I turn this off for IA-64 only.  Andreas Schwab says it's also needed on m68k
+# to get a correct value for the wait-channel (WCHAN in ps). --davidm
+CFLAGS_sched.o := $(PROFILING) -fno-omit-frame-pointer
+endif
+
+$(obj)/configs.o: $(obj)/config_data.h
+
+# config_data.h contains the same information as ikconfig.h but gzipped.
+# Info from config_data can be extracted from /proc/config*
+targets += config_data.gz
+$(obj)/config_data.gz: .config FORCE
+	$(call if_changed,gzip)
+
+quiet_cmd_ikconfiggz = IKCFG   $@
+      cmd_ikconfiggz = (echo "static const char kernel_config_data[] __used = MAGIC_START"; cat $< | scripts/bin2c; echo "MAGIC_END;") > $@
+targets += config_data.h
+$(obj)/config_data.h: $(obj)/config_data.gz FORCE
+	$(call if_changed,ikconfiggz)
+
+$(obj)/time.o: $(obj)/timeconst.h
+
+quiet_cmd_timeconst  = TIMEC   $@
+      cmd_timeconst  = $(PERL) $< $(CONFIG_HZ) > $@
+targets += timeconst.h
+$(obj)/timeconst.h: $(src)/timeconst.pl FORCE
+	$(call if_changed,timeconst)
diff -Naur /home/jara/linux-2.6.32/kernel/minix/ansi.h /usr/src/linux/kernel/minix/ansi.h
--- /home/jara/linux-2.6.32/kernel/minix/ansi.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/ansi.h	2005-09-13 22:59:00.000000000 -0300
@@ -0,0 +1,69 @@
+/* The <ansi.h> header attempts to decide whether the compiler has enough
+ * conformance to Standard C for Minix to take advantage of.  If so, the
+ * symbol _ANSI is defined (as 31459).  Otherwise _ANSI is not defined
+ * here, but it may be defined by applications that want to bend the rules.
+ * The magic number in the definition is to inhibit unnecessary bending
+ * of the rules.  (For consistency with the new '#ifdef _ANSI" tests in
+ * the headers, _ANSI should really be defined as nothing, but that would
+ * break many library routines that use "#if _ANSI".)
+
+ * If _ANSI ends up being defined, a macro
+ *
+ *	_PROTOTYPE(function, params)
+ *
+ * is defined.  This macro expands in different ways, generating either
+ * ANSI Standard C prototypes or old-style K&R (Kernighan & Ritchie)
+ * prototypes, as needed.  Finally, some programs use _CONST, _VOIDSTAR etc
+ * in such a way that they are portable over both ANSI and K&R compilers.
+ * The appropriate macros are defined here.
+ */
+
+#ifndef _ANSI_H
+#define _ANSI_H
+
+#if __STDC__ == 1
+#define _ANSI		31459	/* compiler claims full ANSI conformance */
+#endif
+
+#ifdef __GNUC__
+#define _ANSI		31459	/* gcc conforms enough even in non-ANSI mode */
+#endif
+
+#ifdef _ANSI
+
+/* Keep everything for ANSI prototypes. */
+#define	_PROTOTYPE(function, params)	function params
+#define	_ARGS(params)			params
+
+#define	_VOIDSTAR	void *
+#define	_VOID		void
+#define	_CONST		const
+#define	_VOLATILE	volatile
+#define _SIZET		size_t
+
+#else
+
+/* Throw away the parameters for K&R prototypes. */
+#define	_PROTOTYPE(function, params)	function()
+#define	_ARGS(params)			()
+
+#define	_VOIDSTAR	void *
+#define	_VOID		void
+#define	_CONST
+#define	_VOLATILE
+#define _SIZET		int
+
+#endif /* _ANSI */
+
+/* This should be defined as restrict when a C99 compiler is used. */
+#define _RESTRICT
+
+/* Setting any of _MINIX, _POSIX_C_SOURCE or _POSIX2_SOURCE implies
+ * _POSIX_SOURCE.  (Seems wrong to put this here in ANSI space.)
+ */
+#if defined(_MINIX) || _POSIX_C_SOURCE > 0 || defined(_POSIX2_SOURCE)
+#undef _POSIX_SOURCE
+#define _POSIX_SOURCE	1
+#endif
+
+#endif /* ANSI_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/callnr.h /usr/src/linux/kernel/minix/callnr.h
--- /home/jara/linux-2.6.32/kernel/minix/callnr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/callnr.h	2013-08-06 02:18:00.000000000 -0300
@@ -0,0 +1,104 @@
+
+#ifdef MOLAUTOFORK
+#define NCALLS		  97	/* number of system calls allowed */
+#else /*MOLAUTOFORK */
+#define NCALLS		  96	/* number of system calls allowed */
+#endif /*MOLAUTOFORK */
+
+#define MOLUNUSED		0
+#define MOLEXIT		   1 
+#define MOLFORK		   2 
+#define MOLREAD		   3 
+#define MOLWRITE		   4 
+#define MOLOPEN		   5 
+#define MOLCLOSE		   6 
+#define MOLWAIT		   7
+#define MOLCREAT		   8 
+#define MOLLINK		   9 
+#define MOLUNLINK		  10 
+#define MOLWAITPID		  11
+#define MOLCHDIR		  12 
+#define MOLTIME		  13
+#define MOLMKNOD		  14 
+#define MOLCHMOD		  15 
+#define MOLCHOWN		  16 
+#define MOLBRK		  17
+#define MOLSTAT		  18 
+#define MOLLSEEK		  19
+#define MOLGETPID		  20
+#define MOLMOUNT		  21 
+#define MOLUMOUNT		  22 
+#define MOLSETUID		  23
+#define MOLGETUID		  24
+#define MOLSTIME		  25
+#define MOLPTRACE		  26
+#define MOLALARM		  27
+#define MOLFSTAT		  28 
+#define MOLPAUSE		  29
+#define MOLUTIME		  30 
+#define MOLACCESS		  33 
+#define MOLSYNC		  36 
+#define MOLKILL		  37
+#define MOLRENAME		  38
+#define MOLMKDIR		  39
+#define MOLRMDIR		  40
+#define MOLDUP		  41 
+#define MOLPIPE		  42 
+#define MOLTIMES		  43
+#define MOLSYMLINK		  45
+#define MOLSETGID		  46
+#define MOLGETGID		  47
+#define MOLSIGNAL		  48
+#define MOLRDLNK		  49
+#define MOLLSTAT		  50
+#define MOLIOCTL		  54
+#define MOLFCNTL		  55
+#define MOLEXEC		  59
+#define MOLUMASK		  60 
+#define MOLCHROOT		  61 
+#define MOLSETSID		  62
+#define MOLGETPGRP		  63
+
+/* The following are not system calls, but are processed like them. */
+#define MOLUNPAUSE		  65	/* to MM or FS: check for EINTR */
+#define MOLREVIVE	 	  67	/* to FS: revive a sleeping process */
+#define MOLTASK_REPLY	  68	/* to FS: reply code from tty task */
+
+/* Posix signal handling. */
+#define MOLSIGACTION	  71
+#define MOLSIGSUSPEND	  72
+#define MOLSIGPENDING	  73
+#define MOLSIGPROCMASK	  74
+#define MOLSIGRETURN	  75
+
+#define MOLREBOOT		  76	/* to PM */
+
+/* MINIX specific calls, e.g., to support system services. */
+#define MOLSVRCTL		  77
+#define MOLPROCSTAT          78    /* to PM */
+#define MOLGETSYSINFO	  79	/* to PM or FS */
+#define MOLGETPROCNR         80    /* to PM */
+#define MOLDEVCTL		  81    /* to FS */
+#define MOLFSTATFS	 	  82	/* to FS */
+#define MOLALLOCMEM	  83	/* to PM */
+#define MOLFREEMEM		  84	/* to PM */
+#define MOLSELECT            85	/* to FS */
+#define MOLFCHDIR            86	/* to FS */
+#define MOLFSYNC             87	/* to FS */
+#define MOLGETPRIORITY       88	/* to PM */
+#define MOLSETPRIORITY       89	/* to PM */
+#define MOLGETTIMEOFDAY      90	/* to PM */
+#define MOLSETEUID		  91	/* to PM */
+#define MOLSETEGID		  92	/* to PM */
+#define MOLTRUNCATE	  93	/* to FS */
+#define MOLFTRUNCATE	  94	/* to FS */
+
+#ifdef MOLAUTOFORK
+#define MOLFREEPROC	  95	/* to PM: Sent by the parent process when it does fork() */
+#define MOLBINDPROC	  96	/* to PM: Sent by the parent process when it does fork() */
+#else /*MOLAUTOFORK */
+#define MOLBINDPROC	  95	/* to PM: When a registered system process needs to register to PM and SYSTASK  */
+#endif /*MOLAUTOFORK */
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/cmd.h /usr/src/linux/kernel/minix/cmd.h
--- /home/jara/linux-2.6.32/kernel/minix/cmd.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/cmd.h	2013-09-29 21:09:00.000000000 -0300
@@ -0,0 +1,69 @@
+
+/* COMMANDS 	*/
+  enum proxy_cmd{
+        CMD_NONE       =  0,	/* NO COMMAND  						*/
+		CMD_SEND_MSG,		/*  Send a message to a process 					*/
+		CMD_NTFY_MSG,		/* Send a NOTIFY message to remote proces  		*/
+		CMD_SNDREC_MSG,		/*  Send a message to a process and wait for reply 		*/
+		CMD_REPLY_MSG,		/*  Send a REPLY message to a process 				*/
+		CMD_COPYIN_DATA,	/* Request and data to copy data to remote process 		*/
+		CMD_COPYOUT_RQST,	/* The remote process send to local process the data requested 	*/
+		CMD_COPYLCL_RQST,
+		CMD_COPYRMT_RQST,	/* REQUESTER to SENDER to copy data out to RECEIVER */
+		CMD_COPYIN_RQST,	/* SENDER to RECEIVER */
+        CMD_HELL0,			/* HELLO COMMAND used by proxies 				*/
+		CMD_SHUTDOWN,		/* Exit the waiting loop with error	EMOLINTR */
+  };
+
+#define CMD_SEND_ACK		(CMD_SEND_MSG | CMD_ACKNOWLEDGE) 
+#define CMD_NTFY_ACK		(CMD_NTFY_MSG | CMD_ACKNOWLEDGE)
+#define CMD_SNDREC_ACK  	(CMD_SNDREC_MSG | CMD_ACKNOWLEDGE)
+#define	CMD_REPLY_ACK   	(CMD_REPLY_MSG  | CMD_ACKNOWLEDGE)
+#define	CMD_COPYIN_ACK 		(CMD_COPYIN_DATA | CMD_ACKNOWLEDGE)
+#define	CMD_COPYOUT_DATA 	(CMD_COPYOUT_RQST | CMD_ACKNOWLEDGE)
+#define	CMD_COPYLCL_ACK		(CMD_COPYLCL_RQST | CMD_ACKNOWLEDGE)
+#define CMD_COPYRMT_ACK 	(CMD_COPYRMT_RQST | CMD_ACKNOWLEDGE) /* From RECEIVER to REQUESTER */
+
+  
+struct vcopy_s {
+	int	v_src;		/* source endpoint		*/
+	int	v_dst;		/* destination endpoint		*/
+  	int	v_rqtr;		/* requester endpoint		*/
+	void 	*v_saddr;	/* virtual address copy from 	*/
+  	void 	*v_daddr;	/* virtual address copy to 	*/
+  	int	v_bytes;	/* bytes to copy		*/
+};
+typedef struct vcopy_s vcopy_t;
+
+struct cmd_s {
+	int	c_cmd;		
+	int 	c_vmid;		/* VM ID				*/
+	int	c_src;		/* source endpoint			*/
+	int	c_dst;		/* destination endpoint			*/
+	int	c_snode;	/* source node				*/
+	int	c_dnode;	/* destination node			*/
+	int 	c_rcode;	/* return code 				*/
+  	int 	c_len;		/* payload len 				*/
+struct timespec c_timestamp;	/* timestamp				*/
+	vcopy_t c_vcopy;	/* struct used only for remote vcopy 	*/
+};
+typedef struct cmd_s cmd_t;
+
+#define CMD_FORMAT "cmd=%d vmid=%d src=%d dst=%d snode=%d dnode=%d rcode=%d len=%d\n" 
+#define CMD_FIELDS(p) 	p->c_cmd, p->c_vmid, p->c_src, p->c_dst, p->c_snode \
+	, p->c_dnode, p->c_rcode, p->c_len 
+
+
+#define VCOPY_FORMAT "src=%d dst=%d rqtr=%d saddr=%p daddr=%p bytes=%d \n"
+#define VCOPY_FIELDS(p) p->c_vcopy.v_src, p->c_vcopy.v_dst, p->c_vcopy.v_rqtr,\
+	 p->c_vcopy.v_saddr, p->c_vcopy.v_daddr, p->c_vcopy.v_bytes
+
+#define	HDR_PAYLOAD_MASK	0x1000	/* it means that thereis another header */
+
+#define HDR_FORMAT 	CMD_FORMAT
+#define HDR_FIELDS(p)	CMD_FIELDS(p)
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/com.h /usr/src/linux/kernel/minix/com.h
--- /home/jara/linux-2.6.32/kernel/minix/com.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/com.h	2014-06-17 09:12:58.000000000 -0300
@@ -0,0 +1,566 @@
+#ifndef _MINIX_COM_H
+#define _MINIX_COM_H 
+
+#define 	OK		0
+
+#define 	TRUE	1
+#define 	FALSE	0
+
+#define TIMEOUT_NOWAIT			0	
+#define TIMEOUT_FOREVER			(-1)
+
+#define MIGR_START		0
+#define MIGR_COMMIT		1
+#define MIGR_ROLLBACK	2
+
+#define SELF_BIND		0
+#define LCL_BIND		1
+#define RMT_BIND		2
+#define BKUP_BIND		3
+
+/*===========================================================================*
+ *          	    		Magic process numbers			     *
+ *===========================================================================*/
+
+
+/* These may not be any valid endpoint (see <minix/endpoint.h>). */
+#define ANY		0x7ace	/* used to indicate 'any process' */
+#define NONE 		0x6ace  /* used to indicate 'no process at all' */
+#define SELF		0x8ace 	/* used to indicate 'own process' */
+#define _MAX_MAGIC_PROC (SELF)	/* used by <minix/endpoint.h> 
+				   to determine generation size */
+
+#define LOCALNODE		(-1) /* The node id of processes running local */
+
+#define MIN(x,y) 	(x<y)?x:y;
+#define MAX(x,y) 	(x>y)?x:y;
+
+/*===========================================================================*
+ *            	Process numbers of processes in the system image	     *
+ *===========================================================================*/
+
+/* The values of several task numbers depend on whether they or other tasks
+ * are enabled. They are defined as (PREVIOUS_TASK - ENABLE_TASK) in general.
+ * ENABLE_TASK is either 0 or 1, so a task either gets a new number, or gets
+ * the same number as the previous task and is further unused. Note that the
+ * order should correspond to the order in the task table defined in table.c. 
+ */
+
+
+/* Kernel tasks. These all run in the same address space. */
+#define KERNEL           -1			/* pseudo-process for IPC and scheduling */
+#define HARDWARE     KERNEL			/* for hardware interrupt handlers */
+#define SYSTEM           -2			/* request system functionality */
+#define CLOCK  		 (SYSTEM-_NR_SYSTASKS)	/* process number until NR_NODES System tasks */
+#define IDLE             (CLOCK-1)		/* runs when no one else can run */
+
+
+/* Number of tasks. Note that NR_PROCS is defined in <minix/config.h>. */
+/* !!!!!!!!!!!!!!! IT MUST BE LOWER THAN  (-EMOLBUSY) = 16 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11*/
+#define NR_TASKS	  _NR_TASKS 
+
+
+/* User-space processes, that is, device drivers, servers, and INIT. */
+#define PM_PROC_NR	  0			/* process manager */
+#define FS_PROC_NR 	  (PM_PROC_NR+1)	/* file system */
+#define RS_PROC_NR 	  (FS_PROC_NR+1)	/* reincarnation server */
+#define MEM_PROC_NR 	  (RS_PROC_NR+1)	/* memory driver (RAM disk, null, etc.) */
+#define LOG_PROC_NR	  (MEM_PROC_NR+1)	/* log device driver */
+#define TTY_PROC_NR	  (LOG_PROC_NR+1)	/* terminal (TTY) driver */
+#define DS_PROC_NR	  (TTY_PROC_NR+1)	/* data store server */
+#define IS_PROC_NR	  (DS_PROC_NR+1) 	/* Information Server*/
+#define INIT_PROC_NR	  (IS_PROC_NR+1)  	/* init -- goes multiuser */
+
+#define FIRST_USER_NR	   (NR_SYS_PROCS)
+
+/* Number of processes contained in the system image. */
+#define NR_BOOT_PROCS 	(NR_TASKS + INIT_PROC_NR + 1)
+
+/*===========================================================================*
+ *                	   Kernel notification types                         *
+ *===========================================================================*/
+
+/* Kernel notification types. In principle, these can be sent to any process,
+ * so make sure that these types do not interfere with other message types.
+ * Notifications are prioritized because of the way they are unhold() and
+ * blocking notifications are delivered. The lowest numbers go first. The
+ * offset are used for the per-process notification bit maps. 
+ */
+#define NOTIFY_MESSAGE		  0x1000
+#define NOTIFY_FROM(p)	 (NOTIFY_MESSAGE | (p)) 
+#  define PROC_EVENT	NOTIFY_FROM(PM_PROC_NR) /* process status change */
+#  define SYN_ALARM	NOTIFY_FROM(CLOCK) 	/* synchronous alarm */
+#  define SYS_SIG	NOTIFY_FROM(SYSTEM) 	/* system signal */
+#  define HARD_INT	NOTIFY_FROM(HARDWARE) 	/* hardware interrupt */
+#  define NEW_KSIG	NOTIFY_FROM(HARDWARE)  	/* new kernel signal */
+#  define FKEY_PRESSED	NOTIFY_FROM(TTY_PROC_NR)/* function key press */
+#  define DEV_PING	NOTIFY_FROM(RS_PROC_NR) /* driver liveness ping */
+
+/* Shorthands for message parameters passed with notifications. */
+#define NOTIFY_SOURCE		m_source
+#define NOTIFY_TYPE		m_type
+#define NOTIFY_FLAGS		m9_i1
+#define NOTIFY_ARG		m9_l1
+#define NOTIFY_TIMESTAMP	m9_t1  
+
+/*===========================================================================*
+ *                Messages for BUS controller drivers 			     *
+ *===========================================================================*/
+#define BUSC_RQ_BASE	0x300	/* base for request types */
+#define BUSC_RS_BASE	0x380	/* base for response types */
+
+#define BUSC_PCI_INIT		(BUSC_RQ_BASE + 0)	/* First message to
+							 * PCI driver
+							 */
+#define BUSC_PCI_FIRST_DEV	(BUSC_RQ_BASE + 1)	/* Get index (and
+							 * vid/did) of the
+							 * first PCI device
+							 */
+#define BUSC_PCI_NEXT_DEV	(BUSC_RQ_BASE + 2)	/* Get index (and
+							 * vid/did) of the
+							 * next PCI device
+							 */
+#define BUSC_PCI_FIND_DEV	(BUSC_RQ_BASE + 3)	/* Get index of a
+							 * PCI device based on
+							 * bus/dev/function
+							 */
+#define BUSC_PCI_IDS		(BUSC_RQ_BASE + 4)	/* Get vid/did from an
+							 * index
+							 */
+#define BUSC_PCI_DEV_NAME	(BUSC_RQ_BASE + 5)	/* Get the name of a
+							 * PCI device
+							 */
+#define BUSC_PCI_SLOT_NAME	(BUSC_RQ_BASE + 6)	/* Get the name of a
+							 * PCI slot
+							 */
+#define BUSC_PCI_RESERVE	(BUSC_RQ_BASE + 7)	/* Reserve a PCI dev */
+#define BUSC_PCI_ATTR_R8	(BUSC_RQ_BASE + 8)	/* Read 8-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_R16	(BUSC_RQ_BASE + 9)	/* Read 16-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_R32	(BUSC_RQ_BASE + 10)	/* Read 32-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W8	(BUSC_RQ_BASE + 11)	/* Write 8-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W16	(BUSC_RQ_BASE + 12)	/* Write 16-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W32	(BUSC_RQ_BASE + 13)	/* Write 32-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_RESCAN		(BUSC_RQ_BASE + 14)	/* Rescan bus */
+
+/*===========================================================================*
+ *                Messages for BLOCK and CHARACTER device drivers	     *
+ *===========================================================================*/
+
+/* Message types for device drivers. */
+#define DEV_RQ_BASE   0x400	/* base for device request types */
+#define DEV_RS_BASE   0x500	/* base for device response types */
+
+#define CANCEL       	(DEV_RQ_BASE +  0) /* force a task to cancel */
+#define DEV_READ	(DEV_RQ_BASE +  3) /* read from minor device */
+#define DEV_WRITE   	(DEV_RQ_BASE +  4) /* write to minor device */
+#define DEV_IOCTL    	(DEV_RQ_BASE +  5) /* I/O control code */
+#define DEV_OPEN     	(DEV_RQ_BASE +  6) /* open a minor device */
+#define DEV_CLOSE    	(DEV_RQ_BASE +  7) /* close a minor device */
+#define DEV_SCATTER  	(DEV_RQ_BASE +  8) /* write from a vector */
+#define DEV_GATHER   	(DEV_RQ_BASE +  9) /* read into a vector */
+#define TTY_SETPGRP 	(DEV_RQ_BASE + 10) /* set process group */
+#define TTY_EXIT	(DEV_RQ_BASE + 11) /* process group leader exited */	
+#define DEV_SELECT	(DEV_RQ_BASE + 12) /* request select() attention */
+#define DEV_STATUS   	(DEV_RQ_BASE + 13) /* request driver status */
+
+#define DEV_REPLY       (DEV_RS_BASE + 0) /* general task reply */
+#define DEV_CLONED      (DEV_RS_BASE + 1) /* return cloned minor */
+#define DEV_REVIVE      (DEV_RS_BASE + 2) /* driver revives process */
+#define DEV_IO_READY    (DEV_RS_BASE + 3) /* selected device ready */
+#define DEV_NO_STATUS   (DEV_RS_BASE + 4) /* empty status reply */
+
+/* Field names for messages to block and character device drivers. */
+#define DEVICE    	m2_i1	/* major-minor device */
+#define IO_ENDPT	m2_i2	/* which (proc/endpoint) wants I/O? */
+#define COUNT   	m2_i3	/* how many bytes to transfer */
+#define REQUEST 	m2_i3	/* ioctl request code */
+#define POSITION	m2_l1	/* file offset */
+#define ADDRESS 	m2_p1	/* core buffer address */
+
+/* Field names for DEV_SELECT messages to device drivers. */
+#define DEV_MINOR	m2_i1	/* minor device */
+#define DEV_SEL_OPS	m2_i2	/* which select operations are requested */
+#define DEV_SEL_WATCH	m2_i3	/* request notify if no operations are ready */
+
+/* Field names used in reply messages from tasks. */
+#define REP_ENDPT	m2_i1	/* # of proc on whose behalf I/O was done */
+#define REP_STATUS	m2_i2	/* bytes transferred or error number */
+#define SUSPEND 	 -998 	/* status to suspend caller, reply later */
+
+/* Field names for messages to TTY driver. */
+#define TTY_LINE	DEVICE	/* message parameter: terminal line */
+#define TTY_REQUEST	COUNT	/* message parameter: ioctl request code */
+#define TTY_SPEK	POSITION/* message parameter: ioctl speed, erasing */
+#define TTY_FLAGS	m2_l2	/* message parameter: ioctl tty mode */
+#define TTY_PGRP 	m2_i3	/* message parameter: process group */	
+
+/* Field names for the QIC 02 status reply from tape driver */
+#define TAPE_STAT0	m2_l1
+#define TAPE_STAT1	m2_l2
+
+/*===========================================================================*
+ *                  	   Messages for networking layer		     *
+ *===========================================================================*/
+
+/* Message types for network layer requests. This layer acts like a driver. */
+#define NW_OPEN		DEV_OPEN
+#define NW_CLOSE	DEV_CLOSE
+#define NW_READ		DEV_READ
+#define NW_WRITE	DEV_WRITE
+#define NW_IOCTL	DEV_IOCTL
+#define NW_CANCEL	CANCEL
+
+/* Base type for data link layer requests and responses. */
+#define DL_RQ_BASE	0x800		
+#define DL_RS_BASE	0x900		
+
+/* Message types for data link layer requests. */
+#define DL_WRITE	(DL_RQ_BASE + 3)
+#define DL_WRITEV	(DL_RQ_BASE + 4)
+#define DL_READ		(DL_RQ_BASE + 5)
+#define DL_READV	(DL_RQ_BASE + 6)
+#define DL_INIT		(DL_RQ_BASE + 7)
+#define DL_STOP		(DL_RQ_BASE + 8)
+#define DL_GETSTAT	(DL_RQ_BASE + 9)
+#define DL_GETNAME	(DL_RQ_BASE +10)
+
+/* Message type for data link layer replies. */
+#define DL_INIT_REPLY	(DL_RS_BASE + 20)
+#define DL_TASK_REPLY	(DL_RS_BASE + 21)
+#define DL_NAME_REPLY	(DL_RS_BASE + 22)
+
+/* Field names for data link layer messages. */
+#define DL_PORT		m2_i1
+#define DL_PROC		m2_i2	/* endpoint */
+#define DL_COUNT	m2_i3
+#define DL_MODE		m2_l1
+#define DL_CLCK		m2_l2
+#define DL_ADDR		m2_p1
+#define DL_STAT		m2_l1
+#define DL_NAME		m3_ca1
+
+/* Bits in 'DL_STAT' field of DL replies. */
+#  define DL_PACK_SEND		0x01
+#  define DL_PACK_RECV		0x02
+#  define DL_READ_IP		0x04
+
+/* Bits in 'DL_MODE' field of DL requests. */
+#  define DL_NOMODE		0x0
+#  define DL_PROMISC_REQ	0x2
+#  define DL_MULTI_REQ		0x4
+#  define DL_BROAD_REQ		0x8
+
+/*===========================================================================*
+ *                  SYSTASK request types and field names                    *
+ *===========================================================================*/
+
+/* System library calls are dispatched via a call vector, so be careful when 
+ * modifying the system call numbers. The numbers here determine which call
+ * is made from the call vector.
+ */ 
+#define KERNEL_CALL	0x600	/* base for kernel calls to SYSTEM */ 
+
+#  define SYS_FORK       (KERNEL_CALL + 0)	/* sys_fork() */
+#  define SYS_EXEC       (KERNEL_CALL + 1)	/* sys_exec() */
+#  define SYS_EXIT	 (KERNEL_CALL + 2)	/* sys_exit() */
+#  define SYS_NICE       (KERNEL_CALL + 3)	/* sys_nice() */
+#  define SYS_PRIVCTL    (KERNEL_CALL + 4)	/* sys_privctl() */
+#  define SYS_TRACE      (KERNEL_CALL + 5)	/* sys_trace() */
+#  define SYS_KILL       (KERNEL_CALL + 6)	/* sys_kill() */
+
+#  define SYS_GETKSIG    (KERNEL_CALL + 7)	/* sys_getsig() */
+#  define SYS_ENDKSIG    (KERNEL_CALL + 8)	/* sys_endsig() */
+#  define SYS_SIGSEND    (KERNEL_CALL + 9)	/* sys_sigsend() */
+#  define SYS_SIGRETURN  (KERNEL_CALL + 10)	/* sys_sigreturn() */
+
+#  define SYS_NEWMAP     (KERNEL_CALL + 11)	/* sys_newmap() */
+#  define SYS_SEGCTL     (KERNEL_CALL + 12)	/* sys_segctl() */
+#  define SYS_MEMSET     (KERNEL_CALL + 13)	/* sys_memset() */
+
+#  define SYS_UMAP       (KERNEL_CALL + 14)	/* sys_umap() */
+#  define SYS_VIRCOPY    (KERNEL_CALL + 15)	/* sys_vircopy() */
+#  define SYS_PHYSCOPY   (KERNEL_CALL + 16) 	/* sys_physcopy() */
+#  define SYS_VIRVCOPY   (KERNEL_CALL + 17)	/* sys_virvcopy() */
+#  define SYS_PHYSVCOPY  (KERNEL_CALL + 18)	/* sys_physvcopy() */
+
+#  define SYS_IRQCTL     (KERNEL_CALL + 19)	/* sys_irqctl() */
+#  define SYS_INT86      (KERNEL_CALL + 20)	/* sys_int86() */
+#  define SYS_DEVIO      (KERNEL_CALL + 21)	/* sys_devio() */
+#  define SYS_SDEVIO     (KERNEL_CALL + 22)	/* sys_sdevio() */
+#  define SYS_VDEVIO     (KERNEL_CALL + 23)	/* sys_vdevio() */
+
+#  define SYS_SETALARM	 (KERNEL_CALL + 24)	/* sys_setalarm() */
+#  define SYS_TIMES	 (KERNEL_CALL + 25)	/* sys_times() */
+#  define SYS_GETINFO    (KERNEL_CALL + 26) 	/* sys_getinfo() */
+#  define SYS_ABORT      (KERNEL_CALL + 27)	/* sys_abort() */
+#  define SYS_IOPENABLE  (KERNEL_CALL + 28)	/* sys_enable_iop() */
+#  define SYS_VM_SETBUF  (KERNEL_CALL + 29)	/* sys_vm_setbuf() */
+#  define SYS_VM_MAP  	 (KERNEL_CALL + 30)	/* sys_vm_map() */
+#  define SYS_KILLED  	 (KERNEL_CALL + 31)	/* sys_vm_map() */
+
+#  define SYS_BINDPROC 	 (KERNEL_CALL + 32)	/* sys_bindproc() */
+#  define SYS_RFORK 	 (KERNEL_CALL + 33)	/* sys_bindproc() */
+
+#define NR_SYS_CALLS	34	/* number of system calls */ 
+
+/* Subfunctions for SYS_PRIVCTL */
+#define SYS_PRIV_INIT		1	/* Initialize a privilege structure */
+#define SYS_PRIV_ADD_IO		2	/* Add I/O range (struct io_range) */
+#define SYS_PRIV_ADD_MEM	3	/* Add memory range (struct mem_range)
+					 */
+#define SYS_PRIV_ADD_IRQ	4	/* Add IRQ */
+
+/* Field names for SYS_MEMSET, SYS_SEGCTL. */
+#define MEM_PTR		m2_p1	/* base */
+#define MEM_COUNT	m2_l1	/* count */
+#define MEM_PATTERN	m2_l2   /* pattern to write */
+#define MEM_CHUNK_BASE	m4_l1	/* physical base address */
+#define MEM_CHUNK_SIZE	m4_l2	/* size of mem chunk */
+#define MEM_TOT_SIZE	m4_l3	/* total memory size */
+#define MEM_CHUNK_TAG	m4_l4	/* tag to identify chunk of mem */
+
+/* Field names for SYS_DEVIO, SYS_VDEVIO, SYS_SDEVIO. */
+#define DIO_REQUEST	m2_i3	/* device in or output */
+#   define DIO_INPUT	    0	/* input */
+#   define DIO_OUTPUT	    1	/* output */
+#define DIO_TYPE	m2_i1   /* flag indicating byte, word, or long */ 
+#   define DIO_BYTE	  'b'	/* byte type values */
+#   define DIO_WORD	  'w'	/* word type values */
+#   define DIO_LONG	  'l'	/* long type values */
+#define DIO_PORT	m2_l1	/* single port address */
+#define DIO_VALUE	m2_l2	/* single I/O value */
+#define DIO_VEC_ADDR	m2_p1   /* address of buffer or (p,v)-pairs */
+#define DIO_VEC_SIZE	m2_l2   /* number of elements in vector */
+#define DIO_VEC_ENDPT	m2_i2   /* number of process where vector is */
+
+/* Field names for SYS_SIGNARLM, SYS_FLAGARLM, SYS_SYNCALRM. */
+#define ALRM_EXP_TIME   m2_l1	/* expire time for the alarm call */
+#define ALRM_ABS_TIME   m2_i2	/* set to 1 to use absolute alarm time */
+#define ALRM_TIME_LEFT  m2_l1	/* how many ticks were remaining */
+#define ALRM_ENDPT      m2_i1	/* which process wants the alarm? */
+#define ALRM_FLAG_PTR	m2_p1   /* virtual address of timeout flag */ 	
+
+/* Field names for SYS_IRQCTL. */
+#define IRQ_REQUEST     m5_c1	/* what to do? */
+#  define IRQ_SETPOLICY     1	/* manage a slot of the IRQ table */
+#  define IRQ_RMPOLICY      2	/* remove a slot of the IRQ table */
+#  define IRQ_ENABLE        3	/* enable interrupts */
+#  define IRQ_DISABLE       4	/* disable interrupts */
+#define IRQ_VECTOR	m5_c2   /* irq vector */
+#define IRQ_POLICY	m5_i1   /* options for IRQCTL request */
+#  define IRQ_REENABLE  0x001	/* reenable IRQ line after interrupt */
+#  define IRQ_BYTE      0x100	/* byte values */      
+#  define IRQ_WORD      0x200	/* word values */
+#  define IRQ_LONG      0x400	/* long values */
+#define IRQ_ENDPT	m5_i2   /* endpoint number, SELF, NONE */
+#define IRQ_HOOK_ID	m5_l3   /* id of irq hook at kernel */
+
+/* Field names for SYS_SEGCTL. */
+#define SEG_SELECT	m4_l1   /* segment selector returned */ 
+#define SEG_OFFSET	m4_l2	/* offset in segment returned */
+#define SEG_PHYS	m4_l3	/* physical address of segment */
+#define SEG_SIZE	m4_l4	/* segment size */
+#define SEG_INDEX	m4_l5	/* segment index in remote map */
+
+/* Field names for SYS_VIDCOPY. */
+#define VID_REQUEST	m4_l1	/* what to do? */
+#  define VID_VID_COPY	   1	/* request vid_vid_copy() */
+#  define MEM_VID_COPY     2	/* request mem_vid_copy() */
+#define VID_SRC_ADDR	m4_l2	/* virtual address in memory */
+#define VID_SRC_OFFSET	m4_l3	/* offset in video memory */
+#define VID_DST_OFFSET	m4_l4	/* offset in video memory */
+#define VID_CP_COUNT	m4_l5	/* number of words to be copied */
+
+/* Field names for SYS_ABORT. */
+#define ABRT_HOW	m1_i1	/* RBT_REBOOT, RBT_HALT, etc. */
+#define ABRT_MON_ENDPT  m1_i2	/* process where monitor params are */
+#define ABRT_MON_LEN	m1_i3	/* length of monitor params */
+#define ABRT_MON_ADDR   m1_p1	/* virtual address of monitor params */
+
+/* Field names for _UMAP, _VIRCOPY, _PHYSCOPY. */
+#define CP_SRC_SPACE 	m5_c1	/* T or D space (stack is also D) */
+#define CP_SRC_ENDPT	m5_i1	/* process to copy from */
+#define CP_SRC_ADDR	m5_l1	/* address where data come from */
+#define CP_DST_SPACE	m5_c2	/* T or D space (stack is also D) */
+#define CP_DST_ENDPT	m5_i2	/* process to copy to */
+#define CP_DST_ADDR	m5_l2	/* address where data go to */
+#define CP_NR_BYTES	m5_l3	/* number of bytes to copy */
+
+/* Field names for SYS_VCOPY and SYS_VVIRCOPY. */
+#define VCP_NR_OK	m1_i2	/* number of successfull copies */
+#define VCP_VEC_SIZE	m1_i3	/* size of copy vector */
+#define VCP_VEC_ADDR	m1_p1	/* pointer to copy vector */
+
+/* Field names for SYS_GETINFO. */
+#define I_REQUEST      m7_i3	/* what info to get */
+#   define GET_KINFO	   0	/* get kernel information structure */
+#   define GET_IMAGE	   1	/* get system image table */
+#   define GET_PROCTAB	   2	/* get kernel process table */
+#   define GET_RANDOMNESS  3	/* get randomness buffer */
+#   define GET_MONPARAMS   4	/* get monitor parameters */
+#   define GET_KENV	   5	/* get kernel environment string */
+#   define GET_IRQHOOKS	   6	/* get the IRQ table */
+#   define GET_KMESSAGES   7	/* get kernel messages */
+#   define GET_PRIVTAB	   8	/* get kernel privileges table */
+#   define GET_KADDRESSES  9	/* get various kernel addresses */
+#   define GET_SCHEDINFO  10	/* get scheduling queues */
+#   define GET_PROC 	  11	/* get process slot if given process */
+#   define GET_MACHINE 	  12	/* get machine information */
+#   define GET_LOCKTIMING 13	/* get lock()/unlock() latency timing */
+#   define GET_BIOSBUFFER 14	/* get a buffer for BIOS calls */
+#   define GET_LOADINFO   15	/* get load average information */
+#   define GET_SLOTSTAB   16	/* get slot allocation table from systask */
+
+#define I_ENDPT      m7_i4	/* calling process */
+#define I_VAL_PTR      m7_p1	/* virtual address at caller */ 
+#define I_VAL_LEN      m7_i1	/* max length of value */
+#define I_VAL_PTR2     m7_p2	/* second virtual address */ 
+#define I_VAL_LEN2_E   m7_i2	/* second length, or proc nr */
+#   define GET_IRQACTIDS  16	/* get the IRQ masks */
+
+/* Field names for SYS_TIMES. */
+#define T_ENDPT      m4_l1	/* process to request time info for */
+#define T_USER_TIME    m4_l1	/* user time consumed by process */
+#define T_SYSTEM_TIME  m4_l2	/* system time consumed by process */
+#define T_CHILD_UTIME  m4_l3	/* user time consumed by process' children */
+#define T_CHILD_STIME  m4_l4	/* sys time consumed by process' children */
+#define T_BOOT_TICKS   m4_l5	/* number of clock ticks since boot time */
+
+/* vm_map */
+#define VM_MAP_ENDPT		m4_l1
+#define VM_MAP_MAPUNMAP		m4_l2
+#define VM_MAP_BASE		m4_l3
+#define VM_MAP_SIZE		m4_l4
+#define VM_MAP_ADDR		m4_l5
+
+/* Field names for SYS_TRACE, SYS_PRIVCTL. */
+#define CTL_ENDPT    m2_i1	/* process number of the caller */
+#define CTL_REQUEST    m2_i2	/* server control request */
+#define CTL_MM_PRIV    m2_i3	/* privilege as seen by PM */
+#define CTL_ARG_PTR    m2_p1	/* pointer to argument */
+#define CTL_ADDRESS    m2_l1	/* address at traced process' space */
+#define CTL_DATA       m2_l2	/* data field for tracing */
+
+/* Field names for SYS_KILL, SYS_SIGCTL */
+#define SIG_REQUEST    m2_l2	/* PM signal control request */
+#define S_GETSIG 	   0	/* get pending kernel signal */
+#define S_ENDSIG 	   1	/* finish a kernel signal */
+#define S_SENDSIG   	   2	/* POSIX style signal handling */
+#define S_SIGRETURN	   3 	/* return from POSIX handling */
+#define S_KILL		   4 	/* servers kills process with signal */
+#define SIG_ENDPT       m2_i1	/* process number for inform */
+#define SIG_NUMBER     m2_i2	/* signal number to send */
+#define SIG_FLAGS      m2_i3	/* signal flags field */
+#define SIG_MAP        m2_l1	/* used by kernel to pass signal bit map */
+#define SIG_CTXT_PTR   m2_p1	/* pointer to info to restore signal context */
+
+/* Field names for SYS_FORK, _EXEC, _EXIT, _NEWMAP. */
+#define PR_ENDPT       m1_i1	/* indicates a process */
+#define PR_LPID        m1_i1	/* indicates the LINUX PID */
+#define PR_PRIORITY    m1_i2	/* process priority */
+#define PR_PRIV	     m1_i2	/* process privilege level */
+#define PR_SLOT        m1_i2	/* indicates a process slot */
+#define PR_PID	     m1_i3	/* process id at process manager */
+#define PR_STACK_PTR   m1_p1	/* used for stack ptr in sys_exec, sys_getsp */
+#define PR_TRACING     m1_i3	/* flag to indicate tracing is on/ off */
+#define PR_NAME_PTR    m1_p2	/* tells where program name is for dmp */
+#define PR_IP_PTR      m1_p3	/* initial value for ip after exec */
+#define PR_MEM_PTR     m1_p1	/* tells where memory map is for sys_newmap */
+
+#define	M3_LPID		m3_i1
+#define	M3_ENDPT	m3_i2
+#define	M3_SLOT		m3_i2
+	
+
+/* Field names for SYS_INT86 */
+#define INT86_REG86    m1_p1	/* pointer to registers */
+
+/* Field names for SELECT (FS). */
+#define SEL_NFDS       m8_i1
+#define SEL_READFDS    m8_p1
+#define SEL_WRITEFDS   m8_p2
+#define SEL_ERRORFDS   m8_p3
+#define SEL_TIMEOUT    m8_p4
+
+/* What system info to retrieve with sysgetinfo(). */
+#define SI_KINFO	   	   0	/* get kernel info via PM */
+#define SI_PMPROC_TAB	   1	/* copy of entire PM process table */
+#define SI_KPROC_TAB	   2	/* copy of kernel process table */
+#define SI_MACHINE 	   3	/* copy of kernel VM info via PM */
+#define SI_PRIV_TAB	   4	/* copy of kernel priviledge  table */
+#define SI_FSPROC_TAB	   5	/* copy of entire PM process table */
+#define SI_SLOTS_TAB	   6 	/* copy of entire SYSTASK slots allocation table */
+
+
+#define SI_DMAP_TAB	   3	/* get device <-> driver mappings */
+#define SI_MEM_ALLOC	   4	/* get memory allocation data */
+#define SI_DATA_STORE	   5	/* get copy of data store */
+#define SI_LOADINFO	   6	/* get copy of load average structure */
+
+/*===========================================================================*
+ *                Messages for the Reincarnation Server 		     *
+ *===========================================================================*/
+
+#define RS_RQ_BASE		0x700
+
+#define RS_UP		(RS_RQ_BASE + 0)	/* start system service */
+#define RS_DOWN		(RS_RQ_BASE + 1)	/* stop system service */
+#define RS_REFRESH	(RS_RQ_BASE + 2)	/* restart system service */
+#define RS_RESCUE	(RS_RQ_BASE + 3)	/* set rescue directory */
+#define RS_SHUTDOWN	(RS_RQ_BASE + 4)	/* alert about shutdown */
+
+#  define RS_CMD_ADDR		m1_p1		/* command string */
+#  define RS_CMD_LEN		m1_i1		/* length of command */
+#  define RS_PID		m1_i1		/* pid of system service */
+#  define RS_PERIOD 	        m1_i2		/* heartbeat period */
+#  define RS_DEV_MAJOR          m1_i3           /* major device number */
+
+/*===========================================================================*
+ *                Messages for the Data Store Server			     *
+ *===========================================================================*/
+
+#define DS_RQ_BASE		0x800
+
+#define DS_PUBLISH	(DS_RQ_BASE + 0)	/* publish information */
+#define DS_RETRIEVE	(DS_RQ_BASE + 1)	/* retrieve information */
+#define DS_SUBSCRIBE	(DS_RQ_BASE + 2)	/* subscribe to information */
+
+#  define DS_KEY		m2_i1		/* key for the information */
+#  define DS_FLAGS		m2_i2		/* flags provided by caller */
+#  define DS_AUTH		m2_p1		/* authorization of caller */
+#  define DS_VAL_L1		m2_l1		/* first long data value */
+#  define DS_VAL_L2		m2_l2		/* second long data value */
+
+/*===========================================================================*
+ *                Miscellaneous messages used by TTY			     *
+ *===========================================================================*/
+
+/* Miscellaneous request types and field names, e.g. used by IS server. */
+#define FKEY_CONTROL 		98  	/* control a function key at the TTY */
+#  define FKEY_REQUEST	     m2_i1	/* request to perform at TTY */
+#  define    FKEY_MAP		10	/* observe function key */
+#  define    FKEY_UNMAP		11	/* stop observing function key */
+#  define    FKEY_EVENTS	12	/* request open key presses */
+#  define FKEY_FKEYS	      m2_l1	/* F1-F12 keys pressed */
+#  define FKEY_SFKEYS	      m2_l2	/* Shift-F1-F12 keys pressed */
+#define DIAGNOSTICS 	100 	/* output a string without FS in between */
+#  define DIAG_PRINT_BUF      m1_p1
+#  define DIAG_BUF_COUNT      m1_i1
+#  define DIAG_ENDPT          m1_i2
+#define GET_KMESS	101	/* get kmess from TTY */
+#  define GETKM_PTR	      m1_p1
+
+
+#endif /* _MINIX_COM_H */ 
diff -Naur /home/jara/linux-2.6.32/kernel/minix/config.h /usr/src/linux/kernel/minix/config.h
--- /home/jara/linux-2.6.32/kernel/minix/config.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/config.h	2013-10-21 19:32:44.000000000 -0300
@@ -0,0 +1,167 @@
+#ifndef _CONFIG_H
+#define _CONFIG_H
+
+#define MOLIPC	1
+#define MOLPROFILING	0
+
+
+/* Minix release and version numbers. */
+#define OS_RELEASE "3"
+#define OS_VERSION "1.2a-MOLIPC"
+
+#define DRVS_VERSION 2
+#define DRVS_SUBVER  1
+
+#define MAXCOPYBUF	32768 
+#define MAXCOPYLEN	(16 * MAXCOPYBUF)
+
+/* This file sets configuration parameters for the MINIX kernel, FS, and PM.
+ * It is divided up into two main sections.  The first section contains
+ * user-settable parameters.  In the second section, various internal system
+ * parameters are set based on the user-settable parameters.
+ *
+ * Parts of config.h have been moved to sys_config.h, which can be included
+ * by other include files that wish to get at the configuration data, but
+ * don't want to pollute the users namespace. Some editable values have
+ * gone there.
+ *
+ */
+
+/* The MACHINE (called _MINIX_MACHINE) setting can be done
+ * in <minix/machine.h>.
+ */
+#include "sys_config.h"
+
+#define USE_DRVS_RWLOCK	0
+#define USE_DRVS_MUTEX	1
+
+#define USE_VM_RWLOCK	0
+#define USE_VM_MUTEX	1
+#define USE_VM_SEQLOCK	2
+
+#define USE_PROC_RWLOCK	0
+#define USE_PROC_MUTEX	1
+
+#define USE_NODE_RWLOCK	0
+#define USE_NODE_MUTEX	1
+
+#define USE_PROXY_RWLOCK	0
+#define USE_PROXY_MUTEX		1
+
+#define DEBUGALL	0xFFFFFFFF	/* Set all debug levels */
+
+#define LOCK_DRVS_TYPE	USE_DRVS_MUTEX
+#define LOCK_VM_TYPE	USE_VM_MUTEX
+#define LOCK_PROC_TYPE	USE_PROC_MUTEX
+#define LOCK_NODE_TYPE	USE_NODE_MUTEX
+#define LOCK_PROXY_TYPE	USE_PROXY_MUTEX
+
+#define MACHINE      _MINIX_MACHINE
+
+#define IBM_PC       _MACHINE_IBM_PC
+#define SUN_4        _MACHINE_SUN_4
+#define SUN_4_60     _MACHINE_SUN_4_60
+#define ATARI        _MACHINE_ATARI
+#define MACINTOSH    _MACHINE_MACINTOSH
+
+/* Number of slots in the process table for non-kernel processes. The number
+ * of system processes defines how many processes with special privileges 
+ * there can be. User processes share the same properties and count for one. 
+ *
+ * These can be changed in sys_config.h.
+ */
+
+#define NR_FIXED_TASKS  _NR_FIXED_TASKS 
+#define NR_NODES 	_NR_NODES 
+#define NR_SYSTASKS	_NR_SYSTASKS
+#define NR_TASKS	_NR_TASKS
+#define NR_SERVERS	_NR_SERVERS
+#define NR_SYS_PROCS	_NR_SYS_PROCS
+#define NR_USR_PROCS    _NR_USR_PROCS
+#define NR_PROCS	_NR_PROCS
+
+#define NR_VMS 	  	_NR_VMS 
+
+#define MAX_PROF		10 /*Maximum performance profiling entries in process descriptor */
+
+/* The buffer cache should be made as large as you can afford. */
+#if (MACHINE == IBM_PC && _WORD_SIZE == 2)
+#define NR_BUFS           40	/* # blocks in the buffer cache */
+#define NR_BUF_HASH       64	/* size of buf hash table; MUST BE POWER OF 2*/
+#endif
+
+#if (MACHINE == IBM_PC && _WORD_SIZE == 4)
+#define NR_BUFS         1200	/* # blocks in the buffer cache */
+#define NR_BUF_HASH     2048	/* size of buf hash table; MUST BE POWER OF 2*/
+#endif
+
+#if (MACHINE == SUN_4_60)
+#define NR_BUFS		 512	/* # blocks in the buffer cache (<=1536) */
+#define NR_BUF_HASH	 512	/* size of buf hash table; MUST BE POWER OF 2*/
+#endif
+
+/* Number of controller tasks (/dev/cN device classes). */
+#define NR_CTRLRS          2
+
+/* Enable or disable the second level file system cache on the RAM disk. */
+#define ENABLE_CACHE2      0
+
+/* Enable or disable swapping processes to disk. */
+#define ENABLE_SWAP	   1
+
+/* Include or exclude an image of /dev/boot in the boot image. 
+ * Please update the makefile in /usr/src/tools/ as well.
+ */
+#define ENABLE_BOOTDEV	   0	/* load image of /dev/boot at boot time */
+
+/* DMA_SECTORS may be increased to speed up DMA based drivers. */
+#define DMA_SECTORS        1	/* DMA buffer size (must be >= 1) */
+
+/* Include or exclude backwards compatibility code. */
+#define ENABLE_BINCOMPAT   0	/* for binaries using obsolete calls */
+#define ENABLE_SRCCOMPAT   0	/* for sources using obsolete calls */
+
+/* Which processes should receive diagnostics from the kernel and system? 
+ * Directly sending it to TTY only displays the output. Sending it to the
+ * log driver will cause the diagnostics to be buffered and displayed.
+ * Messages are sent by src/lib/sysutil/kputc.c to these processes, in
+ * the order of this array, which must be terminated by NONE. This is used
+ * by drivers and servers that printf().
+ * The kernel does this for its own kprintf() in kernel/utility.c, also using
+ * this array, but a slightly different mechanism.
+ */
+#define OUTPUT_PROCS_ARRAY	{ TTY_PROC_NR, LOG_PROC_NR, NONE }
+
+/* NR_CONS, NR_RS_LINES, and NR_PTYS determine the number of terminals the
+ * system can handle.
+ */
+#define NR_CONS            4	/* # system consoles (1 to 8) */
+#define	NR_RS_LINES	   4	/* # rs232 terminals (0 to 4) */
+#define	NR_PTYS		   32	/* # pseudo terminals (0 to 64) */
+
+/*===========================================================================*
+ *	There are no user-settable parameters after this line		     *
+ *===========================================================================*/
+/* Set the CHIP type based on the machine selected. The symbol CHIP is actually
+ * indicative of more than just the CPU.  For example, machines for which
+ * CHIP == INTEL are expected to have 8259A interrrupt controllers and the
+ * other properties of IBM PC/XT/AT/386 types machines in general. */
+#define INTEL             _CHIP_INTEL	/* CHIP type for PC, XT, AT, 386 and clones */
+#define M68000            _CHIP_M68000	/* CHIP type for Atari, Amiga, Macintosh    */
+#define SPARC             _CHIP_SPARC	/* CHIP type for SUN-4 (e.g. SPARCstation)  */
+
+/* Set the FP_FORMAT type based on the machine selected, either hw or sw    */
+#define FP_NONE	 _FP_NONE	/* no floating point support                */
+#define FP_IEEE	 _FP_IEEE	/* conform IEEE floating point standard     */
+
+/* _MINIX_CHIP is defined in sys_config.h. */
+#define CHIP	_MINIX_CHIP
+
+/* _MINIX_FP_FORMAT is defined in sys_config.h. */
+#define FP_FORMAT	_MINIX_FP_FORMAT
+
+/* _ASKDEV and _FASTLOAD are defined in sys_config.h. */
+#define ASKDEV _ASKDEV
+#define FASTLOAD _FASTLOAD
+
+#endif /* _CONFIG_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/const.h /usr/src/linux/kernel/minix/const.h
--- /home/jara/linux-2.6.32/kernel/minix/const.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/const.h	2014-07-10 19:50:30.000000000 -0300
@@ -0,0 +1,48 @@
+#define BITMAP_BITS		(sizeof(unsigned long int)* CHAR_BIT) 
+#define BIT_VM_FREE	1	/* VM is free */
+
+#define VM_RUNNING	0x00			/* VM is RUNNING */
+#define VM_FREE		(1<<BIT_VM_FREE)	/* VM is free */
+
+#define DRVS_RUNNING	0x00	/* DRVS is RUNNING*/
+#define DRVS_NO_INIT	(-1)	/* DRVS has not been initialized */
+#define PROC_NO_PID	(-1)	
+
+#define SUPER_USER (uid_t) 0	/* uid_t of superuser */
+#define MOL_LONG_MAX  2147483647L	/* maximum value of a long */
+
+//Agregado PID MOLFS
+#define NO_BLOCK              ((block_t) 0)	/* absence of a block number */
+#define NO_ENTRY                ((ino_t) 0)	/* absence of a dir entry */
+#define NO_ZONE                ((zone_t) 0)	/* absence of a zone number */
+#define NO_DEV                  ((dev_t) 0)	/* absence of a device numb */
+
+//ESTO VIENE DE dirent.h ver si incluirlo o usar directo la header !!!
+
+/* The block size must be at least 1024 bytes, because otherwise
+ * the superblock (at 1024 bytes) overlaps with other filesystem data.
+ */
+#define _MIN_BLOCK_SIZE		 1024
+
+/* The below is allocated in some parts of the system as the largest
+ * a filesystem block can be. For instance, the boot monitor allocates
+ * 3 of these blocks and has to fit within 64kB, so this can't be
+ * increased without taking that into account.
+ */
+#define _MAX_BLOCK_SIZE		 4096
+
+#define _STATIC_BLOCK_SIZE   1024
+
+#define MINIX_HZ          60	/* clock freq (software settable on IBM-PC) */
+
+/* Miscellaneous */
+//#define TRUE               1	/* used for turning integers into Booleans */
+//#define FALSE              0	/* used for turning integers into Booleans */ 
+#define BYTE            0377	/* mask for 8 bits */
+#define READING            0	/* copy data to user */
+#define WRITING            1	/* copy data from user */
+#define NO_NUM        0x8000	/* used as numerical argument to panic() */
+#define NIL_PTR   (char *) 0	/* generally useful expression */
+#define HAVE_SCATTERED_IO  1	/* scattered I/O is now standard */ 
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/dir.h /usr/src/linux/kernel/minix/dir.h
--- /home/jara/linux-2.6.32/kernel/minix/dir.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/dir.h	2005-04-21 11:55:00.000000000 -0300
@@ -0,0 +1,19 @@
+/* The <dir.h> header gives the layout of a directory. */
+
+#ifndef _DIR_H
+#define _DIR_H
+
+#include <sys/types.h>
+
+#define	DIRBLKSIZ	512	/* size of directory block */
+
+#ifndef DIRSIZ
+#define DIRSIZ	60
+#endif
+
+struct direct {
+  ino_t d_ino;
+  char d_name[DIRSIZ];
+};
+
+#endif /* _DIR_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/drvs_usr.h /usr/src/linux/kernel/minix/drvs_usr.h
--- /home/jara/linux-2.6.32/kernel/minix/drvs_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/drvs_usr.h	2013-10-03 11:20:00.000000000 -0300
@@ -0,0 +1,31 @@
+#ifndef DRVS_USR_H
+#define DRVS_USR_H
+
+struct drvs_usr {
+	int	d_nr_vms;
+	int	d_nr_nodes;
+	int 	d_nr_procs;
+	int 	d_nr_tasks;
+	int 	d_nr_sysprocs;
+
+	int 	d_max_copybuf;
+	int 	d_max_copylen;
+
+	unsigned long int d_dbglvl;
+	int	d_version;
+	int	d_subver;
+};
+typedef struct drvs_usr drvs_usr_t;
+
+#define DRVS_USR_FORMAT "d_nr_vms=%d d_nr_nodes=%d d_nr_procs=%d d_nr_tasks=%d d_nr_sysprocs=%d \n"
+#define DRVS_USR_FIELDS(p) p->d_nr_vms,p->d_nr_nodes, p->d_nr_procs, p->d_nr_tasks, p->d_nr_sysprocs  
+
+#define DRVS_MAX_FORMAT "d_max_copybuf=%d d_max_copylen=%d\n"
+#define DRVS_MAX_FIELDS(p) p->d_max_copybuf,p->d_max_copylen  
+
+#define DRVS_VER_FORMAT "d_dbglvl=%lX version=%d.%d\n"
+#define DRVS_VER_FIELDS(p) p->d_dbglvl, p->d_version, p->d_subver  
+
+
+
+#endif /* DRVS_USR_H */
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/kernel/minix/endpoint.h /usr/src/linux/kernel/minix/endpoint.h
--- /home/jara/linux-2.6.32/kernel/minix/endpoint.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/endpoint.h	2012-07-16 22:53:00.000000000 -0300
@@ -0,0 +1,25 @@
+
+#ifndef _MINIX_ENDPOINT_H
+#define _MINIX_ENDPOINT_H 1
+
+#include "sys_config.h"
+#include "com.h"
+
+/* The point of the padding in 'generation size' is to 
+ * allow for certain bogus endpoint numbers such as NONE, ANY, etc.
+ *
+ * The _MAX_MAGIC_PROC is defined by <minix/com.h>. That include
+ * file defines some magic process numbers such as ANY and NONE,
+ * and must never be a valid endpoint number. Therefore we make sure
+ * the generation size is big enough to start the next generation
+ * above the highest magic number.
+ */
+#define _ENDPOINT_GENERATION_SIZE (NR_TASKS+_MAX_MAGIC_PROC+1)
+#define _ENDPOINT_MAX_GENERATION  (INT_MAX/_ENDPOINT_GENERATION_SIZE-1)
+
+/* Generation + Process slot number <-> endpoint. */
+#define _ENDPOINT(g, p) ((g) * _ENDPOINT_GENERATION_SIZE + (p))
+#define _ENDPOINT_G(e) (((e)+NR_TASKS) / _ENDPOINT_GENERATION_SIZE)
+#define _ENDPOINT_P(e) ((((e)+NR_TASKS) % _ENDPOINT_GENERATION_SIZE) - NR_TASKS)
+
+#endif
diff -Naur /home/jara/linux-2.6.32/kernel/minix/errno.h /usr/src/linux/kernel/minix/errno.h
--- /home/jara/linux-2.6.32/kernel/minix/errno.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/errno.h	2012-07-16 22:35:00.000000000 -0300
@@ -0,0 +1,91 @@
+
+#   define _SIGN         -
+
+/* Here are the numerical values of the error numbers. */
+#define _NERROR               70  /* number of errors */  
+
+#define EMOLGENERIC      (_SIGN 99)  /* generic error */
+#define EMOLPERM         (_SIGN  1)  /* operation not permitted */
+#define EMOLNOENT        (_SIGN  2)  /* no such file or directory */
+#define EMOLSRCH         (_SIGN  3)  /* no such process */
+#define EMOLINTR         (_SIGN  4)  /* interrupted function call */
+#define EMOLIO           (_SIGN  5)  /* input/output error */
+#define EMOLNXIO         (_SIGN  6)  /* no such device or address */
+#define EMOL2BIG         (_SIGN  7)  /* arg list too long */
+#define EMOLNOEXEC       (_SIGN  8)  /* exec format error */
+#define EMOLBADF         (_SIGN  9)  /* bad file descriptor */
+#define EMOLCHILD        (_SIGN 10)  /* no child process */
+#define EMOLAGAIN        (_SIGN 11)  /* resource temporarily unavailable */
+#define EMOLNOMEM        (_SIGN 12)  /* not enough space */
+#define EMOLACCES        (_SIGN 13)  /* permission denied */
+#define EMOLFAULT        (_SIGN 14)  /* bad address */
+#define EMOLNOTBLK       (_SIGN 15)  /* Extension: not a block special file */
+#define EMOLBUSY         (_SIGN 16)  /* resource busy */
+#define EMOLEXIST        (_SIGN 17)  /* file exists */
+#define EMOLXDEV         (_SIGN 18)  /* improper link */
+#define EMOLNODEV        (_SIGN 19)  /* no such device */
+#define EMOLNOTDIR       (_SIGN 20)  /* not a directory */
+#define EMOLISDIR        (_SIGN 21)  /* is a directory */
+#define EMOLINVAL        (_SIGN 22)  /* invalid argument */
+#define EMOLNFILE        (_SIGN 23)  /* too many open files in system */
+#define EMOLMFILE        (_SIGN 24)  /* too many open files */
+#define EMOLNOTTY        (_SIGN 25)  /* inappropriate I/O control operation */
+#define EMOLTXTBSY       (_SIGN 26)  /* no longer used */
+#define EMOLFBIG         (_SIGN 27)  /* file too large */
+#define EMOLNOSPC        (_SIGN 28)  /* no space left on device */
+#define EMOLSPIPE        (_SIGN 29)  /* invalid seek */
+#define EMOLROFS         (_SIGN 30)  /* read-only file system */
+#define EMOLMLINK        (_SIGN 31)  /* too many links */
+#define EMOLPIPE         (_SIGN 32)  /* broken pipe */
+#define EMOLDOM          (_SIGN 33)  /* domain error    	(from ANSI C std) */
+#define EMOLRANGE        (_SIGN 34)  /* result too large	(from ANSI C std) */
+#define EMOLDEADLK       (_SIGN 35)  /* resource deadlock avoided */
+#define EMOLNAMETOOLONG  (_SIGN 36)  /* file name too long */
+#define EMOLNOLCK        (_SIGN 37)  /* no locks available */
+#define EMOLNOSYS        (_SIGN 38)  /* function not implemented */
+#define EMOLNOTEMPTY     (_SIGN 39)  /* directory not empty */
+#define EMOLLOOP         (_SIGN 40)  /* too many levels of symlinks detected */
+
+/* The following errors relate to networking. */
+#define EMOLPACKSIZE     (_SIGN 50)  /* invalid packet size for some protocol */
+#define EMOLOUTOFBUFS    (_SIGN 51)  /* not enough buffers left */
+#define EMOLBADIOCTL     (_SIGN 52)  /* illegal ioctl for device */
+#define EMOLBADMODE      (_SIGN 53)  /* badmode in ioctl */
+#define EMOLWOULDBLOCK   (_SIGN 54)
+#define EMOLBADDEST      (_SIGN 55)  /* not a valid destination address */
+#define EMOLDSTNOTRCH    (_SIGN 56)  /* destination not reachable */
+#define EMOLISCONN	      (_SIGN 57)  /* all ready connected */
+#define EMOLADDRINUSE    (_SIGN 58)  /* address in use */
+#define EMOLCONNREFUSED  (_SIGN 59)  /* connection refused */
+#define EMOLCONNRESET    (_SIGN 60)  /* connection reset */
+#define EMOLTIMEDOUT     (_SIGN 61)  /* connection timed out */
+#define EMOLURG	      (_SIGN 62)  /* urgent data present */
+#define EMOLNOURG	      (_SIGN 63)  /* no urgent data present */
+#define EMOLNOTCONN      (_SIGN 64)  /* no connection (yet or anymore) */
+#define EMOLSHUTDOWN     (_SIGN 65)  /* a write call to a shutdown connection */
+#define EMOLNOCONN       (_SIGN 66)  /* no such connection */
+#define EMOLAFNOSUPPORT  (_SIGN 67)  /* address family not supported */
+#define EMOLPROTONOSUPPORT (_SIGN 68) /* protocol not supported by AF */
+#define EMOLPROTOTYPE    (_SIGN 69)  /* Protocol wrong type for socket */
+#define EMOLINPROGRESS   (_SIGN 70)  /* Operation now in progress */
+#define EMOLADDRNOTAVAIL (_SIGN 71)  /* Can't assign requested address */
+#define EMOLALREADY      (_SIGN 72)  /* Connection already in progress */
+#define EMOLMSGSIZE      (_SIGN 73)  /* Message too long */
+#define EMOLNOTSOCK      (_SIGN 74)  /* Socket operation on non-socket */
+#define EMOLNOPROTOOPT   (_SIGN 75)  /* Protocol not available */
+
+/* The following are not POSIX errors, but they can still happen. 
+ * All of these are generated by the kernel and relate to message passing.
+ */
+#define EMOLLOCKED      (_SIGN 101)  /* can't send message due to deadlock */
+#define EMOLBADCALL     (_SIGN 102)  /* illegal system call number */
+#define EMOLBADSRCDST   (_SIGN 103)  /* bad source or destination process */
+#define EMOLCALLDENIED  (_SIGN 104)  /* no permission for system call */
+#define EMOLDEADSRCDST  (_SIGN 105)  /* source or destination is not alive */
+#define EMOLNOTREADY    (_SIGN 106)  /* source or destination is not ready */
+#define EMOLBADREQUEST  (_SIGN 107)  /* destination cannot handle request */
+#define EMOLSRCDIED     (_SIGN 108)  /* source just died */
+#define EMOLDSTDIED     (_SIGN 109)  /* destination just died */
+#define EMOLTRAPDENIED  (_SIGN 110)  /* IPC trap not allowed */
+#define EMOLDONTREPLY   (_SIGN 201)  /* pseudo-code: don't send a reply */
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/ipc.h /usr/src/linux/kernel/minix/ipc.h
--- /home/jara/linux-2.6.32/kernel/minix/ipc.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/ipc.h	2014-04-13 20:39:06.000000000 -0300
@@ -0,0 +1,127 @@
+#ifndef _IPC_H
+#define _IPC_H
+
+/*==========================================================================* 
+ * Types relating to messages. 						    *
+ *==========================================================================*/ 
+
+#define M1                 1
+#define M3                 3
+#define M4                 4
+#define M3_STRING         14
+
+#define MINIX_MSG	1	/* the payload is a MINIX message */
+
+#define 	SLOTS_BY_MSG		4 /* number of slots that fit in a message */
+
+typedef struct {int m1i1, m1i2, m1i3; char *m1p1, *m1p2, *m1p3;} mess_1;
+typedef struct {int m2i1, m2i2, m2i3; long m2l1, m2l2; char *m2p1;} mess_2;
+typedef struct {int m3i1, m3i2; char *m3p1; char m3ca1[M3_STRING];} mess_3;
+typedef struct {long m4l1, m4l2, m4l3, m4l4, m4l5;} mess_4;
+typedef struct {short m5c1, m5c2; int m5i1, m5i2; long m5l1, m5l2, m5l3;}mess_5;
+typedef struct {char m6ca1[sizeof(mess_3)];} mess_6;
+typedef struct {int m7i1, m7i2, m7i3, m7i4; char *m7p1, *m7p2;} mess_7;
+typedef struct {int m8i1, m8i2; char *m8p1, *m8p2, *m8p3, *m8p4;} mess_8;
+typedef struct {int m9i1, m9l1; struct timespec m9t1;} mess_9;
+typedef struct {int mAdst, mAnr, mAia[SLOTS_BY_MSG];} mess_A;
+
+
+typedef struct {
+  int m_source;			/* who sent the message */
+  int m_type;			/* what kind of message is it */
+  union {
+	mess_1 m_m1;
+	mess_2 m_m2;
+	mess_3 m_m3;
+	mess_4 m_m4;
+	mess_5 m_m5;
+	mess_6 m_m6;
+	mess_7 m_m7;
+	mess_8 m_m8;
+	mess_9 m_m9;
+	mess_A m_mA;
+  } m_u;
+} message;
+
+
+/* The following defines provide names for useful members. */
+#define m1_i1  m_u.m_m1.m1i1
+#define m1_i2  m_u.m_m1.m1i2
+#define m1_i3  m_u.m_m1.m1i3
+#define m1_p1  m_u.m_m1.m1p1
+#define m1_p2  m_u.m_m1.m1p2
+#define m1_p3  m_u.m_m1.m1p3
+
+#define m2_i1  m_u.m_m2.m2i1
+#define m2_i2  m_u.m_m2.m2i2
+#define m2_i3  m_u.m_m2.m2i3
+#define m2_l1  m_u.m_m2.m2l1
+#define m2_l2  m_u.m_m2.m2l2
+#define m2_p1  m_u.m_m2.m2p1
+
+#define m3_i1  m_u.m_m3.m3i1
+#define m3_i2  m_u.m_m3.m3i2
+#define m3_p1  m_u.m_m3.m3p1
+#define m3_ca1 m_u.m_m3.m3ca1
+
+#define m4_l1  m_u.m_m4.m4l1
+#define m4_l2  m_u.m_m4.m4l2
+#define m4_l3  m_u.m_m4.m4l3
+#define m4_l4  m_u.m_m4.m4l4
+#define m4_l5  m_u.m_m4.m4l5
+
+#define m5_c1  m_u.m_m5.m5c1
+#define m5_c2  m_u.m_m5.m5c2
+#define m5_i1  m_u.m_m5.m5i1
+#define m5_i2  m_u.m_m5.m5i2
+#define m5_l1  m_u.m_m5.m5l1
+#define m5_l2  m_u.m_m5.m5l2
+#define m5_l3  m_u.m_m5.m5l3
+
+#define m6_ca1 m_u.m_m6.m6ca1
+
+#define m7_i1  m_u.m_m7.m7i1
+#define m7_i2  m_u.m_m7.m7i2
+#define m7_i3  m_u.m_m7.m7i3
+#define m7_i4  m_u.m_m7.m7i4
+#define m7_p1  m_u.m_m7.m7p1
+#define m7_p2  m_u.m_m7.m7p2
+
+#define m8_i1  m_u.m_m8.m8i1
+#define m8_i2  m_u.m_m8.m8i2
+#define m8_p1  m_u.m_m8.m8p1
+#define m8_p2  m_u.m_m8.m8p2
+#define m8_p3  m_u.m_m8.m8p3
+#define m8_p4  m_u.m_m8.m8p4
+
+#define m9_i1  m_u.m_m9.m9i1
+#define m9_l1  m_u.m_m9.m9l1
+#define m9_t1  m_u.m_m9.m9t1
+
+#define mA_nr  m_u.m_mA.mAnr
+#define mA_dst m_u.m_mA.mAdst
+#define mA_ia  m_u.m_mA.mAia
+
+#define MSG1_FORMAT "source=%d type=%d m1i1=%d m1i2=%d m1i3=%d m1p1=%p m1p2=%p m1p3=%p \n"
+#define MSG2_FORMAT "source=%d type=%d m2i1=%d m2i2=%d m2i3=%d m2l1=%d m2l2=%d m2p1=%p\n"
+#define MSG3_FORMAT "source=%d type=%d m3i1=%d m3i2=%d m3p1=%p m3ca1=[%s]\n"
+#define MSG4_FORMAT "source=%d type=%d m4l1=%d m4l2=%d m4l3=%d m4l4=%d m4l5=%d\n"
+#define MSG5_FORMAT "source=%d type=%d m5c1=%c m5c2=%c m5i1=%d m5i2=%d m5l1=%d m5l2=%d m5l3=%d\n"
+#define MSG6_FORMAT "source=%d type=%d m6ca1=[%s]\n"
+#define MSG7_FORMAT "source=%d type=%d m7i1=%d m7i2=%d m7i3=%d m7i4=%d m7p1=%p m7p2=%p\n"
+#define MSG8_FORMAT "source=%d type=%d m8i1=%d m8i2=%d m8p1=%p m8p2=%p m8p3=%p m8p4=%p\n"
+#define MSG9_FORMAT "source=%d type=%d m9i1=%d m9l1=%d m9t1.tv_sec=%ld m9t1.tv_nsec=%ld\n"
+#define MSGA_FORMAT "source=%d type=%d dest=%d mAnr=%d mAia[0]=%d mAia[1]=%d mAia[2]=%d mAia[3]=%d\n"
+
+#define MSG1_FIELDS(p) 	p->m_source,p->m_type, p->m1_i1, p->m1_i2, p->m1_i3, p->m1_p1, p->m1_p2, p->m1_p3
+#define MSG2_FIELDS(p) 	p->m_source,p->m_type, p->m2_i1, p->m2_i2, p->m2_i3, p->m2_l1, p->m2_l2, p->m2_p1
+#define MSG3_FIELDS(p) 	p->m_source,p->m_type, p->m3_i1, p->m3_i2, p->m3_p1, p->m3_ca1
+#define MSG4_FIELDS(p) 	p->m_source,p->m_type, p->m4_l1, p->m4_l2, p->m4_l3, p->m4_l4, p->m4_l5
+#define MSG5_FIELDS(p) 	p->m_source,p->m_type, p->m5_c1, p->m5_c2, p->m5_i1, p->m5_i2, p->m5_l1, p->m5_l2, p->m5_l3
+#define MSG6_FIELDS(p) 	p->m_source,p->m_type, p->m6_ca1
+#define MSG7_FIELDS(p) 	p->m_source,p->m_type, p->m7_i1, p->m7_i2, p->m7_i3, p->m7_i4, p->m7_p1, p->m7p2
+#define MSG8_FIELDS(p) 	p->m_source,p->m_type, p->m8_i1, p->m8_i2, p->m8_p1, p->m8_p2, p->m8_p3, p->m8_p4
+#define MSG9_FIELDS(p) 	p->m_source,p->m_type, p->m9_i1, p->m9_l1, p->m9_t1.tv_sec, p->m9_t1.tv_nsec
+#define MSGA_FIELDS(p) 	p->m_source,p->m_type, p->mA_dst, p->mA_nr, p->mA_ia[0], p->mA_ia[1], p->mA_ia[2],p->mA_ia[3]
+
+#endif /* _IPC_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/kipc.h /usr/src/linux/kernel/minix/kipc.h
--- /home/jara/linux-2.6.32/kernel/minix/kipc.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/kipc.h	2013-10-07 19:23:00.000000000 -0300
@@ -0,0 +1,72 @@
+#ifndef IPC_H
+#define IPC_H
+
+/* This header file defines constants for MINIX inter-process communication.
+ * These definitions are used in the file proc.c.
+ */
+#include "com.h"
+
+/* Masks and flags for system calls. */
+#define SYSCALL_FUNC	0x000F	/* mask for system call function */
+#define SYSCALL_FLAGS   0x00F0  /* mask for system call flags */
+#define NON_BLOCKING    0x0010  /* do not block if target not ready */
+
+/* System call numbers that are passed when trapping to the kernel. The 
+ * numbers are carefully defined so that it can easily be seen (based on 
+ * the bits that are on) which checks should be done in sys_call().
+ */
+#define VMINIT		   	0	
+#define SEND		   	1	/* 0001 : blocking send */
+#define RECEIVE			2	/* 0010 : blocking receive */
+#define MOLVOID3			3
+#define NOTIFY		   	4	/* 0100 : nonblocking notify */
+// #define MOLVOID5		5
+#define SENDREC	 		5  	
+#define RCVRQST			6
+#define REPLY			7
+#define VMEND			8	/* End a VM 			*/
+#define BIND			9	/* Bind a process to IPC  	*/
+#define UNBIND			10	/* UnBind a process to IPC  	*/
+#define VMDUMP			11	/* Dump VM's tables		*/
+#define PROCDUMP		12	/* Dump a VM process table	*/
+#define GETPRIV			13	/* Get process priviledges	*/
+#define SETPRIV			14	/* Set process priviledges	*/
+#define VCOPY 			15   /* Virtual Copy			*/
+#define GETVMINFO		16	/* Get VM information		*/
+#define GETPROCINFO		17	/* Get Proc information		*/
+#define MOLVOID18		18  	/* used by mol_rmtbind()    = molbind(vmid,proc,nodeid) */
+#define RELAY			19	
+#define PROXYBIND		20	
+#define PROXYUNBIND		21	
+#define GETNODEINFO		22	
+#define PUT2LCL			23	/* Used by receiver proxy to send all kind of messages to local processes */	
+#define GET2RMT			24	/* Used by sender  proxy to send all kind of local messages to remote  processes */	
+#define ADDNODE			25	
+#define DELNODE			26	
+#define DRVSINIT		27	
+#define DRVSEND			28
+#define GETEP			29	/* Get process endpoint 	*/
+#define GETDRVSINFO		30	
+#define PROXYCONN		31	
+#define WAIT4BIND		32	
+#define MIGRATE			33	
+#define NODEUP			34	
+#define NODEDOWN		35	
+#define GETPROXYINFO	36	
+
+#define NR_MOLCALLS	 	37   /* Numero de IPCs/DRVMM Calls habilitadas */ 
+
+#define IPCMASK			0x08	/* mask to test IPC calls */
+
+#define MINIX_ECHO	   8	/* 1000 : echo a message */
+#define IPC_REQUEST	   5	/* 0101 : blocking request */
+#define IPC_REPLY	   6    /* 0110 : nonblocking reply */
+#define IPC_NOTIFY	   7    /* 0111 : nonblocking notification */
+#define IPC_RECEIVE	   9	/* 1001 : blocking receive */
+
+/* The following bit masks determine what checks that should be done. */
+#define CHECK_PTR       0xBB	/* 1011 1011 : validate message buffer */
+#define CHECK_DST       0x55	/* 0101 0101 : validate message destination */
+#define CHECK_DEADLOCK  0x93	/* 1001 0011 : check for deadlock */
+
+#endif /* IPC_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/limits.h /usr/src/linux/kernel/minix/limits.h
--- /home/jara/linux-2.6.32/kernel/minix/limits.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/limits.h	2013-07-12 16:43:00.000000000 -0300
@@ -0,0 +1,92 @@
+/* The <limits.h> header defines some basic sizes, both of the language types 
+ * (e.g., the number of bits in an integer), and of the operating system (e.g.
+ * the number of characters in a file name.
+ */
+
+#ifndef _LIMITS_H
+#define _LIMITS_H
+
+#define PATH_MAX           255	/* # chars in a path name */
+
+#ifdef ANULADO
+
+/* Definitions about chars (8 bits in MINIX, and signed). */
+#define CHAR_BIT           8	/* # bits in a char */
+#define CHAR_MIN        -128	/* minimum value of a char */
+#define CHAR_MAX         127	/* maximum value of a char */
+#define SCHAR_MIN       -128	/* minimum value of a signed char */
+#define SCHAR_MAX        127	/* maximum value of a signed char */
+#define UCHAR_MAX        255	/* maximum value of an unsigned char */
+#define MB_LEN_MAX         1	/* maximum length of a multibyte char */
+
+/* Definitions about shorts (16 bits in MINIX). */
+#define SHRT_MIN  (-32767-1)	/* minimum value of a short */
+#define SHRT_MAX       32767	/* maximum value of a short */
+#define USHRT_MAX     0xFFFF	/* maximum value of unsigned short */
+
+/* _EM_WSIZE is a compiler-generated symbol giving the word size in bytes. */
+#if _EM_WSIZE == 2
+#define INT_MIN   (-32767-1)	/* minimum value of a 16-bit int */
+#define INT_MAX        32767	/* maximum value of a 16-bit int */
+#define UINT_MAX      0xFFFF	/* maximum value of an unsigned 16-bit int */
+#endif
+
+#if _EM_WSIZE == 4
+#define INT_MIN (-2147483647-1)	/* minimum value of a 32-bit int */
+#define INT_MAX   2147483647	/* maximum value of a 32-bit int */
+#define UINT_MAX  0xFFFFFFFF	/* maximum value of an unsigned 32-bit int */
+#endif
+
+/*Definitions about longs (32 bits in MINIX). */
+#define LONG_MIN (-2147483647L-1)/* minimum value of a long */
+#define LONG_MAX  2147483647L	/* maximum value of a long */
+#define ULONG_MAX 0xFFFFFFFFL	/* maximum value of an unsigned long */
+
+#include <sys/dir.h>
+
+/* Minimum sizes required by the POSIX P1003.1 standard (Table 2-3). */
+#ifdef _POSIX_SOURCE		/* these are only visible for POSIX */
+#define _POSIX_ARG_MAX    4096	/* exec() may have 4K worth of args */
+#define _POSIX_CHILD_MAX     6	/* a process may have 6 children */
+#define _POSIX_LINK_MAX      8	/* a file may have 8 links */
+#define _POSIX_MAX_CANON   255	/* size of the canonical input queue */
+#define _POSIX_MAX_INPUT   255	/* you can type 255 chars ahead */
+#define _POSIX_NAME_MAX DIRSIZ	/* max. file name length */
+#define _POSIX_NGROUPS_MAX   0	/* supplementary group IDs are optional */
+#define _POSIX_OPEN_MAX     16	/* a process may have 16 files open */
+#define _POSIX_PATH_MAX    255	/* a pathname may contain 255 chars */
+#define _POSIX_PIPE_BUF    512	/* pipes writes of 512 bytes must be atomic */
+#define _POSIX_STREAM_MAX    8	/* at least 8 FILEs can be open at once */
+#define _POSIX_TZNAME_MAX    3	/* time zone names can be at least 3 chars */
+#define _POSIX_SSIZE_MAX 32767	/* read() must support 32767 byte reads */
+
+/* Values actually implemented by MINIX (Tables 2-4, 2-5, 2-6, and 2-7). */
+/* Some of these old names had better be defined when not POSIX. */
+#define _NO_LIMIT          100	/* arbitrary number; limit not enforced */
+
+#define NGROUPS_MAX          0	/* supplemental group IDs not available */
+#if _EM_WSIZE > 2
+#define ARG_MAX          16384	/* # bytes of args + environ for exec() */
+#else
+#define ARG_MAX           4096	/* args + environ on small machines */
+#endif
+#define CHILD_MAX    _NO_LIMIT	/* MINIX does not limit children */
+#define OPEN_MAX            30	/* # open files a process may have */
+#if 0			/* V1 file system */
+#define LINK_MAX      CHAR_MAX	/* # links a file may have */
+#else			/* V2 or better file system */
+#define LINK_MAX      SHRT_MAX	/* # links a file may have */
+#endif
+#define MAX_CANON          255	/* size of the canonical input queue */
+#define MAX_INPUT          255	/* size of the type-ahead buffer */
+#define NAME_MAX        DIRSIZ	/* # chars in a file name */
+#define PIPE_BUF          7168	/* # bytes in atomic write to a pipe */
+#define STREAM_MAX          20	/* must be the same as FOPEN_MAX in stdio.h */
+#define TZNAME_MAX           3	/* maximum bytes in a time zone name is 3 */
+#define SSIZE_MAX        32767	/* max defined byte count for read() */
+
+#endif /* _POSIX_SOURCE */
+
+#endif /* ANULADO */
+
+#endif /* _LIMITS_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/macros.h /usr/src/linux/kernel/minix/macros.h
--- /home/jara/linux-2.6.32/kernel/minix/macros.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/macros.h	2013-09-18 10:07:00.000000000 -0300
@@ -0,0 +1,18 @@
+/* Constants and macros for bit map manipulation. */
+#define MAP_CHUNK(map,bit) (map)[((bit)/BITCHUNK_BITS)]
+#define CHUNK_OFFSET(bit) ((bit)%BITCHUNK_BITS))
+#define GET_BIT(map,bit) ( MAP_CHUNK(map,bit) & (1 << CHUNK_OFFSET(bit) )
+#define SET_BIT(map,bit) ( MAP_CHUNK(map,bit) |= (1 << CHUNK_OFFSET(bit) )
+#define UNSET_BIT(map,bit) ( MAP_CHUNK(map,bit) &= ~(1 << CHUNK_OFFSET(bit) )
+
+#define get_node_bit(x,y) 	get_sys_bit(x,y)
+#define set_node_bit(x,y) 	set_sys_bit(x,y)
+#define unset_node_bit(x,y) 	unset_sys_bit(x,y)
+
+#define get_sys_bit(map,bit) \
+	( MAP_CHUNK(map.chunk,bit) & (1 << CHUNK_OFFSET(bit) )
+#define set_sys_bit(map,bit) \
+	( MAP_CHUNK(map.chunk,bit) |= (1 << CHUNK_OFFSET(bit) )
+#define unset_sys_bit(map,bit) \
+	( MAP_CHUNK(map.chunk,bit) &= ~(1 << CHUNK_OFFSET(bit) )
+#define NR_SYS_CHUNKS	BITMAP_CHUNKS(NR_SYS_PROCS)
diff -Naur /home/jara/linux-2.6.32/kernel/minix/moldebug.h /usr/src/linux/kernel/minix/moldebug.h
--- /home/jara/linux-2.6.32/kernel/minix/moldebug.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/moldebug.h	2013-10-12 15:57:00.000000000 -0300
@@ -0,0 +1,83 @@
+
+#define MOLDBG		1
+
+#define NODEBUG  	0x00000000
+#define DBGLVL0  	0x00000001
+#define GENERIC  	0x00000002
+#define INTERNAL  	0x00000004
+#define DBGLVL3  	0x00000008
+#define DBGLVL4  	0x00000010
+#define DBGLVL5  	0x00000020
+#define DBGLVL6  	0x00000040
+#define DBGLVL7  	0x00000080
+
+#define DBGPROCLOCK  0x00000100
+#define DBGVMLOCK  	 0x00000200
+#define DBGNODELOCK  0x00000400
+#define DBGTASKLOCK  0x00000800
+
+#define DBGMESSAGE	0x00001000
+#define DBGCMD		0x00002000
+#define DBGVCOPY	0x00004000
+#define DBGPARAMS	0x00008000
+
+#define DBGPROC		0x00010000
+#define DBGPRIV		0x00020000
+#define DBGPROCSEM	0x00040000
+#define DBGNODE		0x00080000
+#define DBGPROXYLOCK	0x00100000
+#define DBGREFCOUNT	0x00200000
+
+
+#ifdef MOLDBG
+ #define MOLDEBUG(dbglvl, text, args ...) \
+ do { \
+ if(dbglvl & drvs.d_dbglvl) \
+     printk("DEBUG %d:%s:%u: " \
+             text, current->pid, __FUNCTION__ ,__LINE__, ## args); \
+ }while(0);
+#else 
+#define MOLDEBUG(x, args ...)
+#endif 
+
+#if MOLPROFILING != 0
+#define MOLPROFVAR(tmp) uint64_t tmp;
+#else 
+#define MOLPROFVAR(tmp) 
+#endif 
+
+#if MOLPROFILING != 0
+#define MOLPROFINIT(tmp) tmp = get_cicles()
+#else 
+#define MOLPROFINIT(tmp) 
+#endif 
+
+#if MOLPROFILING != 0
+#define MOLPROFLOG(p,n) do { p->p_profiling[n]= get_cicles();  p->p_profline[n] = __LINE__;} while(0)
+#else 
+#define MOLPROFLOG(p,n)
+#endif 
+
+#if MOLPROFILING != 0
+#define MOLPROFPRT(p,tmp) do { \
+	int index;\
+	p->p_profiling[0]= tmp;\
+	p->p_profline[0]= 0;\
+	printk("PROF %d:%s:%u:0:%lld:0\n", \
+		current->pid, __FUNCTION__ ,p->p_profline[0], p->p_profiling[0]);\
+	for ( index = 1; index < MAX_PROF; index++) \
+	     printk("PROF %d:%s:%u:%d:%lld:%lld\n",\
+		current->pid, __FUNCTION__ ,p->p_profline[index], index, p->p_profiling[index],\
+		(p->p_profiling[index]- p->p_profiling[index-1]) ); \
+	} while(0);
+#else 
+#define MOLPROFPRT(p,tmp)
+#endif 
+
+
+
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/molerrno.h /usr/src/linux/kernel/minix/molerrno.h
--- /home/jara/linux-2.6.32/kernel/minix/molerrno.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/molerrno.h	2015-03-18 12:18:37.000000000 -0300
@@ -0,0 +1,153 @@
+
+#define _SIGN         -
+
+/* Here are the numerical values of the error numbers. */
+#define _NERROR               70  /* number of errors */  
+
+#define EMOLGENERIC      (_SIGN 99)  /* generic error */
+#define EMOLPERM         (_SIGN  1)  /* operation not permitted */
+#define EMOLNOENT        (_SIGN  2)  /* no such file or directory */
+#define EMOLSRCH         (_SIGN  3)  /* no such process */
+#define EMOLINTR         (_SIGN  4)  /* interrupted function call */
+#define EMOLIO           (_SIGN  5)  /* input/output error */
+#define EMOLNXIO         (_SIGN  6)  /* no such device or address */
+#define EMOL2BIG         (_SIGN  7)  /* arg list too long */
+#define EMOLNOEXEC       (_SIGN  8)  /* exec format error */
+#define EMOLBADF         (_SIGN  9)  /* bad file descriptor */
+#define EMOLCHILD        (_SIGN 10)  /* no child process */
+#define EMOLAGAIN        (_SIGN 11)  /* resource temporarily unavailable */
+#define EMOLNOMEM        (_SIGN 12)  /* not enough space */
+#define EMOLACCES        (_SIGN 13)  /* permission denied */
+#define EMOLFAULT        (_SIGN 14)  /* bad address */
+#define EMOLNOTBLK       (_SIGN 15)  /* Extension: not a block special file */
+#define EMOLBUSY         (_SIGN 16)  /* resource busy */
+#define EMOLEXIST        (_SIGN 17)  /* file exists */
+#define EMOLXDEV         (_SIGN 18)  /* improper link */
+#define EMOLNODEV        (_SIGN 19)  /* no such device */
+#define EMOLNOTDIR       (_SIGN 20)  /* not a directory */
+#define EMOLISDIR        (_SIGN 21)  /* is a directory */
+#define EMOLINVAL        (_SIGN 22)  /* invalid argument */
+#define EMOLNFILE        (_SIGN 23)  /* too many open files in system */
+#define EMOLMFILE        (_SIGN 24)  /* too many open files */
+#define EMOLNOTTY        (_SIGN 25)  /* inappropriate I/O control operation */
+#define EMOLTXTBSY       (_SIGN 26)  /* no longer used */
+#define EMOLFBIG         (_SIGN 27)  /* file too large */
+#define EMOLNOSPC        (_SIGN 28)  /* no space left on device */
+#define EMOLSPIPE        (_SIGN 29)  /* invalid seek */
+#define EMOLROFS         (_SIGN 30)  /* read-only file system */
+#define EMOLMLINK        (_SIGN 31)  /* too many links */
+#define EMOLPIPE         (_SIGN 32)  /* broken pipe */
+#define EMOLDOM          (_SIGN 33)  /* domain error    	(from ANSI C std) */
+#define EMOLRANGE        (_SIGN 34)  /* result too large	(from ANSI C std) */
+#define EMOLDEADLK       (_SIGN 35)  /* resource deadlock avoided */
+#define EMOLNAMETOOLONG  (_SIGN 36)  /* file name too long */
+#define EMOLNOLCK        (_SIGN 37)  /* no locks available */
+#define EMOLNOSYS        (_SIGN 38)  /* function not implemented */
+#define EMOLNOTEMPTY     (_SIGN 39)  /* directory not empty */
+#define EMOLLOOP         (_SIGN 40)  /* too many levels of symlinks detected */
+
+/* The following errors relate to networking. */
+#define EMOLPACKSIZE     (_SIGN 50)  /* invalid packet size for some protocol */
+#define EMOLOUTOFBUFS    (_SIGN 51)  /* not enough buffers left */
+#define EMOLBADIOCTL     (_SIGN 52)  /* illegal ioctl for device */
+#define EMOLBADMODE      (_SIGN 53)  /* badmode in ioctl */
+#define EMOLWOULDBLOCK   (_SIGN 54)
+#define EMOLBADDEST      (_SIGN 55)  /* not a valid destination address */
+#define EMOLDSTNOTRCH    (_SIGN 56)  /* destination not reachable */
+#define EMOLISCONN	      (_SIGN 57)  /* all ready connected */
+#define EMOLADDRINUSE    (_SIGN 58)  /* address in use */
+#define EMOLCONNREFUSED  (_SIGN 59)  /* connection refused */
+#define EMOLCONNRESET    (_SIGN 60)  /* connection reset */
+#define EMOLTIMEDOUT     (_SIGN 61)  /* connection timed out */
+#define EMOLURG	      (_SIGN 62)  /* urgent data present */
+#define EMOLNOURG	      (_SIGN 63)  /* no urgent data present */
+#define EMOLNOTCONN      (_SIGN 64)  /* no connection (yet or anymore) */
+#define EMOLSHUTDOWN     (_SIGN 65)  /* a write call to a shutdown connection */
+#define EMOLNOCONN       (_SIGN 66)  /* no such connection */
+#define EMOLAFNOSUPPORT  (_SIGN 67)  /* address family not supported */
+#define EMOLPROTONOSUPPORT (_SIGN 68) /* protocol not supported by AF */
+#define EMOLPROTOTYPE    (_SIGN 69)  /* Protocol wrong type for socket */
+#define EMOLINPROGRESS   (_SIGN 70)  /* Operation now in progress */
+#define EMOLADDRNOTAVAIL (_SIGN 71)  /* Can't assign requested address */
+#define EMOLALREADY      (_SIGN 72)  /* Connection already in progress */
+#define EMOLMSGSIZE      (_SIGN 73)  /* Message too long */
+#define EMOLNOTSOCK      (_SIGN 74)  /* Socket operation on non-socket */
+#define EMOLNOPROTOOPT   (_SIGN 75)  /* Protocol not available */
+
+/* The following are not POSIX errors, but they can still happen. 
+ * All of these are generated by the kernel and relate to message passing.
+ */
+#define EMOLLOCKED      (_SIGN 101)  /* can't send message due to deadlock */
+#define EMOLBADCALL     (_SIGN 102)  /* illegal system call number */
+#define EMOLBADSRCDST   (_SIGN 103)  /* bad source or destination process */
+#define EMOLCALLDENIED  (_SIGN 104)  /* no permission for system call */
+#define EMOLDEADSRCDST  (_SIGN 105)  /* source or destination is not alive */
+#define EMOLNOTREADY    (_SIGN 106)  /* source or destination is not ready */
+#define EMOLBADREQUEST  (_SIGN 107)  /* destination cannot handle request */
+#define EMOLSRCDIED     (_SIGN 108)  /* source just died */
+#define EMOLDSTDIED     (_SIGN 109)  /* destination just died */
+#define EMOLTRAPDENIED  (_SIGN 110)  /* IPC trap not allowed */
+#define EMOLDONTREPLY   (_SIGN 201)  /* pseudo-code: don't send a reply */
+
+/* the following ar MOL error codes */
+#define EMOLERRCODE 	(_SIGN 300) 
+#define EMOLBADNODEID 	(_SIGN 301)  /* Bad NODE ID */
+#define EMOLBADVMID 	(_SIGN 302)  /* Bad VM ID */
+#define EMOLVMNOTRUN 	(_SIGN 303)  /* The VM is not running */
+#define EMOLBADPROC  	(_SIGN 304)  /* Bad Process Number */
+#define EMOLBADPID  	(_SIGN 305)  /* Bad Process ID */
+#define EMOLENDPOINT  	(_SIGN 306)  /* Bad Process Endpoint */
+#define EMOLNOPROXY 	(_SIGN 307)  /* The IPC proxy is not running */
+#define EMOLRMTPROC 	(_SIGN 308)  /* The process is REMOTE */
+#define EMOLLCLPROC 	(_SIGN 309)  /* The process is LOCAL */
+#define EMOLNOTBIND 	(_SIGN 310)  /* The process has not BINDed */
+#define EMOLPROXYRUN 	(_SIGN 311)  /* The IPC proxy is already running */
+#define EMOLACKDST 	(_SIGN 312)  /* The IPC proxy sent local process a BAD destination ACK  */
+#define EMOLACKSRC 	(_SIGN 313)  /* The IPC proxy sent local process a BAD source ACK  */
+#define EMOLACKWAIT 	(_SIGN 314)  /* The IPC proxy sent local process that is not waiting for it  */
+#define EMOLNODEBUSY 	(_SIGN 315)  /* NODE is BUSY */
+#define EMOLNONODE 	(_SIGN 316)  /* NODE does not exists or is not in list */
+#define EMOLDRVSBUSY 	(_SIGN 317)  /* The DRVS is BUSY - Can't assign new local node ID */
+#define EMOLDRVSINIT 	(_SIGN 318)  /* The DRVS has not been initialized */
+#define EMOLNOVMNODE 	(_SIGN 319)  /* The NODE is not included into the VM list of nodes */
+#define EMOLPROCRUN 	(_SIGN 320)  /* The copy source/destination process is running */
+#define EMOLNOMSG 	(_SIGN 321)  /*  No message  - list empty	*/
+#define EMOLVMRUN 	(_SIGN 323)  /* The VM is already running */
+#define EMOLPROCSTS (_SIGN 324)  	/* Bad process status  */
+#define EMOLNODEFREE (_SIGN 325)  /* NODE is FREE */
+#define EMOLVMNODE 	(_SIGN 326)  /* The NODE is ALREADY included into the VM list of nodes */
+#define EMOLBADPROXY (_SIGN 327)  /* The NODE is ALREADY included into the VM list of nodes */
+#define EMOLONCOPY	 (_SIGN 328)  	/* The process is in ONCOPY state  */
+#define EMOLENQUEUED	 (_SIGN 329)  	/* The process descriptor is enqueued and cant be used */
+#define EMOLOVERRUN	 (_SIGN 330)  	/* An operation couse an overrun of some system resource */
+#define EMOLBADOWNER	 (_SIGN 331)  	/* A bind operation try to alloc a slot with other owner */
+#define EMOLMIGRATE 	 (_SIGN 332)  	/* The process is migrating */
+#define EMOLPROXYFREE 	 (_SIGN 333)  	/* The proxy pair is free  */
+#define EMOLGRPLEADER 	 (_SIGN 334)  	/* The process is a child thread, it is not the thread group leader */
+#define EMOLPRIVILEGES 	 (_SIGN 335)  	/* The process has no privileges for the call */
+#define EMOLBINDTYPE 	 (_SIGN 336)  	/* Bad BIND TYPE */
+#define EMOLSLOTUSED 	 (_SIGN 337)  	/* BIND the slot is already used */
+#define EMOLBADRANGE 	 (_SIGN 338)  	/* Bad range of a value  */
+#define EMOLBADVALUE 	 (_SIGN 339)  	/* Bad value  */
+#define EMOLBADDIR 		 (_SIGN 340)  	/* Bad Directory  */
+#define EMOLBADFILE		 (_SIGN 341)  	/* Bad File  */
+#define EMOLRSCBUSY		 (_SIGN 342)  	/* Resources busy  */
+#define EMOLNAMESIZE 	 (_SIGN 343)  	/* Name size too long  */
+#define EMOLALLOCMEM	 (_SIGN 344)  	/* Error on allocating memory  */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/mollib.h /usr/src/linux/kernel/minix/mollib.h
--- /home/jara/linux-2.6.32/kernel/minix/mollib.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/mollib.h	2014-06-17 09:12:03.000000000 -0300
@@ -0,0 +1,10 @@
+int getsysinfo(int who, int what, void *where);
+int molsyscall(int who, int syscallnr, message *msgptr);
+
+#define mol_getkinfo(ptr) 	getsysinfo(PM_PROC_NR, SI_KINFO, ptr)
+#define mol_getmachine(ptr) 	getsysinfo(PM_PROC_NR, SI_MACHINE, ptr)
+#define mol_getkproctab(ptr) 	getsysinfo(PM_PROC_NR, SI_KPROC_TAB, ptr)
+#define mol_getpmproctab(ptr) getsysinfo(PM_PROC_NR, SI_PMPROC_TAB, ptr)
+#define mol_getprivtab(ptr)   getsysinfo(PM_PROC_NR, SI_PRIV_TAB, ptr)
+#define mol_getslotstab(ptr)   getsysinfo(PM_PROC_NR, SI_SLOTS_TAB, ptr)
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/mol-macros.h /usr/src/linux/kernel/minix/mol-macros.h
--- /home/jara/linux-2.6.32/kernel/minix/mol-macros.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/mol-macros.h	2013-10-12 14:10:04.000000000 -0300
@@ -0,0 +1,590 @@
+/****************************************************************/
+/*			MOL MACROS   			*/
+/****************************************************************/
+
+/*----------------------------------------------------------------*/
+/*				ERROR CHECKING MACROS 				*/
+/*----------------------------------------------------------------*/
+
+#define CHECK_VMID(vmid) 	if( vmid < 0 || vmid >= drvs.d_nr_vms) 	ERROR_RETURN(EMOLBADVMID);
+#define CHECK_NODEID(nodeid) 	if( nodeid < 0 || nodeid >= drvs.d_nr_nodes) 	ERROR_RETURN(EMOLBADNODEID);
+#define CHECK_PID(pid, p_ptr)	if (pid != p_ptr->p_usr.p_lpid) 		ERROR_RETURN(EMOLBADPID);
+
+#define CHECK_IF_VM_RUN(v_ptr) 	if( v_ptr->vm_usr.vm_flags) 			ERROR_RUNLOCK_VM(v_ptr,EMOLVMNOTRUN);
+
+#define VM_PROC(vm_ptr,i)	((struct proc *) (((char *) vm_ptr->vm_proc) + ( i << log2_proc_size)))
+#define IT_IS_REMOTE(proc)	test_bit(BIT_REMOTE, &proc->p_usr.p_rts_flags)
+#define IT_IS_LOCAL(proc)	!test_bit(BIT_REMOTE, &proc->p_usr.p_rts_flags)
+
+#define ENDPOINT2PTR(vm_ptr, ep) VM_PROC(vm_ptr,(_ENDPOINT_P(ep)+vm_ptr->vm_usr.vm_nr_tasks))
+#define NBR2PTR(vm_ptr, nr)	VM_PROC(vm_ptr,(nr+vm_ptr->vm_usr.vm_nr_tasks))
+#define DRVS_NOT_INIT()		(atomic_read(&local_nodeid) == DRVS_NO_INIT)
+
+#define VM_INCREF(v)		kref_get(&v->vm_kref); 
+#define VM_DECREF(v)		kref_put(&v->vm_kref, vm_release); 
+
+#define NODE2SPROXY(n) 	  &proxies[node[n].n_usr.n_proxies].px_sproxy
+#define NODE2RPROXY(n) 	  &proxies[node[n].n_usr.n_proxies].px_rproxy
+
+#define KREF_GET(rc) do { \
+  	MOLDEBUG(DBGREFCOUNT ,"KREF_GET counter=%d\n",atomic_read(rc.refcount));\
+	kref_get(rc);\
+}while(0);
+
+#define KREF_PUT(rc, function) do { \
+  	MOLDEBUG(DBGREFCOUNT ,"KREF_PUT counter=%d\n",atomic_read(rc.refcount));\
+	kref_put(rc, function);\
+}while(0);
+
+/*----------------------------------------------------------------*/
+/*				MACROS 				*/
+/*----------------------------------------------------------------*/
+#define ERROR_PRINT(rcode) \
+ do { \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__,rcode); \
+ }while(0);
+ 
+#define ERROR_RETURN(rcode) \
+ do { \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__,rcode); \
+	return(rcode); \
+ }while(0);
+
+
+#define ERROR_RUNLOCK_VM(v,rcode) \
+ do { \
+	RUNLOCK_VM(v); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+
+#define ERROR_WUNLOCK_VM(v,rcode) \
+ do { \
+	WUNLOCK_VM(v); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+ 
+#define ERROR_RUNLOCK_PROC(p,rcode) \
+ do { \
+	RUNLOCK_PROC(p); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+
+#define ERROR_WUNLOCK_PROC(p,rcode) \
+ do { \
+	WUNLOCK_PROC(p); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+
+#define ERROR_UNLOCK_TASK(task, rcode) \
+ do { \
+	UNLOCK_TASK(task);\
+	ERROR_RETURN(rcode);\
+ }while(0);
+ 
+#define LOCAL_PROC_UP(proc, rcode) \
+ do { \
+	inherit_cpu(proc) \
+ 	proc->p_rcode = rcode; \
+MOLDEBUG(DBGPROCSEM,"BEFORE UP lpid=%d p_sem=%d rcode=%d\n",proc->p_usr.p_lpid,proc->p_pseudosem, rcode); \
+	proc->p_pseudosem += 1; \
+	wake_up_interruptible(&proc->p_wqhead); \
+}while(0);
+
+#define READY_UP_SHUTDOWN(proc) \
+ do { \
+ 	inherit_cpu(proc) \
+   	proc->p_rcode = EMOLSHUTDOWN; \
+MOLDEBUG(DBGPROCSEM,"BEFORE UP lpid=%d p_sem=%d\n",proc->p_usr.p_lpid,proc->p_pseudosem); \
+	proc->p_pseudosem += 1; \
+	wake_up_interruptible(&proc->p_wqhead); \
+	}\
+ }while(0);
+
+#define READY_UP_RCODE(proc, cmd, rcode) \
+ do { \
+ 	inherit_cpu(proc) \
+	proc->p_rcode = rcode; \
+MOLDEBUG(DBGPROCSEM,"BEFORE UP lpid=%d p_sem=%d\n",proc->p_usr.p_lpid,proc->p_pseudosem); \
+	proc->p_pseudosem += 1; \
+	wake_up_interruptible(&proc->p_wqhead); \
+ }while(0); 
+
+#define BUILD_NOTIFY_MSG(v, p, ep) \
+ do { \
+	p->p_message.m_source 	= ep;\
+	p->p_message.m_type 	= NOTIFY_FROM(p->p_usr.p_nr+v->vm_usr.vm_nr_tasks);\
+	p->p_message.NOTIFY_TIMESTAMP = current_kernel_time();\
+	switch (p->p_usr.p_nr) {\
+		case HARDWARE:\
+		p->p_message.NOTIFY_ARG = (long) p->p_priv.s_int_pending;\
+			p->p_priv.s_int_pending = 0;\
+			break;\
+		case SYSTEM:\
+			p->p_message.NOTIFY_ARG = (long) p->p_priv.s_sig_pending;\
+			p->p_priv.s_sig_pending = 0;\
+			break;\
+		}\
+ }while(0); 
+
+
+#define WLOCK_PROC2(p,q)		\
+do {\
+	if( p->p_usr.p_nr < q->p_usr.p_nr) { \
+		WLOCK_PROC(p);\
+		WLOCK_PROC(q);\
+	}else{\
+		WLOCK_PROC(q);\
+		WLOCK_PROC(p);\
+	}\
+}while(0);
+
+#define WUNLOCK_PROC2(p,q)	\
+do {\
+	WUNLOCK_PROC(p);\
+	WUNLOCK_PROC(q);\
+}while(0); 
+
+#define WLOCK_PROC3(p,q,r)		\
+do {\
+	if( p->p_usr.p_nr < q->p_usr.p_nr) { \
+		if( r->p_usr.p_nr < q->p_usr.p_nr) {\
+			WLOCK_PROC2(p,r);\
+			WLOCK_PROC(q);\
+		}else{ \
+			WLOCK_PROC2(p,q);\
+			WLOCK_PROC(r);\
+		}\
+	}else{\
+		if( r->p_usr.p_nr < p->p_usr.p_nr) {\
+			WLOCK_PROC2(q,r);\
+			WLOCK_PROC(p);\
+		}else{ \
+			WLOCK_PROC2(q,p);\
+			WLOCK_PROC(r);\
+		}\
+	}\
+}while(0);
+
+#define WUNLOCK_PROC3(p,q,r)	\
+do {\
+	WUNLOCK_PROC(p);\
+	WUNLOCK_PROC(q);\
+	WUNLOCK_PROC(r);\
+}while(0);
+
+#define LOCK_TASK(task) 	\
+do {\
+	mutex_lock(&task->proc_mutex);\
+MOLDEBUG(DBGTASKLOCK ,"LOCK_TASK pid=%d count=%d\n",task->pid,atomic_read(&task->proc_mutex.count));\
+}while(0);
+
+#define UNLOCK_TASK(task) 	\
+do {\
+MOLDEBUG(DBGTASKLOCK ,"UNLOCK_TASK pid=%d count=%d\n",task->pid,atomic_read(&task->proc_mutex.count));\
+	mutex_unlock(&task->proc_mutex);\
+}while(0);
+
+#define CHECK_ENDPOINT(t, p_ptr,ep) \
+do {\
+	if( p_ptr->p_usr.p_endpoint != ep) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLENDPOINT);\
+	}\
+}while(0)
+
+#define CHECK_IF_NULL(t, p_ptr)	\
+do {\
+	if( p_ptr == NULL ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLBADPROC);\
+	}\
+}while(0)
+
+#define CHECK_IF_REMOTE(t, p_ptr)	\
+do {\
+	if( IT_IS_REMOTE(p_ptr) ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLRMTPROC);\
+	}\
+}while(0)
+
+#define CHECK_IF_LOCAL(t, p_ptr)	\
+do {\
+	if( !IT_IS_REMOTE(p_ptr) ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLLCLPROC);\
+	}\
+}while(0)
+
+#define CHECK_IF_EMPTY(t, p_ptr)	\
+do {\
+	if( p_ptr->p_usr.p_rts_flags == SLOT_FREE ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLDSTDIED);\
+	}\
+}while(0)
+
+#define CHECK_P_NR(t, v_ptr, p_nr)		\
+do {\
+	if( p_nr < (-v_ptr->vm_usr.vm_nr_tasks) || p_nr >= v_ptr->vm_usr.vm_nr_procs) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLRANGE);\
+	}\
+}while(0)
+
+
+/*--------------------------------------------------------- USE_PROC_RWLOCKS ---------------------------------------*/
+#if LOCK_PROC_TYPE == USE_PROC_RWLOCK
+
+#define RUNLOCK_PROC(p)	\
+	do {\
+MOLDEBUG(DBGPROCLOCK,"RUNLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint, atomic_read(&p->p_mutex.count));\
+		read_unlock(&p->p_rwlock);\
+	}while(0); 
+
+#define WUNLOCK_PROC(p)	\
+do {\
+MOLDEBUG(DBGPROCLOCK,"WUNLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+	write_unlock(&p->p_rwlock);\
+}while(0); 
+
+#define WLOCK_PROC(p)		\
+do {\
+	write_lock(&p->p_rwlock);\
+MOLDEBUG(DBGPROCLOCK,"WLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+}while(0);
+
+#define RLOCK_PROC(p)		\
+do {\
+	read_lock(&p->p_rwlock);\
+MOLDEBUG(DBGPROCLOCK,"RLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+	 	ret = copy_to_user(uaddr, kaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#define COPY_FROM_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+ 	ret = copy_from_user(kaddr, uaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#define COPY_USR2USR_PROC(ret, endpoint, src, srcaddr, dst, dstaddr, len )		\
+do {\
+		preempt_enable();\
+	ret = copy_usr2usr(endpoint, src, srcaddr, dst, dstaddr, len);\
+		preempt_disable();\
+}while(0)
+
+
+#else 
+/*--------------------------------------------------------- USE_PROC_MUTEX  ---------------------------------------*/
+#define RUNLOCK_PROC(p)	\
+	do {\
+MOLDEBUG(DBGPROCLOCK,"RUNLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint, atomic_read(&p->p_mutex.count));\
+		mutex_unlock(&p->p_mutex);\
+	}while(0); 
+
+#define WUNLOCK_PROC(p)	\
+do {\
+MOLDEBUG(DBGPROCLOCK,"WUNLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+	mutex_unlock(&p->p_mutex);\
+}while(0); 
+
+#define WLOCK_PROC(p)		\
+do {\
+	mutex_lock(&p->p_mutex);\
+MOLDEBUG(DBGPROCLOCK,"WLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+}while(0);
+
+#define RLOCK_PROC(p)		\
+do {\
+	mutex_lock(&p->p_mutex);\
+MOLDEBUG(DBGPROCLOCK,"RLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+	 	ret = copy_to_user(uaddr, kaddr, len);\
+}while(0)
+
+#define COPY_FROM_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+ 	ret = copy_from_user(kaddr, uaddr, len);\
+}while(0)
+
+#define COPY_USR2USR_PROC(ret, endpoint, src, srcaddr, dst, dstaddr, len )		\
+do {\
+	ret = copy_usr2usr(endpoint, src, srcaddr, dst, dstaddr, len);\
+}while(0)
+
+#endif
+
+#define LOCK_ALL_PROCS(vm_ptr, proc_ptr, i) do { \
+MOLDEBUG(INTERNAL,"Locking all processes of VM=%d\n",vm_ptr->vm_usr.vm_vmid); \
+	for (i = 0; i < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs); i++) {\
+		tmp_ptr = VM_PROC(vm_ptr,i);\
+		WLOCK_PROC(tmp_ptr); \
+	}\
+}while(0)
+
+#define UNLOCK_ALL_PROCS(vm_ptr, proc_ptr,i) do{ \
+MOLDEBUG(INTERNAL,"Unlocking all processes of VM=%d\n",vm_ptr->vm_usr.vm_vmid);\
+	for (i = 0; i < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs); i++) {\
+		tmp_ptr = VM_PROC(vm_ptr,i);\
+		WUNLOCK_PROC(tmp_ptr); \
+	}\
+}while(0)
+
+#define FOR_EACH_PROC(vm_ptr, i) \
+	for (i = 0; i < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs); i++) \
+
+
+/*--------------------------------------------------------- USE_VM_RWLOCKS ---------------------------------------*/
+#if LOCK_VM_TYPE == USE_VM_RWLOCK
+#define WUNLOCK_VM(v)	\
+do {\
+MOLDEBUG(DBGVMLOCK,"WUNLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+	write_unlock(&v->vm_rwlock);\
+}while(0); 
+
+#define RUNLOCK_VM(v)	\
+do {\
+MOLDEBUG(DBGVMLOCK,"RUNLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+	read_unlock(&v->vm_rwlock);\
+}while(0); 
+	
+#define WLOCK_VM(v)		\
+do {\
+	write_lock(&v->vm_rwlock);\
+MOLDEBUG(DBGVMLOCK,"WLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+}while(0);
+
+#define RLOCK_VM(v)		\
+do {\
+	read_lock(&v->vm_rwlock);\
+MOLDEBUG(DBGVMLOCK,"RLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_VM(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#else
+/*--------------------------------------------------------- USE_VM_MUTEX  ---------------------------------------*/
+#define WUNLOCK_VM(v)	\
+do {\
+MOLDEBUG(DBGVMLOCK,"WUNLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+	mutex_unlock(&v->vm_mutex);\
+}while(0); 
+
+#define RUNLOCK_VM(v)	\
+do {\
+MOLDEBUG(DBGVMLOCK,"RUNLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+	mutex_unlock(&v->vm_mutex);\
+}while(0); 
+	
+#define WLOCK_VM(v)		\
+do {\
+	mutex_lock(&v->vm_mutex);\
+MOLDEBUG(DBGVMLOCK,"WLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+}while(0);
+
+#define RLOCK_VM(v)		\
+do {\
+	mutex_lock(&v->vm_mutex);\
+MOLDEBUG(DBGVMLOCK,"RLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_VM(ret, kaddr, uaddr, len )		\
+do {\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+}while(0)
+
+#endif
+
+/*--------------------------------------------------------- USE_DRVS_RWLOCKS ---------------------------------------*/
+#if LOCK_DRVS_TYPE == USE_DRVS_RWLOCK
+#define WUNLOCK_DRVS	\
+do {\
+	write_unlock(&drvs_rwlock);\
+}while(0); 
+
+#define RUNLOCK_DRVS	\
+do {\
+	read_unlock(&drvs_rwlock);\
+}while(0); 
+	
+#define WLOCK_DRVS		\
+do {\
+	write_lock(&drvs_rwlock);\
+}while(0);
+
+#define RLOCK_DRVS		\
+do {\
+	read_lock(&drvs_rwlock);\
+}while(0);
+
+
+#else
+/*--------------------------------------------------------- USE_DRVS_MUTEX  ---------------------------------------*/
+#define WUNLOCK_DRVS	\
+do {\
+	mutex_unlock(&drvs_mutex);\
+}while(0); 
+
+#define RUNLOCK_DRVS	\
+do {\
+	mutex_unlock(&drvs_mutex);\
+}while(0); 
+	
+#define WLOCK_DRVS		\
+do {\
+	mutex_lock(&drvs_mutex);\
+}while(0);
+
+#define RLOCK_DRVS		\
+do {\
+	mutex_lock(&drvs_mutex);\
+}while(0);
+
+
+#endif
+
+/*--------------------------------------------------------- USE_NODE_RWLOCKS ---------------------------------------*/
+#if LOCK_NODE_TYPE == USE_NODE_RWLOCK
+#define WUNLOCK_NODE(n)	\
+do {\
+MOLDEBUG(DBGNODELOCK,"WUNLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+	write_unlock(&n->n_rwlock);\
+}while(0); 
+
+#define RUNLOCK_NODE(n)	\
+do {\
+MOLDEBUG(DBGNODELOCK,"RUNLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+	read_unlock(&n->n_rwlock);\
+}while(0); 
+	
+#define WLOCK_NODE(n)		\
+do {\
+	write_lock(&n->n_rwlock);\
+MOLDEBUG(DBGNODELOCK,"WLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+}while(0);
+
+#define RLOCK_NODE(n)		\
+do {\
+	read_lock(&n->n_rwlock);\
+MOLDEBUG(DBGNODELOCK,"RLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_NODE(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#else
+/*--------------------------------------------------------- USE_NODE_MUTEX  ---------------------------------------*/
+#define WUNLOCK_NODE(n)	\
+do {\
+MOLDEBUG(DBGNODELOCK,"WUNLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+	mutex_unlock(&n->n_mutex);\
+}while(0); 
+
+#define RUNLOCK_NODE(n)	\
+do {\
+MOLDEBUG(DBGNODELOCK,"RUNLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+	mutex_unlock(&n->n_mutex);\
+}while(0); 
+	
+#define WLOCK_NODE(n)		\
+do {\
+	mutex_lock(&n->n_mutex);\
+MOLDEBUG(DBGNODELOCK,"WLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+}while(0);
+
+#define RLOCK_NODE(n)		\
+do {\
+	mutex_lock(&n->n_mutex);\
+MOLDEBUG(DBGNODELOCK,"RLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_NODE(ret, kaddr, uaddr, len )		\
+do {\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+}while(0)
+
+#endif
+
+/*--------------------------------------------------------- USE_PROXY_RWLOCKS ---------------------------------------*/
+#if LOCK_PROXY_TYPE == USE_PROXY_RWLOCK
+#define WUNLOCK_PROXY(px)	\
+do {\
+MOLDEBUG(DBGPROXYLOCK,"WUNLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+	write_unlock(&px->px_rwlock);\
+}while(0); 
+
+#define RUNLOCK_PROXY(px)	\
+do {\
+MOLDEBUG(DBGPROXYLOCK,"RUNLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+	read_unlock(&px->px_rwlock);\
+}while(0); 
+	
+#define WLOCK_PROXY(px)		\
+do {\
+	write_lock(&px->px_rwlock);\
+MOLDEBUG(DBGPROXYLOCK,"WLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+}while(0);
+
+#define RLOCK_PROXY(px)		\
+do {\
+	read_lock(&px->px_rwlock);\
+MOLDEBUG(DBGPROXYLOCK,"RLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+}while(0);
+
+
+#else
+/*--------------------------------------------------------- USE_PROXY_MUTEX  ---------------------------------------*/
+#define WUNLOCK_PROXY(px)	\
+do {\
+MOLDEBUG(DBGPROXYLOCK,"WUNLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+	mutex_unlock(&px->px_mutex);\
+}while(0); 
+
+#define RUNLOCK_PROXY(px)	\
+do {\
+MOLDEBUG(DBGPROXYLOCK,"RUNLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+	mutex_unlock(&px->px_mutex);\
+}while(0); 
+	
+#define WLOCK_PROXY(px)		\
+do {\
+	mutex_lock(&px->px_mutex);\
+MOLDEBUG(DBGPROXYLOCK,"WLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+}while(0);
+
+#define RLOCK_PROXY(px)		\
+do {\
+	mutex_lock(&px->px_mutex);\
+MOLDEBUG(DBGPROXYLOCK,"RLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+}while(0);
+
+#endif
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/node_usr.h /usr/src/linux/kernel/minix/node_usr.h
--- /home/jara/linux-2.6.32/kernel/minix/node_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/node_usr.h	2013-10-10 11:13:00.000000000 -0300
@@ -0,0 +1,35 @@
+#ifndef NODE_USR_H
+#define NODE_USR_H
+
+#define MAXNODENAME	16
+
+
+#define NODE_BIT_ATTACHED		1	/* The node is attached to a pair of proxies 	*/
+#define NODE_BIT_SCONNECTED		2	/* The proxy sender is connected		*/
+#define NODE_BIT_RCONNECTED		3	/* The proxy receiver is connected		*/
+
+#define NODE_FREE		0
+#define NODE_ATTACHED	(1<<NODE_BIT_ATTACHED)
+#define NODE_SCONNECTED	(1<<NODE_BIT_SCONNECTED)
+#define NODE_RCONNECTED	(1<<NODE_BIT_RCONNECTED)
+
+struct node_usr {
+	int			n_nodeid;
+	volatile unsigned long	n_flags;
+	int			n_proxies;		/* proxies ID for this node		*/
+	unsigned long int  	n_vms; 			/* BITMAP 				*/
+	struct timespec 	n_stimestamp;		/* timestamp of the last sent  msg	*/
+	struct timespec 	n_rtimestamp;		/* timestamp of the last received msg	*/
+	char			n_name[MAXNODENAME];
+};
+
+typedef struct node_usr node_usr_t;
+
+#define NODE_USR_FORMAT "n_nodeid=%d n_proxies=%d n_flags=%lX n_vms=%lX n_name=%s\n"
+#define NODE_USR_FIELDS(p) p->n_nodeid, p->n_proxies, p->n_flags, p->n_vms, p->n_name
+
+#define NODE_TIME_FORMAT "n_nodeid=%d n_name=%s n_stime_sec=%ld n_stime_nsec=%ld n_rtime_sec=%ld n_rtime_nsec=%ld\n"
+#define NODE_TIME_FIELDS(p) p->n_nodeid, p->n_name, p->n_stimestamp.tv_sec, p->n_stimestamp.tv_nsec, \
+			p->n_rtimestamp.tv_sec, p->n_rtimestamp.tv_nsec
+
+#endif /* NODE_USR_H */
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/kernel/minix/priv.h /usr/src/linux/kernel/minix/priv.h
--- /home/jara/linux-2.6.32/kernel/minix/priv.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/priv.h	2013-05-30 09:50:00.000000000 -0300
@@ -0,0 +1,23 @@
+
+#ifndef PRIV_H
+#define PRIV_H
+
+#define SYS_PROC	0x10	/* system processes have own priv structure */
+
+/* =================================*/
+/* USER SPACE INCLUDE FILES         */
+/* =================================*/
+#include "priv_usr.h"
+
+struct priv {
+
+  priv_usr_t s_usr;		/* Privileges user fields 		*/
+
+  sys_map_t s_notify_pending; /* bit map with pending notifications */
+  irq_id_t s_int_pending;	/* pending hardware interrupts */
+  ksigset_t s_sig_pending;	/* pending signals */
+
+};
+typedef struct priv priv_t;
+
+#endif /* PRIV_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/priv_usr.h /usr/src/linux/kernel/minix/priv_usr.h
--- /home/jara/linux-2.6.32/kernel/minix/priv_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/priv_usr.h	2014-05-02 15:09:14.000000000 -0300
@@ -0,0 +1,30 @@
+#ifndef PRIV_USR_H
+#define PRIV_USR_H
+
+#define USER_PRIV	0x0000
+#define SERVER_PRIV	0x0001
+#define TASK_PRIV	0x0002
+#define SYSTEM_PRIV	0x0003
+#define KERNEL_PRIV	0x0004
+#define PROXY_PRIV	0x0005
+
+struct priv_usr {
+
+  sys_id_t s_id;		/* index of this system structure */
+  int	s_warn;			/* process to warn when the process exit/fork */
+  int	s_level;		/* privilege level		*/
+
+  short s_trap_mask;		/* allowed system call traps */
+  sys_map_t s_ipc_from;		/* allowed callers to receive from */
+  sys_map_t s_ipc_to;		/* allowed destination processes */
+  long s_call_mask;		/* allowed kernel calls */
+
+  moltimer_t s_alarm_timer;	/* synchronous alarm timer */ 
+
+};
+typedef struct priv_usr priv_usr_t;
+
+#define PRIV_USR_FORMAT "s_id=%d s_warn=%d s_level=%d trap=%X call=%X\n"
+#define PRIV_USR_FIELDS(p) p->s_id, p->s_warn, p->s_level,(unsigned int)p->s_trap_mask,(unsigned int) p->s_call_mask
+
+#endif /* PRIV_USR_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/proc.h /usr/src/linux/kernel/minix/proc.h
--- /home/jara/linux-2.6.32/kernel/minix/proc.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/proc.h	2013-10-08 15:40:00.000000000 -0300
@@ -0,0 +1,103 @@
+#ifndef PROC_H
+#define PROC_H
+
+/* =================================*/
+/* USER SPACE INCLUDE FILES         */
+/* =================================*/
+#include "types.h"
+#include "macros.h"
+#include "const.h"
+#include "proc_usr.h"
+#include "proc_sts.h"
+#include "vm_usr.h"
+#include "node_usr.h"
+#include "priv.h"
+
+/* =================================*/
+/* PROCESS DESCRIPTOR	             */
+/* =================================*/
+struct proc {
+
+  proc_usr_t	 	p_usr;
+
+  char *p_name_ptr;		/* for local processes is pointer to task_ptr->comm */		
+  int p_rcode;			/* return code of an IPC operation */
+
+  priv_t  p_priv;		/* privileges structure */
+
+  struct list_head p_list;	/* head of list of procs wishing to send 	*/
+  struct list_head p_link;	/* link of the list of procceses whishing to send to other process */
+
+  struct list_head p_mlist;	/* head of list of procs waiting to send to a migrating process 	*/
+  struct list_head p_mlink;	/* link of the list of procceses whishing to send to migrating process */
+  
+  message p_message;		/* buffer to store messages  			*/
+  message *p_umsg;		/* Pointer to message buffer in user space */
+  wait_queue_head_t p_wqhead;	/* LINUX process wait queue head		*/
+  int p_pseudosem;		/* pseudo semaphore 				*/	
+  cmd_t	   p_rmtcmd;	/* remote command 				*/ 
+
+// struct timer_list p_timer; 	/* IPC timeout TIMER	*/
+
+  #if LOCK_PROC_TYPE == USE_PROC_RWLOCK
+  rwlock_t   	p_rwlock;	/* LINUX spinlock to protect this proc	*/	
+  #else	/* USE_PROC_MUTEX*/
+   struct mutex p_mutex;	/* LINUX mutex to protect this proc	*/	
+  #endif 
+  
+  struct task_struct *p_task;	/* pointer to LINUX task structure */
+
+  #if MOLPROFILING != 0
+	int		 p_profline[MAX_PROF];
+	uint64_t p_profiling[MAX_PROF];
+  #endif
+
+};
+typedef struct proc proc_t;
+
+
+/* =================================*/
+/* CLUSTER NODE DESCRIPTOR	      */
+/* =================================*/
+struct cluster_node {
+
+	node_usr_t n_usr;
+	struct proc_dir_entry *n_node_dir;		/* nodeX directory under /proc/drvs 	*/
+	struct proc_dir_entry *n_info_entry;		/* info file under /proc/drvs/nodeX 	*/
+	struct proc_dir_entry *n_stats_entry;		/* stats file under /proc/drvs/nodeX 	*/
+#if LOCK_NODE_TYPE == USE_NODE_RWLOCK
+	rwlock_t   	n_rwlock;	/* LINUX spinlock to protect this NODE	*/	
+#else	/* USE_PROC_MUTEX*/
+	struct mutex n_mutex;	/* LINUX mutex to protect this NODE	*/	
+#endif
+};
+typedef struct cluster_node cluster_node_t;
+
+/* =================================*/
+/* VIRTUAL MACHINE DESCRIPTOR	      */
+/* =================================*/
+struct VM_struct {
+
+	VM_usr_t vm_usr;
+
+	struct kref vm_kref;
+
+#if LOCK_VM_TYPE == USE_VM_RWLOCK
+	rwlock_t  vm_rwlock;
+#else	/* USE_VM_MUTEX*/
+ 	struct mutex vm_mutex;
+#endif
+
+	struct proc_dir_entry *vm_VM_dir;		/* VMx directory under /proc/drvs */
+	struct proc_dir_entry *vm_info_entry;	/* /proc/drvs/VMx/info */
+	struct proc_dir_entry *vm_procs_entry;	/* /proc/drvs/VMx/procs */
+	struct proc_dir_entry *vm_stats_entry;	/* /proc/drvs/VMx/stats */
+
+	struct proc *vm_proc;			/* Dynamic memory pointer to VM process table */ 
+	struct proc **vm_sid2proc;
+};
+typedef struct VM_struct VM_desc_t;
+
+
+	
+#endif /* PROC_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/proc_sts.h /usr/src/linux/kernel/minix/proc_sts.h
--- /home/jara/linux-2.6.32/kernel/minix/proc_sts.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/proc_sts.h	2014-09-03 10:03:22.000000000 -0300
@@ -0,0 +1,58 @@
+#ifndef PROC_STS_H
+#define PROC_STS_H
+
+/* =================================*/
+/* PROCESS DESCRIPTOR STATUS        */
+/* =================================*/
+
+/* Bits for the runtime flags. A process is runnable iff p_rts_flags == 0. 	*/
+#define PROC_RUNNING	0x00000000
+
+#define BIT_SLOT_FREE	0
+#define BIT_NO_MAP	1
+#define BIT_SENDING	2
+#define BIT_RECEIVING	3
+
+#define BIT_SIGNALED	4	
+#define BIT_SIG_PENDING	5
+#define BIT_P_STOP	6
+#define BIT_NO_PRIV	7
+
+#define BIT_NO_PRIORITY 8
+#define BIT_NO_ENDPOINT 9
+#define BIT_ONCOPY	10
+#define BIT_MIGRATE	11
+
+#define BIT_REMOTE	12
+#define BIT_RMTOPER	13		
+
+#define BIT_WAITMIGR	15
+		
+#define BIT_DONATING	16
+
+enum proc_status {
+		SLOT_FREE	= (1<<BIT_SLOT_FREE),	/* process slot is free 				*/
+		NO_MAP		= (1<<BIT_NO_MAP),		/* keeps unmapped forked child from running 	*/
+		SENDING		= (1<<BIT_SENDING),		/* process blocked trying to send 			*/
+		RECEIVING	= (1<<BIT_RECEIVING), 	/* process blocked trying to receive 		*/
+		
+		SIGNALED	= (1<<BIT_SIGNALED),	/* set when new kernel signal arrives 		*/
+		SIG_PENDING	= (1<<BIT_SIG_PENDING),	/* unready while signal being processed 	*/
+		P_STOP		= (1<<BIT_P_STOP),		/* set when process is being traced 		*/
+		NO_PRIV		= (1<<BIT_NO_PRIV),		/* keep forked system process from running 	*/
+		
+		NO_PRIORITY	= (1<<BIT_NO_PRIORITY),	/* process has been stopped 			*/
+		NO_ENDPOINT = (1<<BIT_NO_ENDPOINT),	/* process cannot send or receive messages 	*/
+		ONCOPY	    = (1<<BIT_ONCOPY), 		/* A copy request is pending				*/
+		MIGRATING   = (1<<BIT_MIGRATE),		/* the process is waiting that a process ends its MIGRATION */
+		
+		REMOTE	    = (1<<BIT_REMOTE),		/* the process is running on a remote host	*/
+		RMTOPER		= (1<<BIT_RMTOPER),	/*  a process descriptor is just used for a remote operation until the Sender PROXY completes the request */
+		WAITMIGR	= (1<<BIT_WAITMIGR),	/*  a destination process is MIGRATING, the sender must be blocked and enqueued into the mig a REMOTE process descriptor is just used for a remote operation until the Sender PROXY completes the request */
+		DONATING     = (1<<BIT_DONATING),	/* the process descriptor is reserved to be donated to other node */
+};
+
+/* Bits for the p_misc_flags  */
+#define GENERIC_PROC	0
+
+#endif /* PROC_STS_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/proc_usr.h /usr/src/linux/kernel/minix/proc_usr.h
--- /home/jara/linux-2.6.32/kernel/minix/proc_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/proc_usr.h	2014-04-20 11:04:05.000000000 -0300
@@ -0,0 +1,51 @@
+#ifndef PROC_USR_H
+#define PROC_USR_H
+
+#define MAXPROCNAME	16
+#define PRIV_KERNEL	0
+#define PRIV_SYSTEM	1
+#define PRIV_SYSTEM	1
+
+/* =================================*/
+/* PROCESS DESCRIPTOR	             */
+/* =================================*/
+struct proc_usr {
+
+  int p_nr;				/* process number				*/
+  int p_endpoint;			/* process endpoint				*/
+  int p_vmid;				/* process VMID					*/
+  volatile unsigned long p_rts_flags;	/* process is runnable only if zero 		*/
+  int p_lpid;				/* local LINUX PID 				*/
+  int p_nodeid;				/* Node ID where the process PRIMARY replica is running  */
+  unsigned long p_nodemap;		/* bitmap of nodes where replicas of this process exists UNTIL 32 NODES!!! */
+//  node_map_t p_nodemap;		/* bitmap of nodes where replicas of this process exists */
+
+volatile unsigned long  p_misc_flags;	/* miselaneous flags				*/
+
+  int p_getfrom;			/* from whom does process want to receive?	*/
+  int p_sendto;				/* to whom does process want to send? 		*/
+  int p_waitmigr;			/* waiting the migration of a process 		*/
+  int p_proxy;				/* the descriptor is enqueued on a proxy 	*/
+
+  unsigned long p_lclsent; 		/* counter of LOCAL messages sent	*/
+  unsigned long p_rmtsent; 		/* counter of REMOTE messages sent	*/ 
+
+  char p_name[MAXPROCNAME]; 	
+
+#ifdef MOL_USERSPACE
+	cpu_set_t p_cpumask;
+#else
+	cpumask_t p_cpumask;
+#endif 
+  
+};
+typedef struct proc_usr proc_usr_t;
+
+#define PROC_USR_FORMAT "nr=%d endp=%d vmid=%d flags=%lX misc=%lX lpid=%d nodeid=%d nodemap=%lX name=%s \n"
+#define PROC_USR_FIELDS(p) p->p_nr,p->p_endpoint, p->p_vmid, p->p_rts_flags, p->p_misc_flags, \
+			 p->p_lpid, p->p_nodeid, p->p_nodemap, p->p_name
+
+#define PROC_CPU_FORMAT "nr=%d endp=%d vmid=%d lpid=%d p_cpumask=%lX name=%s \n"
+#define PROC_CPU_FIELDS(p) p->p_nr,p->p_endpoint, p->p_vmid, p->p_lpid, p->p_cpumask.bits[0], p->p_name
+			 
+#endif /* PROC_USR_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/proxy.h /usr/src/linux/kernel/minix/proxy.h
--- /home/jara/linux-2.6.32/kernel/minix/proxy.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/proxy.h	2013-10-08 15:43:00.000000000 -0300
@@ -0,0 +1,21 @@
+
+
+
+struct proxies_s {
+	proxies_usr_t	px_usr;		
+	struct proc 	px_sproxy;	/* sender proxy 			*/
+	struct proc 	px_rproxy;	/* receiver proxy 			*/
+#if LOCK_PROXY_TYPE == USE_PROXY_RWLOCK
+	rwlock_t   	px_rwlock;	/* LINUX spinlock to protect this PAIR OF PROXIES */	
+#else	/* USE_PROC_MUTEX*/
+	struct mutex 	px_mutex;	/* LINUX mutex to protect this PAIR OF PROXIES	*/	
+#endif
+};
+typedef struct proxies_s proxies_t;
+
+
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/proxy_sts.h /usr/src/linux/kernel/minix/proxy_sts.h
--- /home/jara/linux-2.6.32/kernel/minix/proxy_sts.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/proxy_sts.h	2013-10-19 01:11:14.000000000 -0300
@@ -0,0 +1,32 @@
+
+#define MIS_BIT_PROXY		0
+#define MIS_BIT_CONNECTED	1
+#define MIS_BIT_NOTIFY		2
+#define MIS_BIT_NEEDMIGR	3
+#define MIS_BIT_RMTBACKUP	4
+#define MIS_BIT_GRPLEADER	5
+
+
+enum mis_status {
+		MIS_PROXY	= (1<<MIS_BIT_PROXY),	/* the process is a proxy 			*/
+		MIS_CONNECTED	= (1<<MIS_BIT_CONNECTED),	/* The proxy is connected 	*/
+		MIS_NOTIFY	= (1<<MIS_BIT_NOTIFY),	/* A notify is pending 	 			*/
+		MIS_NEEDMIG	= (1<<MIS_BIT_NEEDMIGR), /* The proccess need to migrate		*/
+		MIS_RMTBACKUP	= (1<<MIS_BIT_RMTBACKUP), /* The proccess is a remote process' backup 	*/
+		MIS_GRPLEADER	= (1<<MIS_BIT_GRPLEADER), /* The proccess is the thread group leader 	*/	
+};
+
+#define PX_BIT_INUSE		0
+#define PX_BIT_SCONNECTED	1
+#define PX_BIT_RCONNECTED	2
+
+#define PROXIES_FREE		0x0000
+enum px_status {
+		PROXIES_INUSE	= (1<<PX_BIT_INUSE),		/* the proxy pair is in use 		*/
+		PROXIES_SCONNECTED= (1<<PX_BIT_SCONNECTED),	
+		PROXIES_RCONNECTED= (1<<PX_BIT_RCONNECTED),	
+};
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/proxy_usr.h /usr/src/linux/kernel/minix/proxy_usr.h
--- /home/jara/linux-2.6.32/kernel/minix/proxy_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/proxy_usr.h	2013-10-03 17:19:00.000000000 -0300
@@ -0,0 +1,48 @@
+#define MAXPROXYNAME	16
+
+#define	CONNECT_SPROXY		1
+#define	CONNECT_RPROXY		2
+#define	DISCONNECT_SPROXY	3
+#define	DISCONNECT_RPROXY	4
+
+#define PROXY_NO_VM				(-1)	/* The proxy has not a VM		*/
+
+#define	proxy_hdr_t	cmd_t 
+
+#define ETHERNET_MTU	1500
+#define IPV4_HEADER		20
+#define UPD_HEADER		8
+#define PROXY_HEADER	(sizeof(proxy_hdr_t)+sizeof(int))
+#define MAXMTUSIZE	(ETHERNET_MTU - (IPV4_HEADER+UPD_HEADER) )
+#define MAXBUFSIZE	(ETHERNET_MTU - (IPV4_HEADER+UPD_HEADER+PROXY_HEADER) ) 
+
+#define PROXY_NO_REPLY 		0
+#define PROXY_REPLY		1
+
+#define BIT_ACKNOWLEDGE		13
+#define CMD_ACKNOWLEDGE 	(1<<BIT_ACKNOWLEDGE)
+
+#define HELLO_PERIOD		(30*1000)	/* 30 Seconds */
+
+#define	NO_PROXIES		(-1)
+
+
+typedef union {
+	message pay_msg;		/* Minix message		*/
+	char 	pay_data[MAXCOPYBUF];	/* buffer space to copy data	*/  
+} proxy_payload_t;
+
+#define TIME_FORMAT "TIMESTAMP sec=%ld nsec=%ld\n"
+#define TIME_FIELDS(p) p->tv_sec, p->tv_nsec
+
+struct proxies_usr_s {
+	unsigned int	px_id; 		/* The number of pair of proxies	*/
+unsigned long int	px_flags; 	/* The status of the pair of proxies 	*/
+	char		px_name[MAXPROXYNAME];
+
+};
+typedef struct proxies_usr_s proxies_usr_t;
+
+#define PX_USR_FORMAT 		"px_id=%d px_flags=%d px_name=%s\n" 
+#define PX_USR_FIELDS(p) 	p->px_id, p->px_flags, p->px_name
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/resource.h /usr/src/linux/kernel/minix/resource.h
--- /home/jara/linux-2.6.32/kernel/minix/resource.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/resource.h	2013-05-24 15:25:00.000000000 -0300
@@ -0,0 +1,5 @@
+#define PRIO_SYSTASK	-19
+#define PRIO_PROXY	-19
+#define PRIO_TASK	-15
+#define PRIO_SERVER	-10
+#define PRIO_USERPROC	 0
diff -Naur /home/jara/linux-2.6.32/kernel/minix/signal.h /usr/src/linux/kernel/minix/signal.h
--- /home/jara/linux-2.6.32/kernel/minix/signal.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/signal.h	2014-05-02 18:17:18.000000000 -0300
@@ -0,0 +1,10 @@
+/* MINIX specific signals. These signals are not used by user proceses, 
+ * but meant to inform system processes, like the PM, about system events.
+ */
+ 
+typedef unsigned long mnxsigset_t;
+typedef  mnxsigset_t molsigset_t;
+
+#define SIGKMESS   	  29	/* new kernel message */
+#define SIGKSIG    	  30	/* kernel signal pending */
+#define SIGKSTOP      31	/* kernel shutting down */
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/kernel/minix/slots.h /usr/src/linux/kernel/minix/slots.h
--- /home/jara/linux-2.6.32/kernel/minix/slots.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/slots.h	2014-08-16 10:16:36.000000000 -0300
@@ -0,0 +1,17 @@
+/* =================================*/
+/* SLOT STATUS DESCRIPTOR	             */
+/* =================================*/
+#ifndef SLOTS_H
+#define SLOTS_H
+
+struct slot_s {
+  int s_endpoint;			/* process endpoint					*/
+  int s_owner;				/* Node ID where the process is running 	*/
+  char s_name[MAXPROCNAME]; 	
+};
+typedef struct slot_s slot_t;
+
+#define SLOTS_FORMAT "s_endpoint=%d s_owner=%d s_name=%s\n"
+#define SLOTS_FIELDS(p) p->s_endpoint,p->s_owner, p->s_name
+
+#endif /* SLOTS_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/sys_config.h /usr/src/linux/kernel/minix/sys_config.h
--- /home/jara/linux-2.6.32/kernel/minix/sys_config.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/sys_config.h	2013-08-14 10:07:00.000000000 -0300
@@ -0,0 +1,78 @@
+
+#ifndef _MINIX_SYS_CONFIG_H
+#define _MINIX_SYS_CONFIG_H 1
+
+/*===========================================================================*
+ *		This section contains user-settable parameters		     *
+ *===========================================================================*/
+#define _MINIX_MACHINE       _MACHINE_IBM_PC
+#define	_WORD_SIZE 			4
+
+#define _MACHINE_IBM_PC             1	/* any  8088 or 80x86-based system */
+#define _MACHINE_SUN_4             40	/* any Sun SPARC-based system */
+#define _MACHINE_SUN_4_60	   40	/* Sun-4/60 (aka SparcStation 1 or Campus) */
+#define _MACHINE_ATARI             60	/* ATARI ST/STe/TT (68000/68030) */
+#define _MACHINE_MACINTOSH         62	/* Apple Macintosh (68000) */
+
+#define _NR_FIXED_TASKS 3
+#define _NR_NODES 	32
+#define _NR_SYSTASKS	(2*_NR_NODES)			/* 2 Threads por SYSTASK (64) */
+#define _NR_TASKS	(_NR_FIXED_TASKS+_NR_SYSTASKS)	/* HARDWARE, CLOCK, IDLE + 32xSYSTASKS (64+3) */
+#define _NR_SERVERS	(32-_NR_FIXED_TASKS)		/* (32-3) = 29*/
+#define _NR_SYS_PROCS	(_NR_SERVERS+_NR_TASKS)   	/* 64+3+32-3 = 64+32 = 96 */
+#define _NR_USR_PROCS   (256-_NR_SYS_PROCS)		/* (256-96) = 160 */
+#define _NR_PROCS	(_NR_SERVERS+_NR_USR_PROCS) 	/* 29 +  160 =  189 => (NR_PROCS+NR_TASKS) = (189+ 64+3) = 256 !!!! */
+
+#define _NR_HOLES (2*_NR_PROCS+4)  /* No. of memory holes maintained by PM */
+#define _NR_VMS	     32
+
+/* Set the CHIP type based on the machine selected. The symbol CHIP is actually
+ * indicative of more than just the CPU.  For example, machines for which
+ * CHIP == INTEL are expected to have 8259A interrrupt controllers and the
+ * other properties of IBM PC/XT/AT/386 types machines in general. */
+#define _CHIP_INTEL             1	/* CHIP type for PC, XT, AT, 386 and clones */
+#define _CHIP_M68000            2	/* CHIP type for Atari, Amiga, Macintosh    */
+#define _CHIP_SPARC             3	/* CHIP type for SUN-4 (e.g. SPARCstation)  */
+
+/* Set the FP_FORMAT type based on the machine selected, either hw or sw    */
+#define _FP_NONE		  0	/* no floating point support                */
+#define _FP_IEEE		  1	/* conform IEEE floating point standard     */
+
+#if (_MINIX_MACHINE == _MACHINE_IBM_PC)
+#define _MINIX_CHIP          _CHIP_INTEL
+#endif
+
+#if (_MINIX_MACHINE == _MACHINE_ATARI) || (_MINIX_MACHINE == _MACHINE_MACINTOSH)
+#define _MINIX_CHIP         _CHIP_M68000
+#endif
+
+#if (_MINIX_MACHINE == _MACHINE_SUN_4) || (_MINIX_MACHINE == _MACHINE_SUN_4_60)
+#define _MINIX_CHIP          _CHIP_SPARC
+#define _MINIX_FP_FORMAT   _FP_IEEE
+#endif
+
+#if (_MINIX_MACHINE == _MACHINE_ATARI) || (_MINIX_MACHINE == _MACHINE_SUN_4)
+#define _ASKDEV            1	/* ask for boot device */
+#define _FASTLOAD          1	/* use multiple block transfers to init ram */
+#endif
+
+#ifndef _MINIX_FP_FORMAT
+#define _MINIX_FP_FORMAT   _FP_NONE
+#endif
+
+#ifndef _MINIX_MACHINE
+error "In <minix/sys_config.h> please define _MINIX_MACHINE"
+#endif
+
+#ifndef _MINIX_CHIP
+error "In <minix/sys_config.h> please define _MINIX_MACHINE to have a legal value"
+#endif
+
+#if (_MINIX_MACHINE == 0)
+error "_MINIX_MACHINE has incorrect value (0)"
+#endif
+
+/* Kernel debug checks */
+#define DEBUG_LOCK_CHECK 0	/* Interrupt Lock/unlock sanity checking. */
+
+#endif /* _MINIX_SYS_CONFIG_H */
diff -Naur /home/jara/linux-2.6.32/kernel/minix/syslib.h /usr/src/linux/kernel/minix/syslib.h
--- /home/jara/linux-2.6.32/kernel/minix/syslib.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/syslib.h	2013-09-03 10:24:00.000000000 -0300
@@ -0,0 +1,46 @@
+/* Prototypes for system library functions. */
+
+#ifndef _SYSLIB_H
+#define _SYSLIB_H
+
+#define SYSTASK SYSTEM
+
+/*==========================================================================* 
+ * Minix system library. 						    *
+ *==========================================================================*/ 
+int _taskcall(int who, int syscallnr, message *msgptr);
+int sys_fork(int child_lpid);
+int sys_exit(int proc);
+int sys_privctl(int endpoint, int priv_type);
+int sys_getinfo(int request, void *ptr, int len, void *ptr2, int len2);
+int sys_bindproc(int sysproc_nr, int lpid);
+int sys_rfork(int endpoint, int nodeid, char *name);
+int sys_times(int proc_nr, molclock_t *ptr);
+int sys_setalarm(molclock_t exp_time, int abs_time);
+int sys_vircopy(int src_proc, void *src_vir, int dst_proc, void *dst_vir, int bytes);
+int sys_getuptime(molclock_t *ticks);
+int sys_memset(unsigned long pattern, char *base, int bytes);
+		
+/* Shorthands for sys_getinfo() system call. */
+#define sys_getkinfo(dst)	sys_getinfo(GET_KINFO, dst, 0,0,0)
+#define sys_getproctab(dst)	sys_getinfo(GET_PROCTAB, dst, 0,0,0)
+#define sys_getprivtab(dst)	sys_getinfo(GET_PRIVTAB, dst, 0,0,0)
+#define sys_getmachine(dst)	sys_getinfo(GET_MACHINE, dst, 0,0,0)
+
+#define sys_getkmessages(dst)	sys_getinfo(GET_KMESSAGES, dst, 0,0,0)
+#define sys_getkinfo(dst)	sys_getinfo(GET_KINFO, dst, 0,0,0)
+#define sys_getloadinfo(dst)	sys_getinfo(GET_LOADINFO, dst, 0,0,0)
+#define sys_getproc(dst,nr)	sys_getinfo(GET_PROC, dst, 0,0, nr)
+#define sys_getrandomness(dst)	sys_getinfo(GET_RANDOMNESS, dst, 0,0,0)
+#define sys_getimage(dst)	sys_getinfo(GET_IMAGE, dst, 0,0,0)
+#define sys_getirqhooks(dst)	sys_getinfo(GET_IRQHOOKS, dst, 0,0,0)
+#define sys_getirqactids(dst)	sys_getinfo(GET_IRQACTIDS, dst, 0,0,0)
+#define sys_getmonparams(v,vl)	sys_getinfo(GET_MONPARAMS, v,vl, 0,0)
+#define sys_getschedinfo(v1,v2)	sys_getinfo(GET_SCHEDINFO, v1,0, v2,0)
+#define sys_getlocktimings(dst)	sys_getinfo(GET_LOCKTIMING, dst, 0,0,0)
+#define sys_getbiosbuffer(virp, sizep) sys_getinfo(GET_BIOSBUFFER, virp, \
+	sizeof(*virp), sizep, sizeof(*sizep))
+
+#endif /* _SYSLIB_H */
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/timers.h /usr/src/linux/kernel/minix/timers.h
--- /home/jara/linux-2.6.32/kernel/minix/timers.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/timers.h	2013-08-20 15:46:00.000000000 -0300
@@ -0,0 +1,53 @@
+/* This library provides generic watchdog timer management functionality.
+ * The functions operate on a timer queue provided by the caller. Note that
+ * the timers must use absolute time to allow sorting. The library provides:
+ *
+ *    tmrs_settimer:     (re)set a new watchdog timer in the timers queue 
+ *    tmrs_clrtimer:     remove a timer from both the timers queue 
+ *    tmrs_exptimers:    check for expired timers and run watchdog functions
+ *
+ * Author:
+ *    Jorrit N. Herder <jnherder@cs.vu.nl>
+ *    Adapted from tmr_settimer and tmr_clrtimer in src/kernel/clock.c. 
+ *    Last modified: September 30, 2004.
+ */
+
+#ifndef _TIMERS_H
+#define _TIMERS_H
+
+typedef unsigned long molclock_t;	
+
+struct moltimer;
+typedef void (*tmr_func_t)(struct moltimer *tp);
+typedef union { int ta_int; long ta_long; void *ta_ptr; } tmr_arg_t;
+
+/* A timer_t variable must be declare for each distinct timer to be used.
+ * The timers watchdog function and expiration time are automatically set
+ * by the library function tmrs_settimer, but its argument is not.
+ */
+typedef struct moltimer
+{
+  struct moltimer	*tmr_next;	/* next in a timer chain */
+  molclock_t 	tmr_exp_time;	/* expiration time */
+  tmr_func_t	tmr_func;	/* function to call when expired */
+  tmr_arg_t	tmr_arg;	/* random argument */
+} moltimer_t;
+
+/* Used when the timer is not active. */
+#define TMR_NEVER    ((molclock_t) -1 < 0) ? ((molclock_t) MOL_MOL_LONG_MAX) : ((molclock_t) -1)
+#undef TMR_NEVER
+#define TMR_NEVER	((molclock_t) MOL_LONG_MAX)
+
+/* These definitions can be used to set or get data from a timer variable. */ 
+#define tmr_arg(tp) (&(tp)->tmr_arg)
+#define tmr_exp_time(tp) (&(tp)->tmr_exp_time)
+
+/* Timers should be initialized once before they are being used. Be careful
+ * not to reinitialize a timer that is in a list of timers, or the chain
+ * will be broken.
+ */
+#define tmr_inittimer(tp) (void)((tp)->tmr_exp_time = TMR_NEVER, \
+	(tp)->tmr_next = NULL)
+
+#endif /* _TIMERS_H */
+
diff -Naur /home/jara/linux-2.6.32/kernel/minix/types.h /usr/src/linux/kernel/minix/types.h
--- /home/jara/linux-2.6.32/kernel/minix/types.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/types.h	2013-08-20 15:46:00.000000000 -0300
@@ -0,0 +1,91 @@
+#define CHAR_BIT           8		/* # bits in a char */
+#define TIMEOUT_MS		60000	/* IPC Timeout in Miliseconds */
+
+typedef unsigned long irq_id_t;	
+typedef short sys_id_t;			/* system process index */
+typedef unsigned short bitchunk_t; /* collection of bits in a bitmap */
+typedef unsigned long ksigset_t;
+
+#define BITCHUNK_BITS   (sizeof(bitchunk_t) * CHAR_BIT)
+#define BITMAP_CHUNKS(nr_bits) (((nr_bits)+BITCHUNK_BITS-1)/BITCHUNK_BITS)
+
+typedef struct {			/* bitmap for system indexes */
+  bitchunk_t chunk[BITMAP_CHUNKS(NR_SYS_PROCS)];
+} sys_map_t;
+
+typedef struct {			/* bitmap for VM indexes */
+  bitchunk_t chunk[BITMAP_CHUNKS(NR_VMS)];
+} vm_map_t;
+
+typedef struct {			/* bitmap for NODES indexes */
+  bitchunk_t chunk[BITMAP_CHUNKS(NR_NODES)];
+} node_map_t;
+
+
+/* Signal handler type, e.g. SIG_IGN */
+typedef void (*sighandler_t)(int);
+
+/* Types used in disk, inode, etc. data structures. */
+typedef short          mnx_dev_t;	   /* holds (major|minor) device pair */
+typedef char           mnx_gid_t;	   /* group id */
+typedef unsigned long  mnx_ino_t; 	   /* i-node number (V3 filesystem) */
+typedef unsigned short mnx_mode_t;	   /* file type and permissions bits */
+typedef short          mnx_nlink_t;	   /* number of links to a file */
+typedef unsigned long  mnx_off_t;	   /* offset within a file */
+typedef int            mnx_pid_t;	   /* process id (must be signed) */
+typedef short          mnx_uid_t;	   /* user id */
+typedef unsigned long  mnx_zone_t;	   /* zone number */
+typedef unsigned long  mnx_block_t;	   /* block number */
+typedef unsigned long  mnx_bit_t;	   /* bit number in a bit map */
+typedef unsigned short mnx_zone1_t;	   /* zone number for V1 file systems */
+typedef unsigned short mnx_bitchunk_t; /* collection of bits in a bitmap */
+
+typedef unsigned char   u8_t;	   /* 8 bit type */
+typedef unsigned short u16_t;	   /* 16 bit type */
+typedef unsigned long  u32_t;	   /* 32 bit type */
+
+typedef char            i8_t;      /* 8 bit signed type */
+typedef short          i16_t;      /* 16 bit signed type */
+typedef long           i32_t;      /* 32 bit signed type */
+
+typedef struct { u32_t _[2]; } u64_t;
+
+typedef unsigned long  Ino_t;
+
+#define  _EM_WSIZE  4
+
+#if _EM_WSIZE == 2
+/*typedef unsigned int      Ino_t; Ino_t is now 32 bits */
+typedef unsigned int    Zone1_t;
+typedef unsigned int Bitchunk_t;
+typedef unsigned int      U16_t;
+typedef unsigned int  _mnx_Mode_t;
+
+
+#else /* _EM_WSIZE == 4, or _EM_WSIZE undefined */
+/*typedef int	          Ino_t; Ino_t is now 32 bits */
+typedef int 	        Zone1_t;
+typedef int	     Bitchunk_t;
+typedef int	          U16_t;
+typedef int         _mnx_Mode_t;
+
+#endif /* _EM_WSIZE == 2, etc */
+
+typedef int            Dev_t;
+
+/* Devices. */   
+#define MNX_MAJOR              8    /* major device = (dev>>MAJOR) & 0377 */
+#define MNX_MINOR              0    /* minor device = (dev>>MINOR) & 0377 */
+
+#ifndef minor
+#define minor(dev)      (((dev) >> MNX_MINOR) & 0xff)
+#endif
+
+#ifndef major
+#define major(dev)      (((dev) >> MNX_MAJOR) & 0xff)
+#endif
+
+#ifndef makedev
+#define makedev(major, minor)   \
+                        ((dev_t) (((major) << MNX_MAJOR) | ((minor) << MNX_MINOR)))
+#endif
diff -Naur /home/jara/linux-2.6.32/kernel/minix/vmu.h /usr/src/linux/kernel/minix/vmu.h
--- /home/jara/linux-2.6.32/kernel/minix/vmu.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/vmu.h	2013-01-02 08:31:00.000000000 -0300
@@ -0,0 +1,11 @@
+#define MAXVMNAME	16
+
+struct VM_user {
+	int		vm_vmid;
+	int		vm_flags;
+	int 	vm_nr_procs;
+	int 	vm_nr_tasks;
+	int 	vm_nr_sysprocs;
+	char	vm_name[MAXVMNAME];
+};
+typedef struct VM_user VM_user_t;
diff -Naur /home/jara/linux-2.6.32/kernel/minix/vm_usr.h /usr/src/linux/kernel/minix/vm_usr.h
--- /home/jara/linux-2.6.32/kernel/minix/vm_usr.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/minix/vm_usr.h	2014-03-23 10:27:41.000000000 -0300
@@ -0,0 +1,33 @@
+#ifndef VM_USR_H
+#define VM_USR_H
+
+#define MAXVMNAME	16
+
+struct VM_usr {
+	int	vm_vmid;
+	int	vm_flags;
+	int 	vm_nr_procs;
+	int 	vm_nr_tasks;
+	int 	vm_nr_sysprocs;
+	int 	vm_nr_nodes;
+	unsigned long int vm_nodes; 		
+	char	vm_name[MAXVMNAME];
+#ifdef MOL_USERSPACE
+	cpu_set_t vm_cpumask;
+#else
+	cpumask_t vm_cpumask;
+#endif 
+};
+typedef struct VM_usr VM_usr_t;
+
+#define VM_USR_FORMAT "vm_vmid=%d vm_nr_procs=%d vm_nr_tasks=%d vm_nr_sysprocs=%d vm_nr_nodes=%d flags=%X vm_nodes=%X vm_name=%s\n"
+#define VM_USR_FIELDS(p) p->vm_vmid,p->vm_nr_procs, p->vm_nr_tasks, p->vm_nr_sysprocs, p->vm_nr_nodes,p->vm_flags, p->vm_nodes, p->vm_name
+
+//http://lxr.free-electrons.com/source/include/linux/types.h#L9
+// #define DECLARE_BITMAP(name,bits)    unsigned long name[BITS_TO_LONGS(bits)]
+//http://lxr.free-electrons.com/source/include/linux/cpumask.h
+// typedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS); } cpumask_t; 
+#define VM_CPU_FORMAT "vm_vmid=%d vm_cpumask=%X vm_name=%s \n"
+#define VM_CPU_FIELDS(p) p->vm_vmid,  (unsigned int) p->vm_cpumask.bits[0], p->vm_name
+
+#endif /* VM_USR_H */
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/kernel/mol-acks.c /usr/src/linux/kernel/mol-acks.c
--- /home/jara/linux-2.6.32/kernel/mol-acks.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-acks.c	2013-10-17 12:22:42.000000000 -0300
@@ -0,0 +1,202 @@
+/****************************************************************/
+/*			MOL REMOTE ACKNOWLEDGES				*/
+/****************************************************************/
+
+#include "mol.h"
+#include "mol-proto.h"
+#include "mol-glo.h"
+#include "mol-macros.h"
+
+/****************************************************************/
+/****************************************************************/
+/*	ACKNOWLEDGES FROM LOCAL NODE TO REMOTE NODE		*/
+/****************************************************************/
+/****************************************************************/
+
+/*--------------------------------------------------------------*/
+/*			generic_ack_lcl2rmt			*/
+/* Enqueue into the sender's proxy queue the rmt_ptr   		*/
+/*--------------------------------------------------------------*/
+long generic_ack_lcl2rmt(int ack, struct proc *rmt_ptr, struct proc *lcl_ptr, int rcode)
+{
+	/* set the RMTOPER bit to signal that this REMOTE descriptor 	*/
+	/* is envolved into a remote operation 			*/
+MOLDEBUG(DBGPARAMS,"ack=%d rcode=%d\n", ack, rcode);
+
+	set_bit(BIT_RMTOPER, &rmt_ptr->p_usr.p_rts_flags);
+
+	rmt_ptr->p_rmtcmd.c_cmd   = ack;
+	rmt_ptr->p_rmtcmd.c_vmid  = rmt_ptr->p_usr.p_vmid;
+	rmt_ptr->p_rmtcmd.c_src   = lcl_ptr->p_usr.p_endpoint;	/* Source endpoint		*/
+	rmt_ptr->p_rmtcmd.c_dst   = rmt_ptr->p_usr.p_endpoint;	/* Destination endpoint 	*/
+	rmt_ptr->p_rmtcmd.c_snode = atomic_read(&local_nodeid);	/* source node			*/
+	rmt_ptr->p_rmtcmd.c_dnode = rmt_ptr->p_usr.p_nodeid;	/* destination node		*/
+	rmt_ptr->p_rmtcmd.c_len   = 0;
+	rmt_ptr->p_rmtcmd.c_rcode = rcode;
+
+	return(sproxy_enqueue(rmt_ptr));
+}
+
+/*--------------------------------------------------------------*/
+/*			error_lcl2rmt				*/
+/* Enqueue the rmt_ptr process descriptor into the proxy sender */
+/* with an ACKNOWLEDGE with an error. 				*/
+/* The error header is obtained from the received header 	*/
+/*--------------------------------------------------------------*/
+long error_lcl2rmt( int ack, struct proc *rmt_ptr, proxy_hdr_t *h_ptr, int rcode)
+{
+	/* set the RMTOPER bit to signal that this REMOTE descriptor 	*/
+	/* is envolved into a remote operation 		*/
+MOLDEBUG(DBGPARAMS,"ack=%d rcode=%d\n", ack, rcode);
+
+	set_bit(BIT_RMTOPER, &rmt_ptr->p_usr.p_rts_flags);
+
+	rmt_ptr->p_rmtcmd.c_cmd   = ack;
+	rmt_ptr->p_rmtcmd.c_vmid  = h_ptr->c_vmid;
+	rmt_ptr->p_rmtcmd.c_src   = h_ptr->c_dst;	/* Original destination endpoint is now the Source endpoint 	*/
+	rmt_ptr->p_rmtcmd.c_dst   = rmt_ptr->p_usr.p_endpoint;
+	rmt_ptr->p_rmtcmd.c_snode = atomic_read(&local_nodeid);	/* source node			*/
+	rmt_ptr->p_rmtcmd.c_dnode = rmt_ptr->p_usr.p_nodeid;
+	rmt_ptr->p_rmtcmd.c_len   = 0;
+	rmt_ptr->p_rmtcmd.c_rcode = rcode;
+
+	return(sproxy_enqueue(rmt_ptr));
+}
+
+/*--------------------------------------------------------------*/
+/*			copyin_rqst_lcl2rmt			*/ 
+/* The sender sends a COPYIN_RQST to the destination 		*/
+/* The remote process has the vcopy fields filled		*/
+/*--------------------------------------------------------------*/
+long copyin_rqst_lcl2rmt(struct proc *rmt_ptr, struct proc *lcl_ptr) 
+{
+	proc_usr_t *p_ptr;
+	cmd_t *c_ptr;
+
+	/* set the RMTOPER bit to signal that this REMOTE descriptor 	*/
+	/* is envolved into a remote operation 		*/
+
+	set_bit(BIT_RMTOPER, &rmt_ptr->p_usr.p_rts_flags);
+
+	p_ptr = &rmt_ptr->p_usr;
+MOLDEBUG(DBGPROC,PROC_USR_FORMAT,PROC_USR_FIELDS(p_ptr));
+
+	rmt_ptr->p_rmtcmd.c_cmd   = CMD_COPYIN_RQST;
+	rmt_ptr->p_rmtcmd.c_vmid  = lcl_ptr->p_usr.p_vmid;
+	rmt_ptr->p_rmtcmd.c_src   = lcl_ptr->p_usr.p_endpoint;		/* Source endpoint		*/
+	rmt_ptr->p_rmtcmd.c_dst   = rmt_ptr->p_usr.p_nodeid;		/* Destination endpoint 	*/
+	rmt_ptr->p_rmtcmd.c_snode = atomic_read(&local_nodeid);		/* source node			*/
+	rmt_ptr->p_rmtcmd.c_dnode = rmt_ptr->p_usr.p_nodeid;		/* destination node		*/
+	rmt_ptr->p_rmtcmd.c_len   = rmt_ptr->p_rmtcmd.c_vcopy.v_bytes;
+	rmt_ptr->p_rmtcmd.c_rcode = OK;
+	
+	c_ptr = &rmt_ptr->p_rmtcmd;	
+MOLDEBUG(DBGVCOPY, VCOPY_FORMAT,VCOPY_FIELDS(c_ptr) );
+
+	return(sproxy_enqueue(rmt_ptr));
+}
+
+/*--------------------------------------------------------------*/
+/*			copyout_data_lcl2rmt			*/
+/*--------------------------------------------------------------*/
+long copyout_data_lcl2rmt(struct proc *rmt_ptr, struct proc *lcl_ptr, int rcode)
+{
+	/* set the RMTOPER bit to signal that this REMOTE descriptor 	*/
+	/* is envolved into a remote operation 			*/
+	proc_usr_t *p_ptr;
+	cmd_t *c_ptr;
+
+	p_ptr = &rmt_ptr->p_usr;
+MOLDEBUG(DBGPROC,PROC_USR_FORMAT,PROC_USR_FIELDS(p_ptr));
+
+	set_bit(BIT_RMTOPER, &rmt_ptr->p_usr.p_rts_flags);
+
+	rmt_ptr->p_rmtcmd.c_cmd   = CMD_COPYOUT_DATA;
+	rmt_ptr->p_rmtcmd.c_vmid  = rmt_ptr->p_usr.p_vmid;
+	rmt_ptr->p_rmtcmd.c_src   = lcl_ptr->p_usr.p_endpoint;		/* Source endpoint		*/
+	rmt_ptr->p_rmtcmd.c_dst   = rmt_ptr->p_usr.p_endpoint;		/* Destination endpoint 	*/
+	rmt_ptr->p_rmtcmd.c_snode = atomic_read(&local_nodeid);		/* source node			*/
+	rmt_ptr->p_rmtcmd.c_dnode = rmt_ptr->p_usr.p_nodeid;		/* destination node		*/
+	rmt_ptr->p_rmtcmd.c_len   = rmt_ptr->p_rmtcmd.c_vcopy.v_bytes;
+	rmt_ptr->p_rmtcmd.c_rcode = rcode;
+
+	c_ptr = &rmt_ptr->p_rmtcmd;	
+MOLDEBUG(DBGVCOPY, VCOPY_FORMAT,VCOPY_FIELDS(c_ptr) );
+MOLDEBUG(INTERNAL,"rcode=%d\n", rcode);
+
+	return(sproxy_enqueue(rmt_ptr));
+}
+
+
+/****************************************************************/
+/****************************************************************/
+/*	ACKNOWLEDGES FROM REMOTE NODE TO LOCAL NODE		*/
+/****************************************************************/
+/****************************************************************/
+
+/*--------------------------------------------------------------*/
+/*			send_ack_rmt2lcl			*/
+/* proxy sends a SEND ACK to a local process		 	*/
+/*--------------------------------------------------------------*/
+asmlinkage long send_ack_rmt2lcl(struct proc *rmt_ptr, struct proc *lcl_ptr, int rcode)
+{
+	VM_desc_t *vm_ptr;
+
+	vm_ptr 	= &vm[lcl_ptr->p_usr.p_vmid];
+
+MOLDEBUG(DBGPARAMS,"vmid=%d src_ep=%d dst_ep=%d rcode=%d\n",vm_ptr->vm_usr.vm_vmid, rmt_ptr->p_usr.p_endpoint, lcl_ptr->p_usr.p_endpoint, rcode);
+
+	/* checks if the remote source does not have pending operations */
+	if( test_bit(BIT_SENDING, &rmt_ptr->p_usr.p_rts_flags))	ERROR_RETURN(EMOLPROCSTS);
+
+	/* verify if the local destination is waiting in SENDING state */
+	if(!test_bit(BIT_SENDING, &lcl_ptr->p_usr.p_rts_flags))  	ERROR_RETURN(EMOLACKDST);
+	
+	/* verify if the local ack destination is waiting the ack from the remote source */
+	if(lcl_ptr->p_usr.p_sendto != rmt_ptr->p_usr.p_endpoint) 	ERROR_RETURN(EMOLACKSRC);
+
+	clear_bit(BIT_SENDING, &lcl_ptr->p_usr.p_rts_flags);
+	lcl_ptr->p_usr.p_sendto = NONE;
+
+	/* Wakes up the local ack destinantion */
+	if( lcl_ptr->p_usr.p_rts_flags == 0)
+		READY_UP_RCODE(lcl_ptr, CMD_SEND_ACK, rcode);
+
+	return(OK);
+}
+
+
+/*--------------------------------------------------------------*/
+/*			generic_ack_rmt2lcl			*/
+/* proxy sends an COPY ACK to a local process 			*/
+/*--------------------------------------------------------------*/
+long generic_ack_rmt2lcl(int ack, struct proc *rmt_ptr, struct proc *lcl_ptr, int rcode)
+{
+	VM_desc_t *vm_ptr;
+	int ret;
+
+	vm_ptr 	= &vm[lcl_ptr->p_usr.p_vmid];
+
+MOLDEBUG(DBGPARAMS,"vmid=%d src_ep=%d dst_ep=%d ack=%d rcode=%d\n",
+		vm_ptr->vm_usr.vm_vmid, rmt_ptr->p_usr.p_endpoint, lcl_ptr->p_usr.p_endpoint,ack, rcode);
+	
+	do {
+		ret = OK;
+		if( IT_IS_LOCAL(rmt_ptr)) 			{ret= EMOLLCLPROC; break;}
+
+		if( lcl_ptr->p_usr.p_rts_flags == PROC_RUNNING) {ret= EMOLPROCRUN; break;}
+
+		/*check that all envolved processes are on ONCOPY state */
+		if(!test_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags)){ret= EMOLPROCSTS; break;}
+	    if(!test_bit(BIT_ONCOPY, &rmt_ptr->p_usr.p_rts_flags))  {ret= EMOLPROCSTS; break;}
+	}while(0);
+	if(ret == OK) {
+		/* wake up the requester */
+		if( lcl_ptr->p_usr.p_rts_flags == ONCOPY)
+			READY_UP_RCODE(lcl_ptr, ack, rcode);
+	}
+
+	return(ret);
+}
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/mol-const.h /usr/src/linux/kernel/mol-const.h
--- /home/jara/linux-2.6.32/kernel/mol-const.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-const.h	2013-09-21 10:40:00.000000000 -0300
@@ -0,0 +1,7 @@
+/****************************************************************/
+/*			MOL-CONST.H				 			*/
+/****************************************************************/
+
+#define EXTERN	extern
+#define PID_MAX	PID_MAX_LIMIT		
+#define USER_ROOT	0
diff -Naur /home/jara/linux-2.6.32/kernel/mol-glo.h /usr/src/linux/kernel/mol-glo.h
--- /home/jara/linux-2.6.32/kernel/mol-glo.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-glo.h	2013-10-13 19:56:00.000000000 -0300
@@ -0,0 +1,56 @@
+/*----------------------------------------------------------------*/
+/*				GLOBAL VARIABLES		*/
+/*----------------------------------------------------------------*/
+
+EXTERN VM_desc_t vm[NR_VMS];		/* an array of VM structs */
+EXTERN cluster_node_t node[NR_NODES];	/* an array of NODE structs */
+EXTERN proxies_t proxies[NR_NODES];		/* an array of PROXY PAIR structs */
+EXTERN struct kref drvs_kref;		/* reference counter for DRVS */
+EXTERN int sizeof_proc_aligned; 	/* size of the struct proc cache line aligned */
+EXTERN int log2_proc_size;		/* number of bits to left shift 			 */
+
+EXTERN struct proc_dir_entry *info_entry;
+EXTERN struct proc_dir_entry *proc_drvs_dir;
+EXTERN struct proc_dir_entry *nodes_entry;
+EXTERN struct proc_dir_entry *proxies_dir;
+EXTERN struct proc_dir_entry *proxies_info_entry;
+EXTERN struct proc_dir_entry *proxies_info_procs;
+
+#ifdef MOLHYPER
+atomic_t local_nodeid = ATOMIC_INIT(DRVS_NO_INIT); /* local_nodeid = DRVS_NO_INIT = (-1) means that the DRVS is unitialized! */
+drvs_usr_t drvs = {
+		NR_VMS,
+		NR_NODES,
+		NR_PROCS,
+		NR_TASKS,
+		NR_SYS_PROCS,
+
+		MAXCOPYBUF,
+		MAXCOPYLEN,
+
+		(GENERIC|INTERNAL|DBGPROCLOCK|DBGVMLOCK|DBGMESSAGE|DBGCMD|DBGVCOPY|DBGPARAMS|DBGPROC|\
+		 DBGPRIV|DBGPROCSEM),
+		DRVS_VERSION,
+		DRVS_SUBVER
+		};
+
+#if LOCK_DRVS_TYPE == USE_DRVS_RWLOCK
+rwlock_t drvs_rwlock = RW_LOCK_UNLOCKED;		
+#else
+DEFINE_MUTEX(drvs_mutex);				/* LINUX mutex to protect DRVS 	*/	
+#endif
+
+#else
+EXTERN atomic_t	local_nodeid; 
+EXTERN drvs_usr_t drvs;
+
+#if LOCK_DRVS_TYPE == USE_DRVS_RWLOCK
+EXTERN rwlock_t   	drvs_rwlock;
+#else
+EXTERN struct mutex drvs_mutex;
+#endif
+
+#endif
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/mol.h /usr/src/linux/kernel/mol.h
--- /home/jara/linux-2.6.32/kernel/mol.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol.h	2013-09-21 10:55:00.000000000 -0300
@@ -0,0 +1,46 @@
+/****************************************************************/
+/*			MOL.H				 			*/
+/****************************************************************/
+
+#include <asm/page.h>
+#include <linux/kernel.h>
+#include <linux/semaphore.h>        
+#include <linux/module.h>	/* THIS IS FOR EXPORT_SYMBOL!!! */
+#include <linux/bitops.h>
+#include <linux/bitmap.h>
+#include <linux/sched.h>                    
+#include <linux/list.h>                    
+#include <linux/syscalls.h>   
+#include <linux/vmalloc.h>                 
+#include <linux/timer.h>                 
+#include <linux/kfifo.h>                 
+#include <linux/wait.h>
+#include <linux/proc_fs.h>
+#include <linux/signal.h>
+#include <linux/log2.h>
+#include <linux/kref.h>
+
+#include <asm/unistd.h>  
+#include <asm/uaccess.h>
+#include <asm/spinlock.h>
+#include <asm/pgalloc.h>
+#include <asm/pgtable.h>
+
+#include "../arch/x86/include/asm/processor.h"
+
+#include "./minix/config.h"
+#include "./minix/ipc.h"
+#include "./minix/kipc.h"
+#include "./minix/timers.h"
+#include "./minix/cmd.h"
+#include "./minix/proc.h"
+#include "./minix/proxy_sts.h"
+#include "./minix/proxy_usr.h"
+#include "./minix/proxy.h"
+#include "./minix/molerrno.h"
+#include "./minix/endpoint.h"
+#include "./minix/moldebug.h"
+#include "./minix/drvs_usr.h"
+#include "./minix/callnr.h"
+
+#include "mol-const.h"
diff -Naur /home/jara/linux-2.6.32/kernel/mol-hyper.c /usr/src/linux/kernel/mol-hyper.c
--- /home/jara/linux-2.6.32/kernel/mol-hyper.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-hyper.c	2015-03-18 12:18:37.000000000 -0300
@@ -0,0 +1,2302 @@
+/****************************************************************/
+/*			MINIX OVER LINUX HYPERVISOR 	 	*/
+/****************************************************************/
+
+#include "mol.h"
+#include "mol-proto.h"
+
+extern int send_sig_info(int, struct siginfo *, struct task_struct *);
+extern struct cpuinfo_x86 boot_cpu_data;
+
+/* space for global variables are defined here */
+#ifdef EXTERN
+#undef EXTERN
+#define EXTERN
+#define MOLHYPER
+#endif
+#include "mol-glo.h"
+#include "mol-macros.h"
+
+/*--------------------------------------------------------------*/
+/*			mol_wait4bind				*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_wait4bind(long timeout_ms)
+{
+	struct proc *caller_ptr;
+	int ret;
+	int caller_pid;
+	struct task_struct *task_ptr;	
+
+	if( DRVS_NOT_INIT() ) 		ERROR_RETURN(EMOLDRVSINIT);
+
+	while(TRUE) {
+
+		ret = check_lock_caller(&task_ptr, &caller_ptr, &caller_pid);
+		MOLDEBUG(DBGPARAMS,"caller_pid=%d ret=%d\n", caller_pid, ret);
+
+		if(ret == OK) {		/*The process is just binded */
+			ret = caller_ptr->p_usr.p_endpoint;
+			WUNLOCK_PROC(caller_ptr);
+			return(ret);
+		}
+
+
+		if(ret != EMOLNOTBIND) ERROR_RETURN(ret);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule();		
+	}
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_drvs_init				*/
+/* Initialize the DRVS system					*/
+/* du_addr = NULL => already loaded DRVS parameters 	*/ 
+/* returns the local_node id if OK or negative on error	*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_drvs_init(int nodeid, drvs_usr_t *du_addr)
+{
+	int i, ret;
+	VM_desc_t *vm_ptr;
+	drvs_usr_t lcldrvs, *d_ptr;
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( !DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSBUSY);
+	
+	CHECK_NODEID(nodeid);
+
+	WLOCK_DRVS;
+
+	/* get DRVS parameters from Userspace */
+	if( du_addr != NULL) {  /* NULL => already loaded DRVS parameters */ 
+		do {
+			ret = copy_from_user(&lcldrvs, du_addr, sizeof(drvs_usr_t));
+			if(ret) break;
+			d_ptr = &lcldrvs;
+			MOLDEBUG(DBGPARAMS,DRVS_USR_FORMAT, DRVS_USR_FIELDS(d_ptr));
+			MOLDEBUG(DBGPARAMS,DRVS_MAX_FORMAT, DRVS_MAX_FIELDS(d_ptr));
+			MOLDEBUG(DBGPARAMS,DRVS_VER_FORMAT, DRVS_VER_FIELDS(d_ptr));
+
+			if(d_ptr->d_nr_vms <= 0  || d_ptr->d_nr_vms > NR_VMS ) {ret = EMOLBADRANGE; break;}
+			if(d_ptr->d_nr_nodes <= 0 || d_ptr->d_nr_nodes > NR_NODES) {ret = EMOLBADRANGE; break;}
+			if(d_ptr->d_nr_procs <= 0 || d_ptr->d_nr_procs > NR_PROCS ) {ret = EMOLBADRANGE; break;}
+			if(d_ptr->d_nr_tasks <= 0 || d_ptr->d_nr_tasks > NR_TASKS ) {ret = EMOLBADRANGE; break;}
+			if(d_ptr->d_nr_sysprocs <= 0 || d_ptr->d_nr_sysprocs > NR_SYS_PROCS ) {ret = EMOLBADRANGE; break;}	
+
+			if(d_ptr->d_nr_tasks < ((d_ptr->d_nr_nodes*2)+NR_FIXED_TASKS)) {ret = EMOLBADRANGE; break;}
+			if(d_ptr->d_nr_sysprocs >= (d_ptr->d_nr_procs+ d_ptr->d_nr_tasks)) {ret = EMOLBADRANGE; break;}
+			if(d_ptr->d_nr_sysprocs <= d_ptr->d_nr_tasks) {ret = EMOLBADRANGE; break;}
+
+			if(d_ptr->d_max_copybuf > MAXCOPYBUF) {ret = EMOLBADVALUE; break;}
+			if(d_ptr->d_max_copylen > MAXCOPYLEN) {ret = EMOLBADVALUE; break;}
+			if(d_ptr->d_max_copylen < d_ptr->d_max_copybuf) {ret = EMOLBADVALUE; break;}
+
+		}while(0);
+		if (ret) 	{ 
+			WUNLOCK_DRVS;
+			ERROR_RETURN(ret);
+		}
+		memcpy(&drvs,&lcldrvs, sizeof(drvs_usr_t));
+	}
+
+	MOLDEBUG(INTERNAL,"CPU INFO: x86_cache_size=%d\n", boot_cpu_data.x86_cache_size);
+	MOLDEBUG(INTERNAL,"CPU INFO: x86_cache_alignment =%d\n", boot_cpu_data.x86_cache_alignment);
+
+	MOLDEBUG(INTERNAL,"Initializing DRVS. Local node ID %d\n", nodeid);
+	atomic_set(&local_nodeid, nodeid);		/* LUEGO DEBE SER OBTENIDO DE LA CONFIGURACION */	
+
+
+	MOLDEBUG(INTERNAL,"Initializing %d VMs: vm=%p\n", drvs.d_nr_vms, vm);
+	for( i = 0;  i < drvs.d_nr_vms; i++) {
+		vm_ptr = &vm[i];
+		vm_ptr->vm_usr.vm_flags = VM_FREE;
+		cpumask_setall(&vm_ptr->vm_usr.vm_cpumask);
+#if LOCK_VM_TYPE == USE_VM_RWLOCK
+	  	rwlock_init(&(vm_ptr->vm_rwlock));
+#else	/* USE_MUTEX*/
+		mutex_init(&(vm_ptr->vm_mutex));
+#endif
+	}
+	
+	MOLDEBUG(INTERNAL,"Initializing %d NODEs node=%p\n", drvs.d_nr_nodes, node);
+	for( i = 0;  i < drvs.d_nr_nodes; i++) {
+		init_node(i);
+	}
+
+	MOLDEBUG(INTERNAL,"Initializing %d PROXIES\n", drvs.d_nr_nodes);
+	for( i = 0;  i < drvs.d_nr_nodes; i++) {
+		init_proxies(i);
+	}
+
+	sprintf(node[nodeid].n_usr.n_name,"node%d",nodeid);
+
+	node[atomic_read(&local_nodeid)].n_usr.n_flags = (NODE_ATTACHED | NODE_SCONNECTED | NODE_SCONNECTED);
+	
+	/*Align every struct proc with the cache line */
+	sizeof_proc_aligned = boot_cpu_data.x86_cache_alignment;
+	while( sizeof(struct proc) > sizeof_proc_aligned)
+		sizeof_proc_aligned = (sizeof_proc_aligned << 1);
+	log2_proc_size = ilog2(sizeof_proc_aligned);
+	MOLDEBUG(INTERNAL,"sizeof_proc_aligned=%d log2_proc_size=%d\n",sizeof_proc_aligned, log2_proc_size);
+			
+	/* create the drvs dir under /proc */
+	proc_drvs_dir = proc_mkdir("drvs", NULL);
+  	if (proc_drvs_dir == NULL) {
+     		printk("ERROR: %d:%s:%u: Couldn't create drvs directory under /proc\n",
+				current->pid, __FUNCTION__ ,__LINE__); 
+		WUNLOCK_DRVS;
+		ERROR_RETURN(EMOLBADDIR);
+    	}else {
+		/* create the nodes file under /proc/drvs */
+		nodes_entry = create_proc_entry( "nodes", 0444, proc_drvs_dir);
+  		if (nodes_entry == NULL) {
+	     	printk("ERROR: %d:%s:%u: Couldn't create nodes under /proc/drvs\n",
+				current->pid, __FUNCTION__ ,__LINE__);
+			drvs_release(NULL);
+			WUNLOCK_DRVS;
+			ERROR_RETURN(EMOLBADFILE);
+		}else{
+   		 	nodes_entry->read_proc = nodes_read;
+			MOLDEBUG(GENERIC,"/proc/drvs/nodes installed\n");
+		}
+
+		/* create the file info  under /proc/drvs */
+		info_entry = create_proc_entry( "info", 0444, proc_drvs_dir);
+		if (info_entry == NULL) {
+    		printk("ERROR: %d:%s:%u: Couldn't create info into /proc/drvs\n",
+				current->pid, __FUNCTION__ ,__LINE__); 
+			drvs_release(NULL);
+			WUNLOCK_DRVS;
+			ERROR_RETURN(EMOLBADFILE);
+	    }else{
+			info_entry->read_proc = info_read;
+			MOLDEBUG(GENERIC,"/proc/drvs/info installed\n");
+		}
+		
+		/* create the directory proxies under /proc/drvs */
+		proxies_dir = proc_mkdir("proxies", proc_drvs_dir);
+		if (proxies_dir == NULL) {
+   			printk("ERROR: %d:%s:%u: Couldn't create directory proxies into /proc/drvs\n",
+				current->pid, __FUNCTION__ ,__LINE__); 
+			drvs_release(NULL);
+			WUNLOCK_DRVS;
+			ERROR_RETURN(EMOLBADFILE);
+		}else{
+			/* create the file info  under /proc/drvs/proxies */
+			proxies_info_entry = create_proc_entry( "info", 0444, proxies_dir);
+			if (proxies_info_entry == NULL) {
+				printk("ERROR: %d:%s:%u: Couldn't create file info into /proc/drvs/proxies\n",
+					current->pid, __FUNCTION__ ,__LINE__); 
+				drvs_release(NULL);
+				WUNLOCK_DRVS;
+				ERROR_RETURN(EMOLBADFILE);
+			}else{
+				proxies_info_entry->read_proc = proxies_info_read;
+				MOLDEBUG(GENERIC,"/proc/drvs/proxies/info installed\n");
+			}
+			/* create the file procs  under /proc/drvs/proxies */
+			proxies_info_procs = create_proc_entry( "procs", 0444, proxies_dir);
+			if (proxies_info_procs == NULL) {
+				printk("ERROR: %d:%s:%u: Couldn't create file procs into /proc/drvs/proxies\n",
+					current->pid, __FUNCTION__ ,__LINE__); 
+				drvs_release(NULL);
+				WUNLOCK_DRVS;
+				ERROR_RETURN(EMOLBADFILE);
+			}else{
+				proxies_info_procs->read_proc = proxies_procs_read;
+				MOLDEBUG(GENERIC,"/proc/drvs/proxies/procs installed\n");
+			}
+			
+		}
+    }
+		
+	kref_init(&drvs_kref);	
+
+	WUNLOCK_DRVS;
+
+	return(atomic_read(&local_nodeid));
+}
+
+/*----------------------------------------------------------------*/
+/*			drvs_release							*/
+/*----------------------------------------------------------------*/
+void drvs_release(struct kref *kref)	
+{
+MOLDEBUG(INTERNAL,"Releasing DRVS resources\n");
+
+	/* Set the DRVS as uninitilized */
+	atomic_set(&local_nodeid,DRVS_NO_INIT);
+
+	remove_proc_entry("info", 	proxies_dir);
+	remove_proc_entry("procs", 	proxies_dir);
+
+   	remove_proc_entry("nodes", 	proc_drvs_dir);
+	remove_proc_entry("info", 	proc_drvs_dir);
+	remove_proc_entry("proxies", 	proc_drvs_dir);
+	remove_proc_entry("drvs", 	NULL);
+
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_add_node				*/
+/* Initializa a cluster node to be used by a VM 		*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_add_node(int vmid, int nodeid)
+{
+	cluster_node_t *n_ptr;
+	VM_desc_t *vm_ptr;
+	int i, ret, nodes;
+
+	MOLDEBUG(DBGPARAMS,"vmid=%d nodeid=%d \n", vmid, nodeid);
+
+	if(current_euid() != USER_ROOT) 		ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   			ERROR_RETURN(EMOLDRVSINIT);
+
+	CHECK_NODEID(nodeid);
+	if(nodeid == atomic_read(&local_nodeid)) 	ERROR_RETURN(EMOLBADNODEID);
+	n_ptr = &node[nodeid];
+	if( n_ptr->n_usr.n_flags == NODE_FREE) 		ERROR_RETURN(EMOLNOPROXY);
+
+	CHECK_VMID(vmid);
+	vm_ptr 		= &vm[vmid];
+	WLOCK_VM(vm_ptr);
+	WLOCK_NODE(n_ptr);
+	do {	
+		ret = OK;	
+		if( vm_ptr->vm_usr.vm_flags)  			{ret = EMOLVMNOTRUN; break;}
+		if(test_bit(nodeid, &vm_ptr->vm_usr.vm_nodes))	{ret = EMOLVMNODE; break;}
+		if(test_bit(vmid, &n_ptr->n_usr.n_vms)) 	{ret = EMOLVMNODE; break;}  
+		/* check the number of nodes admitted by the VM*/
+		nodes = 0;
+		for( i = 0; i < sizeof(unsigned long int)*8; i++){
+			if( test_bit(i, &vm_ptr->vm_usr.vm_nodes)){	
+				nodes++;
+			}	
+		}
+		if( nodes >=  vm_ptr->vm_usr.vm_nr_nodes)	{ret = EMOLRSCBUSY; break;} 
+		set_bit(nodeid, &vm_ptr->vm_usr.vm_nodes);
+		set_bit(vmid, &n_ptr->n_usr.n_vms);
+	}while(0);
+	WUNLOCK_NODE(n_ptr);
+	WUNLOCK_VM(vm_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(OK);
+}
+
+
+/*--------------------------------------------------------------*/
+/*			mol_del_node				*/
+/* Delete a cluster node from a VM 		 		*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_del_node(int vmid, int nodeid)
+{
+
+	cluster_node_t *n_ptr;
+	VM_desc_t *vm_ptr;
+	int ret;
+
+	MOLDEBUG(DBGPARAMS,"vmid=%d nodeid=%d \n", vmid, nodeid);
+
+	if(current_euid() != USER_ROOT) 		ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   			ERROR_RETURN(EMOLDRVSINIT);
+
+	CHECK_NODEID(nodeid);
+	if(nodeid == atomic_read(&local_nodeid)) 	ERROR_RETURN(EMOLBADNODEID);
+	n_ptr = &node[nodeid];
+	if( n_ptr->n_usr.n_flags == NODE_FREE) 		ERROR_RETURN(EMOLNOPROXY);
+
+	CHECK_VMID(vmid);
+	vm_ptr 		= &vm[vmid];
+	WLOCK_VM(vm_ptr);
+	WLOCK_NODE(n_ptr);
+	do {
+		ret = OK;	
+		if( vm_ptr->vm_usr.vm_flags) 		{ret = EMOLVMNOTRUN; break;}
+		if(!test_bit(nodeid, &vm_ptr->vm_usr.vm_nodes))	{ret = EMOLVMNODE; break;}
+		if(!test_bit(vmid, &n_ptr->n_usr.n_vms))	{ret = EMOLVMNODE; break;} 
+		clear_bit(nodeid, &vm_ptr->vm_usr.vm_nodes);
+		clear_bit(vmid, &n_ptr->n_usr.n_vms);
+	}while(0);
+	WUNLOCK_NODE(n_ptr);
+	WUNLOCK_VM(vm_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(OK);
+}
+
+
+/*--------------------------------------------------------------*/
+/*			mol_vm_init				*/
+/* Initializa a VM and all of its processes			*/
+/* returns the local_node ID					*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_vm_init(VM_usr_t *vmu_addr)
+{
+	int i, ret, cpu_id;
+	long unsigned int *bm_ptr;
+	VM_desc_t *vm_ptr;
+	struct proc *proc_ptr;
+	VM_usr_t vmu, *vmu_ptr;
+	cpumask_t all_cpumask;
+	
+	MOLDEBUG(INTERNAL,"Current user=%d \n", current_uid());
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT);
+
+	/* ONLY FOR TESTING*/
+	vmu_ptr = &vmu;
+
+	cpu_id = get_cpu();
+	MOLDEBUG(INTERNAL,"This process is running on cpu_id=%d \n", cpu_id);
+
+	/* get VM parameters from Userspace */
+	ret = copy_from_user(&vmu, vmu_addr, sizeof(VM_usr_t));
+	if (ret) 	ERROR_RETURN(ret);
+	do {
+		if((vmu_ptr->vm_vmid        < 0) || (vmu_ptr->vm_vmid 	>= drvs.d_nr_vms)) break;
+		if((vmu_ptr->vm_nr_procs   <= 0) || (vmu_ptr->vm_nr_procs 	> drvs.d_nr_procs)) break;
+		if((vmu_ptr->vm_nr_tasks   <  0) || (vmu_ptr->vm_nr_tasks 	> drvs.d_nr_tasks)) break;
+		if((vmu_ptr->vm_nr_sysprocs < 0) || (vmu_ptr->vm_nr_sysprocs > drvs.d_nr_sysprocs)) break;
+		if((vmu_ptr->vm_nr_nodes   <= 0) || (vmu_ptr->vm_nr_nodes 	> drvs.d_nr_nodes)) break;
+		if(vmu_ptr->vm_nr_tasks < ((vmu_ptr->vm_nr_nodes*2)+NR_FIXED_TASKS)) 		break;
+		if(vmu_ptr->vm_nr_sysprocs >= (vmu_ptr->vm_nr_procs+ vmu_ptr->vm_nr_tasks)) break;
+		if(vmu_ptr->vm_nr_sysprocs <= vmu_ptr->vm_nr_tasks) 					break;
+	}while(0);
+	if(ret) ERROR_RETURN(EMOLBADRANGE);
+	
+	if( strlen(vmu_ptr->vm_name) >= MAXVMNAME ) ERROR_RETURN(EMOLNAMESIZE);
+	
+	for( i = 0; i < drvs.d_nr_vms; i++) {
+		vm_ptr = &vm[i];
+		RLOCK_VM(vm_ptr);
+		if(vm_ptr->vm_usr.vm_flags == VM_RUNNING) {
+			if(strcmp(vmu_ptr->vm_name, vm_ptr->vm_usr.vm_name) == 0) {
+				RUNLOCK_VM(vm_ptr);
+				ERROR_RETURN(EMOLRSCBUSY);	
+			}
+		}
+		RUNLOCK_VM(vm_ptr);	
+	}
+
+MOLDEBUG(INTERNAL,"Initializing VM=%d VMname=%s on node=%d\n",vmu_ptr->vm_vmid,vmu_ptr->vm_name, atomic_read(&local_nodeid));
+	vm_ptr = &vm[vmu_ptr->vm_vmid];
+	WLOCK_VM(vm_ptr);
+
+	if(vm_ptr->vm_usr.vm_flags == VM_RUNNING) 	ERROR_WUNLOCK_VM(vm_ptr,EMOLVMRUN);
+
+	/* Copy user  VM configuration parameters parameters */
+	vm_ptr->vm_usr.vm_vmid 		= vmu_ptr->vm_vmid;
+	vm_ptr->vm_usr.vm_nr_procs 	= vmu_ptr->vm_nr_procs;
+	vm_ptr->vm_usr.vm_nr_tasks 	= vmu_ptr->vm_nr_tasks;
+	vm_ptr->vm_usr.vm_nr_sysprocs 	= vmu_ptr->vm_nr_sysprocs;
+	vm_ptr->vm_usr.vm_nr_nodes 	= vmu_ptr->vm_nr_nodes;
+	strncpy(vm_ptr->vm_usr.vm_name,vmu_ptr->vm_name,MAXVMNAME-1);
+	
+	vm_ptr->vm_usr.vm_flags 		= VM_RUNNING;
+	vm_ptr->vm_usr.vm_nodes 		= 0;
+
+	/*set the VM CPU affinity mask */
+	cpumask_setall(&all_cpumask);
+	if(cpumask_empty(&vmu_ptr->vm_cpumask))	{
+		cpumask_setall(&vm_ptr->vm_usr.vm_cpumask);
+	}else{
+		/* test if the vm_cpumask is a subset of all_cpumask */
+		if( cpumask_subset( &vmu_ptr->vm_cpumask, &all_cpumask)) {
+			cpumask_copy(&vm_ptr->vm_usr.vm_cpumask, &vmu_ptr->vm_cpumask);
+		} else {
+			cpumask_setall(&vm_ptr->vm_usr.vm_cpumask);
+		}
+	}
+
+	/* Set the VM' s NODES bitmap */
+	bm_ptr = &vm_ptr->vm_usr.vm_nodes;
+	set_bit(atomic_read(&local_nodeid), bm_ptr);
+	
+	/* Set the NODE's VMS bitmap */
+	bm_ptr = &node[atomic_read(&local_nodeid)].n_usr.n_vms;
+	set_bit(vm_ptr->vm_usr.vm_vmid, bm_ptr);
+
+	/* ALLOC DYNAMIC memory for an array of pointers to structs proc */  
+	vm_ptr->vm_proc = vmalloc( sizeof_proc_aligned  * (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs)); 
+	if(vm_ptr->vm_proc == NULL)	ERROR_WUNLOCK_VM(vm_ptr, EMOLALLOCMEM);
+
+	MOLDEBUG(INTERNAL,"Initializing VM=%d proc[] table on vm_proc=%p\n", vm_ptr->vm_usr.vm_vmid, vm_ptr->vm_proc);
+	FOR_EACH_PROC(vm_ptr, i) {
+		proc_ptr 		= VM_PROC(vm_ptr,i);
+		init_proc_desc(proc_ptr, vm_ptr->vm_usr.vm_vmid, i);
+		proc_ptr->p_pseudosem 	= 1;
+		proc_ptr->p_usr.p_endpoint	= _ENDPOINT(0,i-vm_ptr->vm_usr.vm_nr_tasks);
+		proc_ptr->p_usr.p_rts_flags	= SLOT_FREE;
+#if LOCK_PROC_TYPE == USE_PROC_RWLOCK
+		rwlock_init(&(proc_ptr->p_rwlock));
+#else	/* USE_PROC_MUTEX*/
+		mutex_init(&(proc_ptr->p_mutex));
+#endif
+	} 
+
+	/* ALLOC DYNAMIC memory for an array of pointers to structs proc  pointers */  
+	vm_ptr->vm_sid2proc = vmalloc(sizeof(struct proc *) * vm_ptr->vm_usr.vm_nr_sysprocs); 
+	if(vm_ptr->vm_sid2proc == NULL)	{
+		vfree(vm_ptr->vm_proc);
+		ERROR_WUNLOCK_VM(vm_ptr, EMOLALLOCMEM);
+	}
+	MOLDEBUG(INTERNAL,"Initializing %d element of system process vector at vm_sid2proc=%p \n", 
+		vm_ptr->vm_usr.vm_nr_sysprocs,vm_ptr->vm_sid2proc);
+
+	for (i = 0; i < (vm_ptr->vm_usr.vm_nr_sysprocs); i++) 
+		vm_ptr->vm_sid2proc[i] = NULL;
+
+	/*creates VM directory under /proc/drvs */
+	vm_ptr->vm_VM_dir = proc_mkdir(vm_ptr->vm_usr.vm_name, proc_drvs_dir);
+
+	/*creates VM entry under /proc/drvs/VMxx */
+	ret = OK;
+	do {
+		vm_ptr->vm_info_entry = create_proc_entry("info", 0444, vm_ptr->vm_VM_dir);
+		if (vm_ptr->vm_info_entry == NULL) {
+			printk("ERROR: %d:%s:%u: Couldn't create info under /proc/drvs/%s\n",
+				current->pid, __FUNCTION__ ,__LINE__, vm_ptr->vm_usr.vm_name); 
+			ret = EMOLBADDIR;
+			break;
+		} else {
+			vm_ptr->vm_info_entry->read_proc = vm_info_read;
+			vm_ptr->vm_info_entry->data = (void*) &vm_ptr->vm_usr.vm_vmid;
+			MOLDEBUG(GENERIC,"/proc/drvs/%s/info installed\n", vm_ptr->vm_usr.vm_name);
+		}
+
+		/*creates VM entry under /proc/drvs/VMxx/procs */
+		vm_ptr->vm_procs_entry = create_proc_entry("procs", 0444, vm_ptr->vm_VM_dir);
+		if (vm_ptr->vm_procs_entry == NULL) {
+			printk("ERROR: %d:%s:%u: Couldn't create procs under /proc/drvs/%s\n",
+				current->pid, __FUNCTION__ ,__LINE__, vm_ptr->vm_usr.vm_name); 
+			ret = EMOLBADFILE;
+			break;
+		} else {
+			vm_ptr->vm_procs_entry->read_proc = vm_procs_read;
+			vm_ptr->vm_procs_entry->data = (void*) &vm_ptr->vm_usr.vm_vmid;
+			MOLDEBUG(GENERIC,"/proc/drvs/%s/procs installed\n", vm_ptr->vm_usr.vm_name);
+
+		}
+		/*creates VM entry under /proc/drvs/VMxx/stats */
+		vm_ptr->vm_stats_entry = create_proc_entry("stats", 0444, vm_ptr->vm_VM_dir);
+		if (vm_ptr->vm_stats_entry == NULL) {
+			printk("ERROR: %d:%s:%u: Couldn't create stats under /proc/drvs/%s\n",
+				current->pid, __FUNCTION__ ,__LINE__, vm_ptr->vm_usr.vm_name); 
+			ret = EMOLBADFILE;
+			break;
+		} else {
+			vm_ptr->vm_stats_entry->read_proc = vm_stats_read;
+			vm_ptr->vm_stats_entry->data = (void*) &vm_ptr->vm_usr.vm_vmid;
+			MOLDEBUG(GENERIC,"/proc/drvs/%s/stats installed\n", vm_ptr->vm_usr.vm_name);
+		}
+	}while(0);
+	kref_init(&vm_ptr->vm_kref);			/* initializa VM reference counter 	*/
+
+    	if(ret) {
+		vm_release(&vm_ptr->vm_kref);
+		WUNLOCK_VM(vm_ptr);
+		ERROR_RETURN(ret);
+	}
+
+	vmu_ptr = &vm_ptr->vm_usr;	
+	MOLDEBUG(INTERNAL,VM_CPU_FORMAT, VM_CPU_FIELDS(vmu_ptr));
+
+	KREF_GET(&drvs_kref); 					/* increment DRVS reference counter 	*/
+	WUNLOCK_VM(vm_ptr);
+	return(atomic_read(&local_nodeid));
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_vm_dmp				*/
+/* Dumps a table of all VMs into dmesg buffer			*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_vm_dump(void)
+{
+	struct  VM_struct *vm_ptr;
+	int i;
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+
+	printk("VMID\tFLAGS\tNAME NODESbitmap\n");
+	for (i = 0; i < drvs.d_nr_vms; i++) {
+		vm_ptr = &vm[i];
+		RLOCK_VM(vm_ptr);
+		if( !vm_ptr->vm_usr.vm_flags)
+			printk("%d\t%X\t%s\t%lX\n",
+				vm_ptr->vm_usr.vm_vmid,
+				vm_ptr->vm_usr.vm_flags,
+				vm_ptr->vm_usr.vm_name,
+				vm_ptr->vm_usr.vm_nodes);
+		RUNLOCK_VM(vm_ptr);
+	} 
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_getdrvsinfo				*/
+/* On return: if (ret >= 0 ) return local_nodeid 		*/
+/*         and the DRVS configuration  parameters 		*/
+/* if ret == -1, the DRVS has not been initialized		*/
+/* if ret < -1, a copy_to_user error has ocurred		*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_getdrvsinfo(drvs_usr_t *drvs_usr_ptr)
+{
+	int rcode;
+	MOLDEBUG(DBGPARAMS,"local_nodeid=%d \n",atomic_read(&local_nodeid));
+	
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	WLOCK_DRVS;
+	COPY_TO_USER_PROC(rcode, &drvs, drvs_usr_ptr, sizeof(drvs_usr_t));
+	WUNLOCK_DRVS;
+	if(rcode) ERROR_RETURN(rcode);
+	return(atomic_read(&local_nodeid));
+}
+
+
+/*--------------------------------------------------------------*/
+/*			mol_getvminfo				*/
+/* Copies the VM entry to userspace				*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_getvminfo(int vmid, VM_usr_t *vm_usr_ptr)
+{
+	int rcode;
+	VM_desc_t *vm_ptr;
+
+	MOLDEBUG(DBGPARAMS,"vmid=%d \n",vmid);
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+
+	CHECK_VMID(vmid);		/* check VM ID limits 	*/
+
+	vm_ptr 		= &vm[vmid];
+	RLOCK_VM(vm_ptr);	
+	COPY_TO_USER_PROC(rcode, &vm_ptr->vm_usr, vm_usr_ptr, sizeof(VM_usr_t));
+	RUNLOCK_VM(vm_ptr);	
+	return(rcode);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_getnodeinfo				*/
+/* Copies the NODE entry to userspace				*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_getnodeinfo(int nodeid, node_usr_t *node_usr_ptr)
+{
+	int rcode;
+	cluster_node_t  *n_ptr;
+    node_usr_t  *nu_ptr;
+
+	MOLDEBUG(DBGPARAMS,"nodeid=%d \n",nodeid);
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+
+	CHECK_NODEID(nodeid);	/* check node ID limits 	*/
+
+	n_ptr 	= &node[nodeid];
+	nu_ptr = &n_ptr->n_usr;
+	MOLDEBUG(DBGPARAMS,NODE_USR_FORMAT,NODE_USR_FIELDS(nu_ptr));
+
+	WLOCK_NODE(n_ptr);
+	COPY_TO_USER_PROC(rcode, &n_ptr->n_usr, node_usr_ptr, sizeof(node_usr_t));
+	WUNLOCK_NODE(n_ptr);
+
+	return(rcode);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_proc_dmp				*/
+/* Dumps a table of process fields of a VM into dmesg buffer	*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_proc_dump(int vmid)
+{
+	int i;
+	struct proc *proc_ptr;
+	VM_desc_t *vm_ptr;
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+
+	CHECK_VMID(vmid);
+	vm_ptr 		= &vm[vmid];
+	
+	RLOCK_VM(vm_ptr);		
+	/* checks if the VM we are talking about is running */
+	CHECK_IF_VM_RUN(vm_ptr);
+
+	printk("VMID\tNR\tENDP\tLPID\tNODE\tFLAGS\tGETF\tSNDT\tWITM\tLSENT\tRSENT\n");
+	FOR_EACH_PROC(vm_ptr, i) {
+		proc_ptr = VM_PROC(vm_ptr,i);
+		RLOCK_PROC(proc_ptr);
+		if (proc_ptr->p_usr.p_rts_flags != SLOT_FREE) {
+			printk("%d\t%d\t%d\t%d\t%d\t%lX\t%d\t%d\t%d\t%ld\t%ld\n",
+			proc_ptr->p_usr.p_vmid,
+			proc_ptr->p_usr.p_nr,
+			proc_ptr->p_usr.p_endpoint,
+			proc_ptr->p_usr.p_lpid,
+			proc_ptr->p_usr.p_nodeid,
+			proc_ptr->p_usr.p_rts_flags,
+			proc_ptr->p_usr.p_getfrom,
+			proc_ptr->p_usr.p_sendto,
+			proc_ptr->p_usr.p_waitmigr,
+			proc_ptr->p_usr.p_lclsent,
+			proc_ptr->p_usr.p_rmtsent);
+		}
+		RUNLOCK_PROC(proc_ptr);
+	} 
+	RUNLOCK_VM(vm_ptr);				/* UP VM_MUTEX*/
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_getprocinfo				*/
+/* Copies a proc descriptor to userspace			*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_getprocinfo(int vmid, int p_nr, struct proc_usr *proc_usr_ptr)
+{
+	int rcode;
+	VM_desc_t *vm_ptr;
+	struct proc *proc_ptr;
+
+	MOLDEBUG(DBGPARAMS,"vmid=%d p_nr=%d\n",vmid, p_nr);
+
+	if(current_euid() != USER_ROOT) 		ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   			ERROR_RETURN(EMOLDRVSINIT );
+
+	CHECK_VMID(vmid);		/* check VM ID limits 	*/
+	vm_ptr 		= &vm[vmid];
+
+	RLOCK_VM(vm_ptr);	
+	if( vm_ptr->vm_usr.vm_flags) 			ERROR_RUNLOCK_VM(vm_ptr,EMOLVMNOTRUN);
+	if( p_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 		
+	 || p_nr >= vm_ptr->vm_usr.vm_nr_procs) 	ERROR_RUNLOCK_VM(vm_ptr,EMOLBADPROC);
+	proc_ptr = NBR2PTR(vm_ptr,p_nr);
+	RLOCK_PROC(proc_ptr);
+	RUNLOCK_VM(vm_ptr);				
+
+	MOLDEBUG(INTERNAL,"lpid=%d name=%s\n", proc_ptr->p_usr.p_lpid, (char*)&proc_ptr->p_usr.p_name);
+	COPY_TO_USER_PROC(rcode, &proc_ptr->p_usr, proc_usr_ptr, sizeof(struct proc_usr));
+	RUNLOCK_PROC(proc_ptr);
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_getproxyinfo					*/
+/* Copies a sproxy and rproxy proc descriptor to userspace  */
+/*--------------------------------------------------------------*/
+asmlinkage long mol_getproxyinfo(int px_nr,  struct proc_usr *sproc_usr_ptr, struct proc_usr *rproc_usr_ptr)
+{
+	int rcode;
+	drvs_usr_t *d_ptr;
+	struct proc *sproxy_ptr, *rproxy_ptr;
+	proxies_t *px_ptr;
+
+
+	MOLDEBUG(DBGPARAMS,"px_nr=%d\n", px_nr);
+
+	if(current_euid() != USER_ROOT) 		ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   			ERROR_RETURN(EMOLDRVSINIT );
+
+	d_ptr = &drvs;
+	if( px_nr < 0 || px_nr >= d_ptr->d_nr_nodes) 	ERROR_RETURN(EMOLBADRANGE);
+
+	px_ptr = &proxies[px_nr];
+	RLOCK_PROXY(px_ptr);
+	if( px_ptr->px_usr.px_flags == PROXIES_FREE)	{
+		RUNLOCK_PROXY(px_ptr);
+		ERROR_RETURN(EMOLNOPROXY);
+	}
+
+	sproxy_ptr = &px_ptr->px_sproxy; 
+	rproxy_ptr = &px_ptr->px_rproxy; 
+	RLOCK_PROC(sproxy_ptr);
+	RLOCK_PROC(rproxy_ptr);
+
+	COPY_TO_USER_PROC(rcode, &proxies[px_nr].px_sproxy, sproc_usr_ptr, sizeof(struct proc_usr));
+	COPY_TO_USER_PROC(rcode, &proxies[px_nr].px_rproxy, rproc_usr_ptr, sizeof(struct proc_usr));
+
+	RUNLOCK_PROC(sproxy_ptr);
+	RUNLOCK_PROC(rproxy_ptr);
+	RUNLOCK_PROXY(px_ptr);
+
+
+	return(rcode);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_bind				*/
+/* Binds (an Initialize) a Linux process to the IPC Kernel	*/
+/* Who can call bind?:						*/
+/* - The main thread of a process to bind itself (mnx_bind)	*/
+/* - The child thread of a process to bind itself (mnx_bind)	*/
+/* - A MOL process that bind a local process (mnx_lclbind)	*/
+/* - A MOL process that bind a remote process (mnx_rmtbind)	*/
+/* - A MOL process that bind a local process that is a backup of*/
+/*	a remote active process (mnx_bkupbind). Then, with	*/
+/*	mol_migrate, the backup process can be converted into   */
+/*	the primary process					*/
+/* Local process: proc = proc number				*/
+/* Remote  process: proc = endpoint 				*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_bind(int oper, int vmid, int pid, int proc, int nodeid)
+{
+	struct proc *proc_ptr, *rproxy, *sproxy, *leader;
+	proc_usr_t *uproc_ptr;
+	VM_desc_t *vm_ptr;
+	int g, i, endpoint, p_nr, rcode;
+	long unsigned int *bm_ptr;
+	struct task_struct *task_ptr,  *leader_ptr;
+	char *uname_ptr;
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+
+	MOLDEBUG(DBGPARAMS,"oper=%d vmid=%d pid=%d proc=%d nodeid=%d\n",oper, vmid, pid, proc, nodeid);
+
+	switch(oper){
+		case SELF_BIND:
+		case LCL_BIND:
+			if( nodeid != LOCALNODE) ERROR_RETURN(EMOLBADNODEID);
+			nodeid = atomic_read(&local_nodeid);
+			p_nr = proc;
+			break;
+		case RMT_BIND:
+			/* The SYSTASK send the endpoint in the proc paramenter */
+			p_nr = _ENDPOINT_P(proc);
+			CHECK_NODEID(nodeid);	/* check node ID limits 	*/
+			if( nodeid == atomic_read(&local_nodeid)) ERROR_RETURN(EMOLBADNODEID);
+			break;
+		case BKUP_BIND:
+			p_nr = _ENDPOINT_P(proc);
+			CHECK_NODEID(nodeid);	/* check node ID limits 	*/
+			if( nodeid == atomic_read(&local_nodeid)) ERROR_RETURN(EMOLBADNODEID);
+			break;
+		default:
+			ERROR_RETURN(EMOLBINDTYPE);
+	}
+
+	CHECK_VMID(vmid);		/* check VM ID limits 	*/
+	vm_ptr 		= &vm[vmid];
+	RLOCK_VM(vm_ptr);
+	do {	
+		rcode = 0;
+		if( vm_ptr->vm_usr.vm_flags) 			{rcode = EMOLVMNOTRUN; break;}
+		if( p_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 		
+		 || p_nr >= vm_ptr->vm_usr.vm_nr_procs) 	{rcode = EMOLBADVMID; break;}
+		bm_ptr = &vm_ptr->vm_usr.vm_nodes;
+		if(!test_bit(nodeid, bm_ptr)) 			{rcode = EMOLNOVMNODE; break;} 
+		i = p_nr+vm_ptr->vm_usr.vm_nr_tasks;
+		proc_ptr = VM_PROC(vm_ptr,i);
+	}while(0);
+	if(rcode) ERROR_RUNLOCK_VM(vm_ptr, rcode);
+
+	WLOCK_PROC(proc_ptr);
+	if(proc_ptr->p_usr.p_rts_flags != SLOT_FREE) {
+		uproc_ptr = &proc_ptr->p_usr;
+		MOLDEBUG(INTERNAL,PROC_USR_FORMAT,PROC_USR_FIELDS(uproc_ptr));
+		WUNLOCK_PROC(proc_ptr);
+		ERROR_RUNLOCK_VM(vm_ptr,EMOLSLOTUSED);
+	} 
+
+	init_proc_desc(proc_ptr, vmid, i);		/* Initialize all process' descriptor fields - PARANOID	*/
+
+	if( oper != RMT_BIND ) {
+		/*
+		* INPUT: process PID 
+		* OUTPUT: task pointer
+		*/
+		if( oper == SELF_BIND){
+			task_ptr = current;	
+			pid = current->pid;
+			MOLDEBUG(INTERNAL,"SELF_BIND PID=%d TGID=%d\n", task_ptr->pid, task_ptr->tgid);
+			LOCK_TASK(task_ptr);	
+			if(!thread_group_leader(task_ptr)) { /* The caller process is NOT the Group Leader 	*/
+				if( current->tgid == pid){		/* the main process group  has called bind	*/		
+					pid = current->pid;
+					task_ptr = current;
+				} else {						/* other process has called bind for this group pid 	*/
+					UNLOCK_TASK(task_ptr);	
+					read_lock(&tasklist_lock);
+					task_ptr = pid_task(find_vpid(pid), PIDTYPE_PID);  
+					if(task_ptr == NULL ) {
+						read_unlock(&tasklist_lock);
+						WUNLOCK_PROC(proc_ptr);
+						ERROR_RUNLOCK_VM(vm_ptr, EMOLBADPROC);
+					}
+					read_unlock(&tasklist_lock);
+					LOCK_TASK(task_ptr);	
+				}
+			}
+		}else{
+			read_lock(&tasklist_lock);
+			task_ptr = pid_task(find_vpid(pid), PIDTYPE_PID);  
+			if(task_ptr == NULL ) {
+				read_unlock(&tasklist_lock);
+				UNLOCK_TASK(task_ptr);	
+				WUNLOCK_PROC(proc_ptr);
+				ERROR_RUNLOCK_VM(vm_ptr, EMOLBADPROC);
+			}
+			read_unlock(&tasklist_lock);
+			LOCK_TASK(task_ptr);	
+			MOLDEBUG(INTERNAL,"LCL_BIND Linux Task PID=%d TGID=%d\n", task_ptr->pid, task_ptr->tgid);		
+		}
+		
+		/*
+		* task_ptr is LOCKED
+		* proc_ptr is LOCKED
+		* vm_ptr is LOCKED
+		* Check that the MAIN thread is binded to the same VM !!
+		*/
+		if(!thread_group_leader(task_ptr)) {
+			leader_ptr= task_ptr->group_leader;		/* get the leader task pointer 		*/
+			LOCK_TASK(leader_ptr);
+			leader =  leader_ptr->proc_ptr;			/*get the leader process pointer 		*/
+			RLOCK_PROC(leader);
+			if(leader->p_usr.p_vmid != vmid) {
+				RUNLOCK_PROC(leader);	
+				UNLOCK_TASK(leader_ptr);
+				UNLOCK_TASK(task_ptr);			
+				WUNLOCK_PROC(proc_ptr);
+				ERROR_RUNLOCK_VM(vm_ptr, EMOLBADPROC);				
+			}
+			RUNLOCK_PROC(leader);	
+			UNLOCK_TASK(leader_ptr);	
+		}
+		
+		MOLDEBUG(INTERNAL,"increment the reference count of the task struct=%d count=%d\n"
+			,task_ptr->pid,atomic_read(&task_ptr->usage)); 
+		get_task_struct(task_ptr);		/* increment the reference count of the task struct */
+		proc_ptr->p_task = task_ptr;		/* Set the task descriptor into the process descriptor */
+		task_ptr->proc_ptr = (struct proc *) proc_ptr;	/* Set the  process descriptor into the task descriptor */
+		strncpy((char* )&proc_ptr->p_usr.p_name, (char*)task_ptr->comm, MAXPROCNAME-1);
+		proc_ptr->p_name_ptr = (char*)task_ptr->comm;
+		if( thread_group_leader(task_ptr)) 
+			proc_ptr->p_usr.p_misc_flags = MIS_GRPLEADER;	/* The proccess is the thread group leader 	*/		
+		UNLOCK_TASK(task_ptr);
+
+		MOLDEBUG(INTERNAL,"process p_name=%s *p_name_ptr=%s\n", (char*)&proc_ptr->p_usr.p_name, proc_ptr->p_name_ptr);
+		
+		if( oper == BKUP_BIND) {
+			proc_ptr->p_usr.p_rts_flags	= REMOTE;	/* appears as if it is REMOTE		*/
+			proc_ptr->p_usr.p_misc_flags	|= MIS_RMTBACKUP;/* It is a remote process' backup 	*/
+			proc_ptr->p_usr.p_nodeid	= nodeid;	/* The primary process node's ID 	*/	
+		}else{
+			proc_ptr->p_usr.p_rts_flags	= PROC_RUNNING;	/* set to RUNNING STATE	*/
+			proc_ptr->p_usr.p_nodeid	= atomic_read(&local_nodeid);	
+		}
+
+		proc_ptr->p_usr.p_lpid 	= pid;			/* Update PID		*/
+		if( i < vm_ptr->vm_usr.vm_nr_sysprocs) {
+			proc_ptr->p_usr.p_endpoint = _ENDPOINT(0,proc_ptr->p_usr.p_nr);
+			proc_ptr->p_priv.s_usr.s_id = i;
+		}else{
+			g = _ENDPOINT_G(proc_ptr->p_usr.p_endpoint);	/* Update endpoint 	*/
+			if(++g >= _ENDPOINT_MAX_GENERATION)		/* increase generation */
+				g = 1;					/* generation number wraparound */
+			proc_ptr->p_usr.p_endpoint = _ENDPOINT(g,proc_ptr->p_usr.p_nr);
+			proc_ptr->p_priv.s_usr.s_id = 0;
+		}
+
+		cpumask_copy(&proc_ptr->p_usr.p_cpumask, &vm_ptr->vm_usr.vm_cpumask);
+		
+		if( oper != BKUP_BIND) {
+			if( current->pid != pid && current->tgid != pid)	/* Other process request the binding por PID */	
+				wake_up_process(task_ptr);			/* Wakes up it as if has in wait4bind state  */
+		}
+	}else{
+		/****************************************************************/
+		/* la SYSTASK es responsable de enviar BIND a las otras SYSTASK */
+		/* y cada SYSTASK remota hace un rmt_bind() 			*/
+		/****************************************************************/
+		sproxy = NODE2SPROXY(nodeid);
+		rproxy = NODE2RPROXY(nodeid);
+
+		RLOCK_PROC(sproxy);
+		RLOCK_PROC(rproxy);
+		/* To bind a REMOTE processes, the local proxies must be active */
+		if ( rproxy->p_usr.p_rts_flags == SLOT_FREE || 
+			 sproxy->p_usr.p_rts_flags == SLOT_FREE ){
+			RUNLOCK_PROC(sproxy);
+			RUNLOCK_PROC(rproxy);
+	 		WUNLOCK_PROC(proc_ptr);
+			ERROR_RUNLOCK_VM(vm_ptr,EMOLNOPROXY);
+		}
+		RUNLOCK_PROC(sproxy);
+		RUNLOCK_PROC(rproxy);
+		
+		proc_ptr->p_usr.p_rts_flags = REMOTE;			
+		proc_ptr->p_usr.p_nodeid   = nodeid;
+		if( i < vm_ptr->vm_usr.vm_nr_sysprocs) {
+			proc_ptr->p_priv.s_usr.s_id = i;
+		}else{
+			proc_ptr->p_priv.s_usr.s_id = 0;
+		}
+		uname_ptr = (char *) pid; /* if LOCAL => pid=PID, if REMOTE => pid= name[] */ 
+		rcode = copy_from_user(proc_ptr->p_usr.p_name,uname_ptr,MAXPROCNAME-1);
+	}
+
+	set_bit(proc_ptr->p_usr.p_nodeid, &proc_ptr->p_usr.p_nodemap);
+
+	uproc_ptr = &proc_ptr->p_usr;
+	MOLDEBUG(INTERNAL,PROC_USR_FORMAT,PROC_USR_FIELDS(uproc_ptr));
+	MOLDEBUG(INTERNAL,PROC_CPU_FORMAT,PROC_CPU_FIELDS(uproc_ptr));
+
+	endpoint = proc_ptr->p_usr.p_endpoint;
+	
+	VM_INCREF(vm_ptr);
+	WUNLOCK_PROC(proc_ptr);
+	RUNLOCK_VM(vm_ptr);	
+
+	return(endpoint);
+}
+
+/*--------------------------------------------------------------*/
+/*			do_autobind				*/
+/* Binds (an Initialize) a REMOTE process descriptor 		*/
+/* VM must be locked						*/
+/* the process descriptor must be locked			*/
+/*--------------------------------------------------------------*/
+long do_autobind(VM_desc_t *vm_ptr, struct proc *rmt_ptr, int endpoint, int nodeid)
+{
+	struct proc *proc_ptr, *rproxy, *sproxy;
+	int i, p_nr;
+	proc_usr_t *uproc_ptr;
+	long unsigned int *bm_ptr;
+
+	MOLDEBUG(DBGPARAMS,"vmid=%d endpoint=%d nodeid=%d \n",vm_ptr->vm_usr.vm_vmid, endpoint, nodeid);
+
+	CHECK_VMID(vm_ptr->vm_usr.vm_vmid);		/* check VM ID limits 	*/
+
+	p_nr = _ENDPOINT_P(endpoint);
+	if( p_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 		
+	 || p_nr >= vm_ptr->vm_usr.vm_nr_procs) 	ERROR_RETURN(EMOLBADVMID);
+
+	if( rmt_ptr->p_usr.p_nr != p_nr)		ERROR_RETURN(EMOLBADPROC);
+
+	CHECK_NODEID(nodeid);	/* check node ID limits 	*/
+
+	bm_ptr = &vm_ptr->vm_usr.vm_nodes;
+	if(!test_bit(nodeid, bm_ptr)) 			ERROR_RETURN(EMOLNOVMNODE);
+	i = p_nr+vm_ptr->vm_usr.vm_nr_tasks;
+	proc_ptr = VM_PROC(vm_ptr,i);
+	if(proc_ptr->p_usr.p_rts_flags != SLOT_FREE)	ERROR_RETURN(EMOLSLOTUSED);
+
+	init_proc_desc(proc_ptr, vm_ptr->vm_usr.vm_vmid, i);	/* Initialize all process descriptor fields	*/
+
+	if( nodeid == atomic_read(&local_nodeid)) 	ERROR_RETURN(EMOLBADNODEID);
+
+	sproxy = NODE2SPROXY(nodeid);
+	rproxy = NODE2RPROXY(nodeid);
+
+	/* To bind a REMOTE processes, the local proxies must be active */
+	if ( rproxy->p_usr.p_rts_flags == SLOT_FREE || 
+		 sproxy->p_usr.p_rts_flags == SLOT_FREE ) ERROR_RETURN(EMOLNOPROXY);
+
+	proc_ptr->p_usr.p_rts_flags = REMOTE;		/* set to RUNNING on REMOTE host */
+	proc_ptr->p_usr.p_endpoint = endpoint;
+	proc_ptr->p_usr.p_nodeid   = nodeid;
+	if( i < vm_ptr->vm_usr.vm_nr_sysprocs) {
+		proc_ptr->p_priv.s_usr.s_id = i;
+	}else{
+		proc_ptr->p_priv.s_usr.s_id = 0;
+	}
+
+	strcpy(proc_ptr->p_usr.p_name,"remote");
+	
+	set_bit(proc_ptr->p_usr.p_nodeid, &proc_ptr->p_usr.p_nodemap);
+
+	proc_ptr->p_usr.p_cpumask = vm_ptr->vm_usr.vm_cpumask;
+	endpoint = proc_ptr->p_usr.p_endpoint;
+
+	uproc_ptr = &proc_ptr->p_usr;
+	MOLDEBUG(INTERNAL,PROC_USR_FORMAT,PROC_USR_FIELDS(uproc_ptr));
+	MOLDEBUG(INTERNAL,PROC_CPU_FORMAT,PROC_CPU_FIELDS(uproc_ptr));
+	
+	VM_INCREF(vm_ptr);
+	return(endpoint);
+}
+
+/*----------------------------------------------------------------*/
+/*			mol_void				*/
+/*----------------------------------------------------------------*/
+asmlinkage long mol_void(void)
+{
+MOLDEBUG(GENERIC,"MOL_VOID \n");
+return(OK);
+}
+
+/*----------------------------------------------------------------*/
+/*			do_vm_end				*/
+/*VM MUTEX Must be WRITE LOCKED					*/
+/* When a VM ends:						*/
+/*	- Sends SIGPIPE to every LOCAL process of the VM	*/
+/*	- Waits that all LOCAL processes unbind by their self 	*/
+/*	*/
+/*----------------------------------------------------------------*/
+long do_vm_end(VM_desc_t *vm_ptr)
+{
+	int i, ret;
+	struct proc *proc_ptr, *tmp_ptr; 	
+	struct task_struct *task_ptr;	
+	wait_queue_head_t wqhead;
+
+	if(vm_ptr->vm_usr.vm_flags == VM_FREE) {
+		ERROR_RETURN(EMOLVMNOTRUN);
+	}
+	
+	init_waitqueue_head(&wqhead);
+	
+	MOLDEBUG(INTERNAL,"Send a SIGPIPE SIGNAL to all LOCAL processes belonging to the VM:%d\n",vm_ptr->vm_usr.vm_vmid);
+	
+	LOCK_ALL_PROCS(vm_ptr, tmp_ptr, i);
+	
+	FOR_EACH_PROC(vm_ptr, i) {
+		proc_ptr = VM_PROC(vm_ptr,i);
+		if( proc_ptr->p_usr.p_rts_flags != SLOT_FREE) {
+			if( IT_IS_LOCAL(proc_ptr) || test_bit(MIS_BIT_RMTBACKUP, &proc_ptr->p_usr.p_misc_flags) ) {
+				task_ptr = proc_ptr->p_task;
+				ret = send_sig_info(SIGKILL , SEND_SIG_NOINFO, task_ptr);
+				if(ret) ERROR_PRINT(ret);
+			}else{
+				do_unbind(vm_ptr, proc_ptr, proc_ptr->p_usr.p_nodeid);
+			}
+		}
+	}
+	UNLOCK_ALL_PROCS(vm_ptr, tmp_ptr, i);
+
+	FOR_EACH_PROC(vm_ptr, i) {
+		proc_ptr = VM_PROC(vm_ptr,i);
+		WLOCK_PROC(proc_ptr);
+		while( proc_ptr->p_usr.p_rts_flags != SLOT_FREE) {
+			if( IT_IS_LOCAL(proc_ptr) || test_bit(MIS_BIT_RMTBACKUP, &proc_ptr->p_usr.p_misc_flags) ) {
+				task_ptr = proc_ptr->p_task;
+/*
+				WUNLOCK_PROC(proc_ptr);
+				WUNLOCK_VM(vm_ptr);
+				do {
+					ret = wait_event_interruptible(wqhead,(proc_ptr->p_usr.p_rts_flags == SLOT_FREE));
+				}while(ret != 0);
+				WLOCK_VM(vm_ptr);
+				WLOCK_PROC(proc_ptr);
+*/
+				sys_wait4(task_ptr->pid, (int __user *)&ret, 0, NULL);
+				WUNLOCK_PROC(proc_ptr);	
+				WUNLOCK_VM(vm_ptr);
+				schedule();
+				WLOCK_VM(vm_ptr);
+				WLOCK_PROC(proc_ptr);	
+			}
+		}
+		WUNLOCK_PROC(proc_ptr);
+	}
+
+
+	/* clears the VM bit on all nodes of the ending VM */
+	for( i = 0; i < drvs.d_nr_nodes ; i++){
+		if( test_bit(i, &vm_ptr->vm_usr.vm_nodes)){
+			clear_bit(vm_ptr->vm_usr.vm_vmid, &node[i].n_usr.n_vms);
+		}
+	}
+
+	vm_ptr->vm_usr.vm_flags = VM_FREE;
+
+	VM_DECREF(vm_ptr); 	/* it calls function vm_release when count=0 */
+
+	KREF_PUT(&drvs_kref, drvs_release); 	/* it calls function drvs_release when count=0 !!! NEVER HERE !!! */
+
+	return(OK);
+}
+
+/*----------------------------------------------------------------*/
+/*			vm_release							*/
+/*----------------------------------------------------------------*/
+void vm_release(struct kref *kref)	
+{
+	VM_desc_t *vm_ptr;
+	long unsigned int *bm_ptr;
+	cluster_node_t *n_ptr;
+	int i;
+
+	vm_ptr = container_of(kref, struct VM_struct, vm_kref);
+
+	MOLDEBUG(INTERNAL,"release memory from processes of VM=%d\n", vm_ptr->vm_usr.vm_vmid);		
+
+	/* Free process descriptors memory */
+	vfree(vm_ptr->vm_proc);
+
+	/* Free system process descriptors memory */
+	vfree(vm_ptr->vm_sid2proc);
+	
+	/* Clears the VM's NODES bitmap */
+	vm_ptr->vm_usr.vm_nodes = 0;
+
+	/* Clear NODEs' VM bitmaps */
+	for( i = 0;  i < drvs.d_nr_nodes; i++) {
+		n_ptr = &node[i];
+		if (n_ptr->n_usr.n_flags != NODE_FREE){
+			bm_ptr = &n_ptr->n_usr.n_vms;
+			if( test_bit(vm_ptr->vm_usr.vm_vmid, bm_ptr))
+				clear_bit(vm_ptr->vm_usr.vm_vmid, bm_ptr);
+		}
+	}
+
+	/*free the VM descriptor */
+	vm_ptr->vm_usr.vm_flags = VM_FREE;
+
+	/* remove /proc/drvs/VMx entries */
+	remove_proc_entry("procs", vm_ptr->vm_VM_dir);
+	remove_proc_entry("info", vm_ptr->vm_VM_dir);
+	remove_proc_entry("stats", vm_ptr->vm_VM_dir);
+
+    	remove_proc_entry(vm_ptr->vm_usr.vm_name, proc_drvs_dir);
+		
+}
+
+/*----------------------------------------------------------------*/
+/*			mol_vm_end				*/
+/*----------------------------------------------------------------*/
+
+asmlinkage long mol_vm_end(int vmid)
+{
+	VM_desc_t *vm_ptr;
+	int rcode = OK;
+	
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+
+	MOLDEBUG(DBGPARAMS,"Ending VM=%d on node=%d\n", vmid, atomic_read(&local_nodeid));
+
+	CHECK_VMID(vmid);
+	vm_ptr 	= &vm[vmid];
+
+	WLOCK_VM(vm_ptr);	
+	if(vm_ptr->vm_usr.vm_flags != VM_FREE) {
+		rcode = do_vm_end(vm_ptr);	
+	}else {
+		rcode = EMOLVMNOTRUN;
+	}
+	WUNLOCK_VM(vm_ptr);	
+	if( rcode) ERROR_RETURN(rcode);
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_getep				*/
+/*--------------------------------------------------------------*/
+
+asmlinkage long mol_getep(int pid)
+{
+	struct proc *caller_ptr,*proc_ptr;
+	VM_desc_t *vm_ptr;
+	int vmid, ret;
+	struct task_struct *task_ptr;	
+	int caller_pid;
+	int endpoint=NONE;
+
+	if( DRVS_NOT_INIT() )   	ERROR_RETURN(EMOLDRVSINIT );
+
+	MOLDEBUG(DBGPARAMS,"pid=%d\n",pid);
+	if( pid < 1 || pid > PID_MAX) 	ERROR_RETURN(EMOLBADRANGE);
+
+	ret = check_lock_caller(&task_ptr, &caller_ptr, &caller_pid);
+	if(ret) ERROR_RETURN(ret);
+
+	MOLDEBUG(INTERNAL,"caller_pid=%d vmid=%d\n",caller_pid, caller_ptr->p_usr.p_vmid);
+
+	CHECK_VMID(caller_ptr->p_usr.p_vmid);
+
+	ret = OK;
+	if( caller_pid != pid) { 	
+
+		read_lock(&tasklist_lock);
+		task_ptr= pid_task(find_vpid(pid), PIDTYPE_PID);   
+		read_unlock(&tasklist_lock);
+		if(task_ptr == NULL) 		ERROR_RETURN(EMOLBADPID);
+
+		MOLDEBUG(INTERNAL,"task_ptr->pid=%d\n",task_ptr->pid);
+
+		/*-----------------------------------
+		 * check TASK state
+		 *-----------------------------------*/
+
+		proc_ptr = (struct proc *) task_ptr->proc_ptr;
+		if( proc_ptr == NULL)	ERROR_RETURN(EMOLNOTBIND);
+
+		/*-----------------------------------
+		 * check VM state
+		 *-----------------------------------*/
+		vmid		= proc_ptr->p_usr.p_vmid;
+		vm_ptr 	= &vm[vmid];
+		MOLDEBUG(INTERNAL,"vmid=%d\n",vmid);
+
+		RLOCK_VM(vm_ptr);
+		if( vm_ptr->vm_usr.vm_flags) 
+			ret = EMOLVMNOTRUN;
+		RUNLOCK_VM(vm_ptr);
+		if(ret) {
+			ERROR_RETURN(ret);	
+		}
+
+		/*-----------------------------------
+	 	* check PROC state
+	 	*-----------------------------------*/
+
+		RLOCK_PROC(proc_ptr);	
+		do	{
+			if (pid != proc_ptr->p_usr.p_lpid)
+				{ret = EMOLBADPID; break;}
+			if( proc_ptr->p_usr.p_rts_flags == SLOT_FREE )
+				{ret = EMOLNOTBIND; break;}
+			if(test_bit(MIS_BIT_PROXY, &proc_ptr->p_usr.p_misc_flags))
+				{ret = EMOLBADPROC;break;}
+			if(caller_ptr->p_usr.p_vmid != proc_ptr->p_usr.p_vmid)
+				{ret = EMOLBADVMID; break;}
+	   		endpoint = proc_ptr->p_usr.p_endpoint;
+		}while(0);
+		RUNLOCK_PROC(proc_ptr);
+	} else {
+		vm_ptr 	= &vm[caller_ptr->p_usr.p_vmid];
+		RLOCK_VM(vm_ptr);
+		if(vm_ptr->vm_usr.vm_flags) 
+			ret = EMOLVMNOTRUN;
+		RUNLOCK_VM(vm_ptr);
+   		if(!ret) endpoint = caller_ptr->p_usr.p_endpoint;
+	}
+	WUNLOCK_PROC(caller_ptr);
+	if(ret) ERROR_RETURN(ret);
+	MOLDEBUG(INTERNAL,"endpoint=%d\n",endpoint);
+	return(endpoint);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_unbind				*/
+/* Unbind a  LOCAL/REMOTE  process from the DRVS */
+/* Who can mol_unbind a process?:				*/
+/* - The main thread of a LOCAL process itself		*/
+/* - The child thread of a LOCAL process itself		*/
+/* - A system process that unbind a remote process	*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_unbind(int vmid, int proc_ep) 
+{
+	VM_desc_t *vm_ptr;
+	long unsigned int *bm_ptr;
+	struct proc *proc_ptr,  *caller_ptr;
+	int p_nr, nodeid;
+	struct task_struct *task_ptr = NULL;
+	int ret = OK;
+	
+	MOLDEBUG(DBGPARAMS,"vmid=%d proc_ep=%d\n",vmid, proc_ep);
+
+	if(current_euid() != USER_ROOT) 			ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   				ERROR_RETURN(EMOLDRVSINIT );
+
+	CHECK_VMID(vmid);	/* check VM ID limits 		*/
+	
+	vm_ptr 		= &vm[vmid];
+	RLOCK_VM(vm_ptr);
+	/* checks if the VM we are talking about is running */
+	if( vm_ptr->vm_usr.vm_flags) 				ERROR_RUNLOCK_VM(vm_ptr,EMOLVMNOTRUN);
+
+	p_nr = _ENDPOINT_P(proc_ep);
+	if( p_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 		
+	 || p_nr >= vm_ptr->vm_usr.vm_nr_procs) 		ERROR_RUNLOCK_VM(vm_ptr,EMOLENDPOINT);
+	bm_ptr = &vm_ptr->vm_usr.vm_nodes;
+	
+ 	proc_ptr     = ENDPOINT2PTR(vm_ptr, proc_ep);
+	RLOCK_PROC(proc_ptr);
+	RUNLOCK_VM(vm_ptr);
+
+    nodeid = proc_ptr->p_usr.p_nodeid; 
+	if( nodeid < 0 || nodeid >= drvs.d_nr_nodes)	ERROR_RUNLOCK_PROC(proc_ptr,EMOLBADNODEID);
+	if(!test_bit(nodeid, bm_ptr)) 					ERROR_RUNLOCK_PROC(proc_ptr,EMOLNOVMNODE);
+
+	caller_ptr = current->proc_ptr;
+	if( IT_IS_LOCAL(proc_ptr)) {
+		if( caller_ptr == proc_ptr ) {					/* Self unbind				*/
+			if( current->pid != proc_ptr->p_usr.p_lpid) {		/* the thread is not binded 		*/
+				if(current->tgid != proc_ptr->p_usr.p_lpid) {	/* the main thread is not binded too 	*/
+					ERROR_RUNLOCK_PROC(proc_ptr,EMOLNOTBIND);
+				}else{
+					RUNLOCK_PROC(proc_ptr);
+					task_ptr = caller_ptr->p_task;
+					LOCK_TASK(task_ptr);
+				}
+			}else{
+				RUNLOCK_PROC(proc_ptr);
+				task_ptr = caller_ptr->p_task;
+				LOCK_TASK(task_ptr);
+			}
+		}else{
+			RUNLOCK_PROC(proc_ptr);
+		}
+	}else{
+		RUNLOCK_PROC(proc_ptr);
+	}
+
+	/* On input VM is LOCKED */
+	RLOCK_VM(vm_ptr);
+	WLOCK_PROC(proc_ptr);
+	ret = do_unbind(vm_ptr, proc_ptr, nodeid);
+	WUNLOCK_PROC(proc_ptr);
+	RUNLOCK_VM(vm_ptr);
+
+	if( caller_ptr == proc_ptr ) 
+		UNLOCK_TASK(task_ptr);
+
+	return(ret);
+}
+ 
+ /*--------------------------------------------------------------*/
+/*		do_unbind				*/
+/* Unbind a  LOCAL/REMOTE  process from the DRVS 	*/
+/* LOCK IN THIS ORDER					*/
+/* TASK MUTEX must be LOCKED			*/
+/* VM MUTEX must be LOCKED	 			*/
+/* PROC MUTEX must be LOCKED				*/
+/* Who can invoke do_unbind ??				*/
+/* 1- the caller: calling mol_unbind			*/
+/* 2- the caller: through exit() 			*/
+/* 3- the caller: has received a signal ERESTARTSYS	*/
+/* 4- another process that unbind a REMOTE process	*/
+/* 5- another process that does vm_end or drvs_end	*/
+/* Tasks made by do_unbind:				*/
+/* 	- If the process is a BACKUP, convert it into a REMOTE	*/
+/*	- wakeup with error all process trying to send 	*/
+/*		a message to the unbinding process 	*/
+/*	- delete notify messages bits sent by the proc	*/
+/*	- Wakeup with error all process that are waiting*/
+/*		to receive a message from the unbinding */
+/*	- Removes the unbinding process descriptor from */
+/*		proxy SENDER queue			*/
+/*--------------------------------------------------------------*/
+asmlinkage long do_unbind(VM_desc_t *vm_ptr, struct proc *proc_ptr, int nodeid)
+{
+	struct proc *src_ptr, *rp, *tmp_ptr, *caller_ptr, *sproxy_ptr;
+	long unsigned int *bm_ptr;
+	proc_usr_t *uproc_ptr;
+	int i, vmid, rcode;
+	int caller_pid, other_pid;
+	struct task_struct *task_ptr;
+
+#ifdef WARN_PROC
+	int warn_ep;
+	struct proc *warn_ptr; 
+#endif /* WARN_PROC */
+	
+	MOLDEBUG(DBGPARAMS,"vmid=%d endpoint=%d lpid=%d nodeid=%d flags=%lX pseudosem=%d\n",
+		vm_ptr->vm_usr.vm_vmid, proc_ptr->p_usr.p_endpoint, proc_ptr->p_usr.p_lpid,proc_ptr->p_usr.p_nodeid, 
+		proc_ptr->p_usr.p_rts_flags, proc_ptr->p_pseudosem );
+
+	do {
+		rcode = OK;
+		if(test_bit(BIT_SLOT_FREE, &proc_ptr->p_usr.p_rts_flags)) 	{rcode = EMOLNOTBIND; break;}
+		if(test_bit(BIT_NO_ENDPOINT, &proc_ptr->p_usr.p_rts_flags)) 	{rcode = EMOLENDPOINT; break;}
+		if(test_bit(MIS_BIT_PROXY, &proc_ptr->p_usr.p_misc_flags)) 	{rcode = EMOLBADPROC; break;}
+		vmid = vm_ptr->vm_usr.vm_vmid;
+		if(proc_ptr->p_usr.p_vmid != vmid)  				{rcode = EMOLBADVMID; break;}
+		if(proc_ptr->p_usr.p_rts_flags == SLOT_FREE) 			{rcode = EMOLDSTDIED; break;}
+	}while(0);
+	if( rcode) ERROR_RETURN(rcode);
+	
+	/* test that the nodeid belongs to the VM */
+	bm_ptr = &vm_ptr->vm_usr.vm_nodes;
+
+	/*Gets the caller of this function */
+	caller_ptr = current->proc_ptr;
+	if(caller_ptr != NULL) {
+		if( nodeid == atomic_read(&local_nodeid) || nodeid == LOCALNODE) {
+			/* checks if we are talking about the same process */
+			caller_pid = current->pid;
+			CHECK_PID(caller_pid, caller_ptr);
+			if( caller_ptr->p_usr.p_rts_flags != 0)		ERROR_RETURN(EMOLPROCSTS);
+			MOLDEBUG(INTERNAL,"Caller endpoint=%d lpid=%d\n", 
+				caller_ptr->p_usr.p_endpoint, caller_ptr->p_usr.p_lpid);
+			if( IT_IS_REMOTE(proc_ptr)) 			ERROR_RETURN(EMOLBADNODEID);
+			if(!test_bit(proc_ptr->p_usr.p_nodeid, bm_ptr))	ERROR_RETURN(EMOLNOVMNODE);
+		} else {
+			if(!test_bit(nodeid, bm_ptr)) 			ERROR_RETURN(EMOLNOVMNODE);
+			if(proc_ptr->p_usr.p_nodeid != nodeid) 		ERROR_RETURN(EMOLBADNODEID);
+		}
+	}
+
+	if( caller_ptr != proc_ptr){
+		if( IT_IS_LOCAL(proc_ptr)) {
+			MOLDEBUG(INTERNAL,"Sending SIGPIPE to pid=%d\n", proc_ptr->p_usr.p_lpid);
+			rcode = send_sig_info(SIGPIPE, SEND_SIG_NOINFO, proc_ptr->p_task);
+			if(rcode) ERROR_RETURN(rcode);
+			/* Waits until the target process unbinds */
+			other_pid = proc_ptr->p_usr.p_lpid;
+			WUNLOCK_PROC(proc_ptr);
+			RUNLOCK_VM(vm_ptr);
+			do {
+				rcode = wait_event_interruptible(caller_ptr->p_wqhead,(other_pid != proc_ptr->p_usr.p_lpid));
+				MOLDEBUG(INTERNAL,"other_pid=%d pid=%d\n",other_pid, proc_ptr->p_usr.p_lpid);
+				}while(rcode != 0);
+			RLOCK_VM(vm_ptr);
+			WLOCK_PROC(proc_ptr);
+			MOLDEBUG(INTERNAL,"other_pid=%d pid=%d\n",other_pid, proc_ptr->p_usr.p_lpid);
+			return(OK);
+		}
+	}
+//	else{
+//		del_timer_sync(&proc_ptr->p_timer);
+//	}
+
+	/*
+	* Test if the unbinding process is a BACKUP. If it is, keep the descriptor as a REMOTE
+	*/
+//	unset_node_bit(proc_ptr->p_usr.p_nodemap,nodeid);
+
+	task_ptr = proc_ptr->p_task;
+	if(test_bit(MIS_BIT_RMTBACKUP, &proc_ptr->p_usr.p_misc_flags)) { /* it is a remote process' backup */
+		/* Convert the BACKUP descriptor into a REMOTE descriptor */
+		clear_bit(MIS_BIT_RMTBACKUP, &proc_ptr->p_usr.p_misc_flags);
+		clear_bit(nodeid, &proc_ptr->p_usr.p_nodemap);
+		proc_ptr->p_usr.p_lpid = PROC_NO_PID;
+		task_ptr->proc_ptr = NULL;
+		proc_ptr->p_task = NULL;
+		VM_DECREF(vm_ptr);
+		put_task_struct(task_ptr);		/* decrement the reference count of the task struct */
+		return(OK);
+	}
+
+	/*--------------------------------------*/
+	/* wakeup with error all process	*/
+	/* trying to send a message to the proc	*/
+	/*--------------------------------------*/
+	MOLDEBUG(INTERNAL,"wakeup with error all process trying to send a message to the proc\n");
+	list_for_each_entry_safe(src_ptr, tmp_ptr, &proc_ptr->p_list, p_link) {
+		if( proc_ptr->p_usr.p_nr < src_ptr->p_usr.p_nr) {
+			WLOCK_PROC(src_ptr); /* Caller LOCK is just locked */
+		}else{	
+			/* free the callers lock and then lock both ordered */
+			WUNLOCK_PROC(proc_ptr);
+			WLOCK_PROC(src_ptr);
+			WLOCK_PROC(proc_ptr);
+		}
+
+		list_del(&src_ptr->p_link); /* remove from queue */
+
+		MOLDEBUG(INTERNAL,"Find process %d trying to send a message to %d\n",
+			src_ptr->p_usr.p_endpoint, proc_ptr->p_usr.p_endpoint);
+		clear_bit(BIT_SENDING, &src_ptr->p_usr.p_rts_flags);
+		if( IT_IS_LOCAL(src_ptr)) {
+			MOLDEBUG(INTERNAL,"Wakeup SENDER with error ep=%d  pid=%d\n",
+				src_ptr->p_usr.p_endpoint, src_ptr->p_usr.p_lpid);	
+			LOCAL_PROC_UP(src_ptr, EMOLDSTDIED);
+		} else {
+			send_ack_lcl2rmt(src_ptr,proc_ptr,EMOLDSTDIED);
+		}
+		WUNLOCK_PROC(src_ptr);
+	}
+	
+	MOLDEBUG(GENERIC,"delete notify messages bits sent by the proc\n");
+	FOR_EACH_PROC(vm_ptr, i) {
+		rp = VM_PROC(vm_ptr,i);
+		if( rp->p_usr.p_rts_flags == SLOT_FREE || rp == proc_ptr) continue;
+		
+		/* Remove any notify message from the process */ 		
+		if( proc_ptr->p_priv.s_usr.s_id < vm_ptr->vm_usr.vm_nr_sysprocs) {
+			if( get_sys_bit(rp->p_priv.s_notify_pending, proc_ptr->p_priv.s_usr.s_id)) {
+				MOLDEBUG(INTERNAL,"Delete the bit %d in the notify bitmap of processes %d \n", 
+					proc_ptr->p_priv.s_usr.s_id, rp->p_usr.p_endpoint);
+				unset_sys_bit(rp->p_priv.s_notify_pending, proc_ptr->p_priv.s_usr.s_id);
+			}
+		}
+
+		/* it onother  LOCAL process is waiting to receive a message from the unbinded process, inform that is exit. */ 
+		if( (!test_bit(BIT_SENDING, &rp->p_usr.p_rts_flags) && test_bit(BIT_RECEIVING, &rp->p_usr.p_rts_flags) ) 
+			&& (rp->p_usr.p_getfrom == proc_ptr->p_usr.p_endpoint)) {
+			MOLDEBUG(INTERNAL,"Process %d is no more waiting a message from the unbinded process %d\n",
+				rp->p_usr.p_endpoint, proc_ptr->p_usr.p_endpoint);
+			if( IT_IS_LOCAL(rp)) {
+				MOLDEBUG(INTERNAL,"Wakeup RECEIVER with error ep=%d  pid=%d\n",
+					rp->p_usr.p_endpoint, rp->p_usr.p_lpid);
+				LOCAL_PROC_UP(rp, EMOLSRCDIED);
+			}
+		}
+	}
+
+	uproc_ptr = &proc_ptr->p_usr;
+	MOLDEBUG(INTERNAL,PROC_USR_FORMAT,PROC_USR_FIELDS(uproc_ptr));
+
+	/* Removes the unbinding process descriptor from proxy SENDER queue */
+	if( test_bit(BIT_RMTOPER, &proc_ptr->p_usr.p_rts_flags)) {
+		if(proc_ptr->p_usr.p_proxy != PROC_NO_PID) {
+			sproxy_ptr = &proxies[proc_ptr->p_usr.p_proxy].px_sproxy;
+			WLOCK_PROC(sproxy_ptr);
+			list_del_init(&proc_ptr->p_link); /* remove from queue */
+			WUNLOCK_PROC(sproxy_ptr);
+		}else{
+			ERROR_PRINT(EMOLPROCSTS);
+		}
+		clear_bit(BIT_RMTOPER, &proc_ptr->p_usr.p_rts_flags);
+	}
+
+	if(IT_IS_LOCAL(proc_ptr)) {		
+		MOLDEBUG(INTERNAL,"decrement the reference count of the task struct=%d count=%d\n"
+			,proc_ptr->p_usr.p_lpid,atomic_read(&proc_ptr->p_task->usage)); 
+		init_proc_desc(proc_ptr, proc_ptr->p_usr.p_vmid, (proc_ptr->p_usr.p_nr+vm_ptr->vm_usr.vm_nr_tasks));
+		VM_DECREF(vm_ptr);
+		put_task_struct(task_ptr);		/* decrement the reference count of the task struct */
+	} else {
+		init_proc_desc(proc_ptr, proc_ptr->p_usr.p_vmid, (proc_ptr->p_usr.p_nr+vm_ptr->vm_usr.vm_nr_tasks));
+		VM_DECREF(vm_ptr);
+	}
+	return(OK);
+	
+}
+
+/*----------------------------------------------------------------*/
+/*			mol_getpriv				*/
+/*----------------------------------------------------------------*/
+
+asmlinkage long mol_getpriv(int vmid, int proc_ep, priv_t *u_priv)
+{
+	VM_desc_t *vm_ptr;
+	struct proc *proc_ptr;
+	priv_usr_t *kp_ptr;
+	int proc_nr;
+	int ret = OK;
+
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+
+	CHECK_VMID(vmid);	/* check VM ID limits 		*/
+
+	vm_ptr 		= &vm[vmid];
+	RLOCK_VM(vm_ptr);
+	/* checks if the VM we are talking about is running */
+	if( vm_ptr->vm_usr.vm_flags) 	ERROR_RUNLOCK_VM(vm_ptr,EMOLVMNOTRUN);
+
+	proc_nr = _ENDPOINT_P(proc_ep);
+	MOLDEBUG(DBGPARAMS,"vmid=%d proc_nr=%d proc_ep=%d\n",vmid, proc_nr, proc_ep);
+	if( proc_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 		
+	 || proc_nr >= vm_ptr->vm_usr.vm_nr_procs) ERROR_RUNLOCK_VM(vm_ptr,EMOLBADPROC);
+ 	proc_ptr   = NBR2PTR(vm_ptr, proc_nr);
+
+	if( proc_ptr->p_usr.p_rts_flags == SLOT_FREE) ERROR_RUNLOCK_VM(vm_ptr,EMOLDSTDIED);
+
+	RLOCK_PROC(proc_ptr);
+	kp_ptr = &proc_ptr->p_priv.s_usr;
+	ret = copy_to_user( u_priv, kp_ptr,  sizeof(priv_usr_t));
+	MOLDEBUG(DBGPRIV,PRIV_USR_FORMAT,PRIV_USR_FIELDS(kp_ptr));
+
+	RUNLOCK_PROC(proc_ptr);
+	RUNLOCK_VM(vm_ptr);
+	return(ret);
+}
+
+/*----------------------------------------------------------------*/
+/*			mol_setpriv				*/
+/*----------------------------------------------------------------*/
+
+asmlinkage long mol_setpriv(int vmid, int proc_ep, priv_t *u_priv)
+{
+	VM_desc_t *vm_ptr;
+	struct proc *proc_ptr;
+	priv_usr_t *kp_ptr;
+	int proc_nr;
+	int ret = OK;
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+
+	CHECK_VMID(vmid);	/* check VM ID limits 		*/
+
+	vm_ptr 		= &vm[vmid];
+	RLOCK_VM(vm_ptr);
+	/* checks if the VM we are talking about is running */
+	if( vm_ptr->vm_usr.vm_flags) 	ERROR_RUNLOCK_VM(vm_ptr,EMOLVMNOTRUN);
+
+	proc_nr = _ENDPOINT_P(proc_ep);
+	MOLDEBUG(DBGPARAMS,"vmid=%d proc_nr=%d proc_ep=%d\n",vmid, proc_nr, proc_ep);
+	if( proc_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 		
+	 || proc_nr >= vm_ptr->vm_usr.vm_nr_procs) ERROR_RUNLOCK_VM(vm_ptr,EMOLBADPROC);
+ 	proc_ptr   = NBR2PTR(vm_ptr, proc_nr);
+
+	if( proc_ptr->p_usr.p_rts_flags == SLOT_FREE) ERROR_RUNLOCK_VM(vm_ptr,EMOLDSTDIED);
+
+	WLOCK_PROC(proc_ptr);
+	kp_ptr = &proc_ptr->p_priv.s_usr;
+	ret = copy_from_user( kp_ptr, u_priv, sizeof(priv_usr_t));
+	MOLDEBUG(DBGPRIV,PRIV_USR_FORMAT,PRIV_USR_FIELDS(kp_ptr));
+
+	WUNLOCK_PROC(proc_ptr);
+	RUNLOCK_VM(vm_ptr);
+	return(ret);
+}
+
+/*----------------------------------------------------------------*/
+/*			mol_proxies_bind			*/
+/* it returns the proxies ID or ERROR				*/
+/*----------------------------------------------------------------*/
+asmlinkage int mol_proxies_bind(char *px_name, int px_nr, int spid, int rpid)
+{
+	struct task_struct *stask_ptr, *rtask_ptr;	
+	struct proc *sproc_ptr, *rproc_ptr;
+	proc_usr_t  *sp_ptr, *rp_ptr;
+	proxies_t *px_ptr;
+	int ret;
+	
+	MOLDEBUG(DBGPARAMS,"px_nr=%d spid=%d, rpid=%d\n",px_nr, spid, rpid);
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+
+	CHECK_NODEID(px_nr);
+
+	/* Verify if both PIDs are running */
+	read_lock(&tasklist_lock);
+	stask_ptr = pid_task(find_vpid(spid), PIDTYPE_PID);  
+	rtask_ptr = pid_task(find_vpid(rpid), PIDTYPE_PID);  
+	if( stask_ptr == NULL || rtask_ptr == NULL) {
+		read_unlock(&tasklist_lock);
+		ERROR_RETURN(EMOLBADPID);
+	}
+	read_unlock(&tasklist_lock);
+
+	px_ptr = &proxies[px_nr];
+	WLOCK_PROXY(px_ptr);
+	if(px_ptr->px_usr.px_flags != PROXIES_FREE){
+		WUNLOCK_PROXY(px_ptr);
+		ERROR_RETURN(EMOLBUSY);
+	}
+
+
+	sproc_ptr = &px_ptr->px_sproxy;
+	rproc_ptr = &px_ptr->px_rproxy;
+
+	LOCK_TASK(stask_ptr);
+	WLOCK_PROC(sproc_ptr);
+	init_proc_desc(sproc_ptr, PROXY_NO_VM, px_nr);
+	stask_ptr->proc_ptr = sproc_ptr;		/* Set the  process descriptor into the task descriptor */
+	sproc_ptr->p_task = stask_ptr;			/* Set the task descriptor into the process descriptor */
+	strncpy(sproc_ptr->p_usr.p_name, stask_ptr->comm, MAXPROCNAME-1);
+	sproc_ptr->p_name_ptr = stask_ptr->comm;
+	sproc_ptr->p_usr.p_lpid = stask_ptr->pid;
+	get_task_struct(stask_ptr);			/* increment the reference count of the task struct */
+	sproc_ptr->p_usr.p_rts_flags 	= PROC_RUNNING;		/* set to RUNNING STATE	*/
+	sproc_ptr->p_usr.p_nr		 	= px_nr;		
+	sproc_ptr->p_usr.p_endpoint	 	= PROC_NO_PID;		
+	sproc_ptr->p_usr.p_nodeid		= atomic_read(&local_nodeid);	
+	sproc_ptr->p_usr.p_lpid 		= spid;			/* Update PID		*/
+	sproc_ptr->p_priv.s_usr.s_level 	= PROXY_PRIV;	
+	set_bit(MIS_BIT_PROXY, &sproc_ptr->p_usr.p_misc_flags);
+	sp_ptr = &sproc_ptr->p_usr;
+	MOLDEBUG(INTERNAL, PROC_USR_FORMAT, PROC_USR_FIELDS(sp_ptr));
+	WUNLOCK_PROC(sproc_ptr);
+	UNLOCK_TASK(stask_ptr);
+
+	LOCK_TASK(rtask_ptr);
+	WLOCK_PROC(rproc_ptr);
+	init_proc_desc(rproc_ptr, PROXY_NO_VM, px_nr);
+	rtask_ptr->proc_ptr = rproc_ptr;		/* Set the  process descriptor into the task descriptor */
+	rproc_ptr->p_task = rtask_ptr;			/* Set the task descriptor into the process descriptor */
+	strncpy(rproc_ptr->p_usr.p_name, rtask_ptr->comm, MAXPROCNAME-1);
+	rproc_ptr->p_name_ptr = rtask_ptr->comm;
+	rproc_ptr->p_usr.p_lpid = rtask_ptr->pid;
+	get_task_struct(rtask_ptr);			/* increment the reference count of the task struct */
+	rproc_ptr->p_usr.p_rts_flags 	= PROC_RUNNING;		/* set to RUNNING STATE	*/
+	rproc_ptr->p_usr.p_nr		 	= px_nr;		
+	rproc_ptr->p_usr.p_endpoint	 	= PROC_NO_PID;		
+	rproc_ptr->p_usr.p_nodeid		= atomic_read(&local_nodeid);	
+	rproc_ptr->p_usr.p_lpid 		= rpid;			/* Update PID		*/
+	rproc_ptr->p_priv.s_usr.s_level	= PROXY_PRIV;	
+	set_bit(MIS_BIT_PROXY, &rproc_ptr->p_usr.p_misc_flags);
+	rp_ptr = &rproc_ptr->p_usr;
+	MOLDEBUG(INTERNAL, PROC_USR_FORMAT, PROC_USR_FIELDS(rp_ptr));
+	WUNLOCK_PROC(rproc_ptr);
+	UNLOCK_TASK(rtask_ptr);
+
+	ret = copy_from_user(px_ptr->px_usr.px_name, px_name, MAXPROXYNAME);
+
+	px_ptr->px_usr.px_flags 		= PROXIES_INUSE;
+
+	KREF_GET(&drvs_kref); 			/* increment DRVS reference counter 	*/
+	WUNLOCK_PROXY(px_ptr);
+
+	return(OK);
+}
+
+/*----------------------------------------------------------------*/
+/*			do_proxies_unbind			*/
+/* The unbinding proxy must be LOCKED 				*/
+/* if the unbinding process is SENDER PROXY:			*/
+/*	- Flush every process descriptor enqueued to send a     */
+/*		CMD to a remote node				*/
+/*	- Ends every node represented by the proxy pair		*/
+/* if the unbinding process is RECEIVER PROXY:			*/
+/*	- Flush every process waiting to receive a message 	*/
+/*		from a remote process of a node represented 	*/
+/*		by the unbindind proxy				*/
+/*	- Ends every node represented by the proxy pair		*/
+/*----------------------------------------------------------------*/
+int do_proxies_unbind(struct proc *proc_ptr)
+{
+	struct task_struct *task_ptr;
+	struct proc *sproxy_ptr, *rproxy_ptr;
+	proxies_t *px_ptr;
+	cluster_node_t *n_ptr;
+	int px_nr;
+	int i, other_pid, ret = OK;
+	wait_queue_head_t wqhead;
+
+
+	if( proc_ptr == NULL) ERROR_RETURN(EMOLBADPROC);
+
+	init_waitqueue_head(&wqhead);
+
+	px_nr = proc_ptr->p_usr.p_nr;
+	MOLDEBUG(DBGPARAMS,"px_nr=%d, pid=%d\n", px_nr, proc_ptr->p_usr.p_lpid);
+
+	CHECK_NODEID(px_nr);
+
+	px_ptr = &proxies[px_nr];
+	sproxy_ptr = &px_ptr->px_sproxy;
+	rproxy_ptr = &px_ptr->px_rproxy;
+
+	MOLDEBUG(DBGPARAMS,"sproxy_pid=%d, rproxy_pid=%d\n", sproxy_ptr->p_usr.p_lpid, rproxy_ptr->p_usr.p_lpid);
+
+	if(sproxy_ptr == proc_ptr ) {		/* the SENDER PROXY */
+		for( i = 0;  i < drvs.d_nr_nodes; i++) {
+			if( test_bit( i ,  &sproxy_ptr->p_usr.p_nodemap)) {
+				clear_bit( i ,  &sproxy_ptr->p_usr.p_nodemap);
+				clear_bit( i ,  &rproxy_ptr->p_usr.p_nodemap);
+				flush_sending_procs( i, sproxy_ptr);
+				n_ptr = &node[i];
+				WLOCK_NODE(n_ptr);
+				clear_bit(NODE_BIT_SCONNECTED, &n_ptr->n_usr.n_flags);
+				if( !test_bit(NODE_BIT_RCONNECTED, &n_ptr->n_usr.n_flags)) { 
+					do_node_end(&node[i]);
+				}
+				WUNLOCK_NODE(n_ptr);
+			}
+		}
+		task_ptr  = sproxy_ptr->p_task;
+		put_task_struct(task_ptr);	/* decrement the reference count of the task struct */
+		init_proc_desc(sproxy_ptr, PROXY_NO_VM, px_nr);	
+		if( rproxy_ptr->p_task != NULL ){
+			MOLDEBUG(INTERNAL,"sending SIGPIPE to RPROXY pid=%d\n", rproxy_ptr->p_usr.p_lpid);
+			ret = send_sig_info(SIGPIPE, SEND_SIG_NOINFO, rproxy_ptr->p_task);
+			other_pid = rproxy_ptr->p_usr.p_lpid;
+#ifdef ANULADO
+			WUNLOCK_PROC(rproxy_ptr);
+			do {
+				ret = wait_event_interruptible(wqhead,(other_pid != rproxy_ptr->p_usr.p_lpid));
+				MOLDEBUG(INTERNAL,"other_pid=%d pid=%d\n",other_pid, rproxy_ptr->p_usr.p_lpid);
+				}while(ret != 0);
+			WLOCK_PROC(rproxy_ptr);
+#endif
+			MOLDEBUG(INTERNAL,"other_pid=%d pid=%d\n",other_pid, rproxy_ptr->p_usr.p_lpid)
+		} else {
+			KREF_PUT(&drvs_kref, drvs_release); 	/* decrement DRVS reference counter 	*/
+		}
+	} else if (rproxy_ptr == proc_ptr) {	/* the RECEIVER PROXY */
+		for( i = 0;  i < drvs.d_nr_nodes; i++) {
+			if( test_bit( i ,  &rproxy_ptr->p_usr.p_nodemap)) {
+				clear_bit( i ,  &sproxy_ptr->p_usr.p_nodemap);
+				clear_bit( i ,  &rproxy_ptr->p_usr.p_nodemap);
+				flush_receiving_procs( i, rproxy_ptr);
+				n_ptr = &node[i];
+				WLOCK_NODE(n_ptr);
+				clear_bit(NODE_BIT_RCONNECTED, &n_ptr->n_usr.n_flags);
+				if( !test_bit(NODE_BIT_SCONNECTED,  &n_ptr->n_usr.n_flags)){ 
+					do_node_end(&node[i]);
+				}
+				WUNLOCK_NODE(n_ptr);
+			}
+		}
+		task_ptr  = rproxy_ptr->p_task;
+		put_task_struct(task_ptr);	/* decrement the reference count of the task struct */
+		init_proc_desc(rproxy_ptr, PROXY_NO_VM, px_nr);	
+		
+		if( sproxy_ptr->p_task != NULL){
+			MOLDEBUG(INTERNAL,"sending SIGPIPE to SPROXY pid=%d\n", sproxy_ptr->p_usr.p_lpid);
+			ret = send_sig_info(SIGPIPE, SEND_SIG_NOINFO, sproxy_ptr->p_task);
+			other_pid = sproxy_ptr->p_usr.p_lpid;
+#ifdef ANULADO	
+			WUNLOCK_PROC(sproxy_ptr);
+			do {
+				ret = wait_event_interruptible(wqhead,(other_pid != sproxy_ptr->p_usr.p_lpid));
+				MOLDEBUG(INTERNAL,"other_pid=%d pid=%d\n",other_pid, sproxy_ptr->p_usr.p_lpid);
+				}while(ret != 0);
+			WLOCK_PROC(sproxy_ptr);
+#endif
+			MOLDEBUG(INTERNAL,"other_pid=%d pid=%d\n",other_pid, sproxy_ptr->p_usr.p_lpid)
+		} else {
+			KREF_PUT(&drvs_kref, drvs_release); 	/* decrement DRVS reference counter 	*/
+		}
+		
+	}else {
+		ret = EMOLBADPID;
+	}
+
+	px_ptr->px_usr.px_flags = PROXIES_FREE;
+
+	if(ret) ERROR_RETURN(ret);
+	return(ret);
+}
+
+/*----------------------------------------------------------------*/
+/*			mol_proxies_unbind			*/
+/*----------------------------------------------------------------*/
+asmlinkage int mol_proxies_unbind(int px_nr)
+{
+	struct proc *sproc_ptr, *rproc_ptr;
+	struct task_struct *task_ptr;
+	proxies_t *px_ptr;
+
+	MOLDEBUG(DBGPARAMS,"px_nr=%d\n",px_nr);
+
+	if(current_euid() != USER_ROOT) 		ERROR_RETURN(EMOLPRIVILEGES);
+	if( DRVS_NOT_INIT() )   			ERROR_RETURN(EMOLDRVSINIT);
+	
+	CHECK_NODEID(px_nr);
+
+	px_ptr = &proxies[px_nr];
+	WLOCK_PROXY(px_ptr);
+	if(px_ptr->px_usr.px_flags == PROXIES_FREE){
+		WUNLOCK_PROXY(px_ptr);
+		ERROR_RETURN(EMOLPROXYFREE);
+	}
+
+	sproc_ptr = &px_ptr->px_sproxy;
+	rproc_ptr = &px_ptr->px_rproxy;	
+
+	WLOCK_PROC(sproc_ptr);
+	WLOCK_PROC(rproc_ptr);
+
+	task_ptr  = sproc_ptr->p_task;
+	if(task_ptr != NULL) {
+		WUNLOCK_PROC(sproc_ptr);
+		LOCK_TASK(task_ptr);
+		WLOCK_PROC(sproc_ptr);
+		do_proxies_unbind(sproc_ptr);
+		UNLOCK_TASK(task_ptr); 
+	}
+
+	task_ptr  = rproc_ptr->p_task;
+	if(task_ptr != NULL) {
+		WUNLOCK_PROC(rproc_ptr);
+		LOCK_TASK(task_ptr);
+		WLOCK_PROC(rproc_ptr);
+		do_proxies_unbind(rproc_ptr);
+		UNLOCK_TASK(task_ptr);  
+	}
+
+	WUNLOCK_PROC(sproc_ptr);
+	WUNLOCK_PROC(rproc_ptr);
+	
+	WUNLOCK_PROXY(px_ptr);
+
+	return(OK);
+}
+
+
+/*----------------------------------------------------------------*/
+/*			mol_proxy_conn				*/
+/* Its is used by the proxies to signal that that they are 	*/
+/* connected/disconnected to proxies on remote nodes		*/
+/* status can be: 						*/
+/* CONNECT_PROXIES or DISCONNECT_PROXIES 			*/
+/*----------------------------------------------------------------*/
+asmlinkage int mol_proxy_conn(int px_nr, int status)
+{
+	struct proc *sproxy_ptr, *rproxy_ptr;
+	proc_usr_t *s_ptr, *r_ptr;
+	proxies_t *px_ptr;
+	cluster_node_t *n_ptr;
+	int rcode, i;
+	
+	MOLDEBUG(DBGPARAMS,"px_nr=%d, status=%d\n",px_nr, status);
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+
+	CHECK_NODEID(px_nr);
+	px_ptr = &proxies[px_nr];
+
+	px_ptr = &proxies[px_nr];
+	WLOCK_PROXY(px_ptr);
+	if(px_ptr->px_usr.px_flags == PROXIES_FREE){
+		WUNLOCK_PROXY(px_ptr);
+		ERROR_RETURN(EMOLPROXYFREE);
+	}
+
+	sproxy_ptr = &px_ptr->px_sproxy;
+	rproxy_ptr = &px_ptr->px_rproxy;
+
+	WLOCK_PROC(sproxy_ptr);
+	WLOCK_PROC(rproxy_ptr);
+	if( sproxy_ptr->p_usr.p_rts_flags == SLOT_FREE 
+	||  rproxy_ptr->p_usr.p_rts_flags == SLOT_FREE ){ 
+		rcode = EMOLNOPROXY; 
+	}else {	
+		rcode = OK;
+		switch(status){
+			case DISCONNECT_SPROXY:
+				clear_bit(PX_BIT_SCONNECTED, &px_ptr->px_usr.px_flags);
+				clear_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags);
+				for( i = 0;  i < drvs.d_nr_nodes; i++) {
+					if( test_bit( i ,  &sproxy_ptr->p_usr.p_nodemap)) {
+						flush_sending_procs( i, sproxy_ptr);
+						n_ptr = &node[i];
+						WLOCK_NODE(n_ptr);						
+						clear_bit(NODE_BIT_SCONNECTED, &n_ptr->n_usr.n_flags);
+						WUNLOCK_NODE(n_ptr);						
+					}
+				}
+				break;
+			case DISCONNECT_RPROXY:
+				clear_bit(PX_BIT_RCONNECTED, &px_ptr->px_usr.px_flags);
+				clear_bit(MIS_BIT_CONNECTED, &rproxy_ptr->p_usr.p_misc_flags);
+				for( i = 0;  i < drvs.d_nr_nodes; i++) {
+					if( test_bit( i ,  &rproxy_ptr->p_usr.p_nodemap)) {
+						flush_receiving_procs( i, rproxy_ptr);
+						n_ptr = &node[i];
+						WLOCK_NODE(n_ptr);	
+						clear_bit(NODE_BIT_RCONNECTED, &n_ptr->n_usr.n_flags);
+						WUNLOCK_NODE(n_ptr);						
+					}
+				}
+				break;
+			case CONNECT_SPROXY:
+				set_bit(PX_BIT_SCONNECTED, &px_ptr->px_usr.px_flags);
+				set_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags);
+				for( i = 0;  i < drvs.d_nr_nodes; i++) {
+					if( test_bit( i ,  &sproxy_ptr->p_usr.p_nodemap)) {
+						n_ptr = &node[i];
+						WLOCK_NODE(n_ptr);
+						set_bit(NODE_BIT_SCONNECTED,  &n_ptr->n_usr.n_flags);
+						WUNLOCK_NODE(n_ptr);						
+					}
+				}
+				break;
+			case CONNECT_RPROXY:
+				set_bit(PX_BIT_RCONNECTED, &px_ptr->px_usr.px_flags);
+				set_bit(MIS_BIT_CONNECTED, &rproxy_ptr->p_usr.p_misc_flags);
+				for( i = 0;  i < drvs.d_nr_nodes; i++) {
+					if( test_bit( i ,  &rproxy_ptr->p_usr.p_nodemap)) {
+						n_ptr = &node[i];
+						WLOCK_NODE(n_ptr);
+						set_bit(NODE_BIT_RCONNECTED,  &n_ptr->n_usr.n_flags);
+						WUNLOCK_NODE(n_ptr);						
+					}
+				}
+				break;
+			default:
+				rcode =EMOLBADVALUE;	
+				break;
+		}
+	}
+
+	s_ptr=&sproxy_ptr->p_usr;
+	r_ptr=&rproxy_ptr->p_usr;
+	MOLDEBUG(INTERNAL,PROC_USR_FORMAT,PROC_USR_FIELDS(s_ptr));
+	MOLDEBUG(INTERNAL,PROC_USR_FORMAT,PROC_USR_FIELDS(r_ptr));
+
+	WUNLOCK_PROC(sproxy_ptr);
+	WUNLOCK_PROC(rproxy_ptr);
+	WUNLOCK_PROXY(px_ptr);
+
+	if(rcode) ERROR_RETURN(rcode);
+	return(OK);
+}
+
+/*----------------------------------------------------------------*/
+/*			do_node_end			*/
+/* when a node finishs:					*/
+/*	- all remote processes of that node of all VMs 	*/
+/*		are unbinded				*/
+/*	- clears the bit represented the node from the 	*/
+/*		every VM bitmap				*/
+/*	- removes the nodename entry from the /proc/drvs*/
+/*----------------------------------------------------------------*/
+int do_node_end(cluster_node_t *n_ptr)
+{
+	int vmid, i;
+	VM_desc_t *vm_ptr;
+	struct proc *proc_ptr;
+
+	MOLDEBUG(DBGPARAMS,"nodeid=%d\n",n_ptr->n_usr.n_nodeid);
+
+	for( vmid = 0; vmid < drvs.d_nr_vms; vmid++) {
+		vm_ptr = &vm[vmid];
+		RLOCK_VM(vm_ptr);
+		if(vm_ptr->vm_usr.vm_flags != VM_FREE) {
+			/*	UNBIND all REMOTE process on that node	*/
+			FOR_EACH_PROC(vm_ptr, i) {
+				proc_ptr = VM_PROC(vm_ptr,i);
+				WLOCK_PROC(proc_ptr);
+				if( IT_IS_REMOTE(proc_ptr) &&  (proc_ptr->p_usr.p_nodeid == n_ptr->n_usr.n_nodeid)) {
+					MOLDEBUG(INTERNAL,"Unbinding remote process endpoint=%d from vm=%d node=%d\n",
+						proc_ptr->p_usr.p_endpoint, vmid, n_ptr->n_usr.n_nodeid);			
+					do_unbind(vm_ptr, proc_ptr, n_ptr->n_usr.n_nodeid);
+				}		
+				WUNLOCK_PROC(proc_ptr);
+			}
+			/* clear the bit in the node and VM bitmaps */
+			clear_bit(n_ptr->n_usr.n_nodeid, &vm_ptr->vm_usr.vm_nodes);
+		}
+		RUNLOCK_VM(vm_ptr);	
+	}
+	
+	clear_node(n_ptr);
+
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_drvs_end				*/
+/* End the DRVS system						*/
+/* - Unbind Proxies and delete Remote Nodes and its processes	*/
+/* - End al VMs: unbind local process and remove commands	*/
+/* - Unbind Proxies						*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_drvs_end(void)
+{
+	int vmid, i, rcode;
+	VM_desc_t *vm_ptr;
+	cluster_node_t *n_ptr;
+	proxies_t *px_ptr;
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT);
+	
+	MOLDEBUG(DBGPARAMS,"Ending DRVS. Local node ID %d\n", atomic_read(&local_nodeid));
+
+	WLOCK_DRVS;
+	
+	MOLDEBUG(GENERIC,"Ending VMs \n");
+	/* End all VMs 		*/
+	for( vmid = 0; vmid < drvs.d_nr_vms; vmid++) {
+		vm_ptr = &vm[vmid];
+		WLOCK_VM(vm_ptr);
+		if(vm_ptr->vm_usr.vm_flags != VM_FREE) {
+			rcode = do_vm_end(vm_ptr);
+			if( rcode) ERROR_PRINT(rcode);
+		}
+		WUNLOCK_VM(vm_ptr);	
+	}
+
+	MOLDEBUG(GENERIC,"Ending Nodes \n");
+	for (i = 0; i < drvs.d_nr_nodes; i++) {
+		n_ptr = &node[i];
+		if( i == atomic_read(&local_nodeid)) continue;
+		WLOCK_NODE(n_ptr);
+		rcode = do_node_end(n_ptr);				
+		WUNLOCK_NODE(n_ptr);
+	}
+
+	MOLDEBUG(GENERIC,"Ending Proxies \n");
+	for (i = 0; i < drvs.d_nr_nodes; i++) {
+		px_ptr = &proxies[i];
+		WLOCK_PROXY(px_ptr);	
+		if( px_ptr->px_usr.px_flags != PROXIES_FREE)
+			rcode = do_proxies_unbind(&px_ptr->px_sproxy);
+		WUNLOCK_PROXY(px_ptr);				
+	}
+
+	KREF_PUT(&drvs_kref, drvs_release); 	/* it calls function drvs_release when count=0 */
+	
+	WUNLOCK_DRVS;
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_node_up				*/
+/* Link a node withe a proxy pair				*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_node_up(char *node_name, int nodeid, int px_nr)
+{
+	struct proc *sproxy_ptr, *rproxy_ptr;
+	cluster_node_t *n_ptr;
+	proxies_t *px_ptr;
+	int ret;
+
+	MOLDEBUG(DBGPARAMS,"nodeid=%d px_nr=%d\n", nodeid, px_nr);
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+	if( DRVS_NOT_INIT() )   	ERROR_RETURN(EMOLDRVSINIT);
+
+	CHECK_NODEID(nodeid);
+	CHECK_NODEID(px_nr);
+
+	if( nodeid >= drvs.d_nr_nodes) 	ERROR_RETURN(EMOLBADNODEID);
+	if( px_nr   >= drvs.d_nr_nodes) ERROR_RETURN(EMOLBADNODEID);
+
+	px_ptr = &proxies[px_nr];
+	WLOCK_PROXY(px_ptr);
+	if(px_ptr->px_usr.px_flags == PROXIES_FREE){
+		WUNLOCK_PROXY(px_ptr);
+		ERROR_RETURN(EMOLPROXYFREE);
+	}
+
+	sproxy_ptr = &px_ptr->px_sproxy;
+	rproxy_ptr = &px_ptr->px_rproxy;
+	WLOCK_PROC(sproxy_ptr);
+	WLOCK_PROC(rproxy_ptr);
+	set_bit(nodeid, &sproxy_ptr->p_usr.p_nodemap);
+	set_bit(nodeid, &rproxy_ptr->p_usr.p_nodemap);
+	MOLDEBUG(INTERNAL,"s_map=%lX r_map=%lX\n", 
+		sproxy_ptr->p_usr.p_nodemap, 
+		rproxy_ptr->p_usr.p_nodemap);
+	WUNLOCK_PROC(sproxy_ptr);
+	WUNLOCK_PROC(rproxy_ptr);
+
+	n_ptr = &node[nodeid];
+	WLOCK_NODE(n_ptr);
+	n_ptr->n_usr.n_flags   = NODE_ATTACHED;
+	n_ptr->n_usr.n_proxies = px_nr;
+	if( test_bit(PX_BIT_SCONNECTED, &px_ptr->px_usr.px_flags)){
+		set_bit(NODE_BIT_SCONNECTED, &n_ptr->n_usr.n_flags);
+	}
+	if( test_bit(PX_BIT_RCONNECTED, &px_ptr->px_usr.px_flags)){
+		set_bit(NODE_BIT_RCONNECTED, &n_ptr->n_usr.n_flags);
+	}
+	ret = copy_from_user(n_ptr->n_usr.n_name, node_name, (MAXNODENAME-1));
+	WUNLOCK_NODE(n_ptr);
+
+	WUNLOCK_PROXY(px_ptr);
+
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_node_down				*/
+/* Unlink a node from a proxy pair				*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_node_down(int nodeid)
+{
+	proxies_t *px_ptr;
+	struct proc *sproxy_ptr, *rproxy_ptr;
+	cluster_node_t *n_ptr;
+	int px_nr, ret;
+
+
+	MOLDEBUG(DBGPARAMS,"nodeid=%d\n", nodeid);
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(EMOLPRIVILEGES);
+	if( DRVS_NOT_INIT() )   	ERROR_RETURN(EMOLDRVSINIT);
+
+	CHECK_NODEID(nodeid);
+
+	n_ptr = &node[nodeid];
+	WLOCK_NODE(n_ptr);
+	px_nr = n_ptr->n_usr.n_proxies;
+
+	px_ptr = &proxies[px_nr];
+	WLOCK_PROXY(px_ptr);
+	if( px_ptr->px_usr.px_flags == PROXIES_FREE){
+		WUNLOCK_PROXY(px_ptr);
+		WUNLOCK_NODE(n_ptr);
+		ERROR_RETURN(EMOLPROXYFREE);	
+	}
+
+	sproxy_ptr = &px_ptr->px_sproxy;
+	rproxy_ptr = &px_ptr->px_sproxy;
+	WLOCK_PROC(sproxy_ptr);
+	WLOCK_PROC(rproxy_ptr);
+	if(!test_bit(nodeid, &sproxy_ptr->p_usr.p_nodemap)){
+		clear_bit(nodeid, &sproxy_ptr->p_usr.p_nodemap);
+		clear_bit(nodeid, &rproxy_ptr->p_usr.p_nodemap);
+		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
+		/*	HACER GARBAGE COLLECTION		*/
+		/* ATENCION el nodo debe seguir en estado NODE_ATTACHED */
+		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
+		clear_node(n_ptr);	
+		ret = OK;	
+	}else{
+		ret = EMOLBADNODEID;
+	}
+	
+	WUNLOCK_PROC(sproxy_ptr);
+	WUNLOCK_PROC(rproxy_ptr);
+	WUNLOCK_PROXY(px_ptr);
+	WUNLOCK_NODE(n_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(ret);
+}
+
+#ifdef MOLAUTOFORK
+/*--------------------------------------------------------------*/
+/*			kernel_lclbind				*/
+/* A parent process has forked and the PM returns de p_nr	*/
+/* Now the parent must bind the child				*/
+/*--------------------------------------------------------------*/
+long kernel_lclbind(int vmid, int pid, int p_nr)
+{
+	struct proc *proc_ptr;
+	VM_desc_t *vm_ptr;
+	int g, i, endpoint, rcode, nodeid;
+	struct task_struct *task_ptr;	
+
+	if( DRVS_NOT_INIT() )   			ERROR_RETURN(EMOLDRVSINIT);
+	nodeid = atomic_read(&local_nodeid);
+MOLDEBUG(DBGLVL1,"vmid=%d pid=%d p_nr=%d nodeid=%d\n",vmid, pid, p_nr, nodeid);
+
+	vm_ptr 		= &vm[vmid];
+	WLOCK_VM(vm_ptr);	
+	if( vm_ptr->vm_usr.vm_flags) 			ERROR_WUNLOCK_VM(vm_ptr,EMOLVMNOTRUN);
+
+	i = p_nr+vm_ptr->vm_usr.vm_nr_tasks;
+	proc_ptr = VM_PROC(vm_ptr,i);
+	if(proc_ptr->p_usr.p_rts_flags != SLOT_FREE) 	ERROR_WUNLOCK_VM(vm_ptr,EMOLBUSY);
+
+	init_proc_desc(proc_ptr, vmid, i);		/* Initialize all process descriptor fields	*/
+
+// 	strncpy((char* )&proc_ptr->p_usr.p_name, (char*)task_ptr->comm, MAXPROCNAME-1);
+	proc_ptr->p_name_ptr = (char*)task_ptr->comm;
+
+// MOLDEBUG(DBGLVL1,"process p_name=%s *p_name_ptr=%s\n", (char*)&proc_ptr->p_usr.p_name, proc_ptr->p_name_ptr);
+		
+	proc_ptr->p_usr.p_rts_flags	= PROC_RUNNING;		/* set to RUNNING STATE	*/
+	proc_ptr->p_usr.p_nodeid	= nodeid;	
+	proc_ptr->p_usr.p_lpid 		= pid;			/* Update PID		*/
+	if( i < vm_ptr->vm_usr.vm_nr_sysprocs) {
+		proc_ptr->p_usr.p_endpoint = _ENDPOINT(0,proc_ptr->p_usr.p_nr);
+		proc_ptr->p_priv.s_usr.s_id = i;
+	}else{
+		g = _ENDPOINT_G(proc_ptr->p_usr.p_endpoint);	/* Update endpoint 	*/
+		if(++g >= _ENDPOINT_MAX_GENERATION)		/* increase generation */
+			g = 1;					/* generation number wraparound */
+		proc_ptr->p_usr.p_endpoint = _ENDPOINT(g,proc_ptr->p_usr.p_nr);
+		proc_ptr->p_priv.s_usr.s_id = 0;
+	}
+
+	
+MOLDEBUG(DBGLVL1,"i=%d p_nr=%d vmid=%d lpid=%d endpoint=%d nodeid=%d name=%s\n",
+		i,
+		proc_ptr->p_usr.p_nr, 
+		proc_ptr->p_usr.p_vmid,
+		proc_ptr->p_usr.p_lpid,
+		proc_ptr->p_usr.p_endpoint,
+		proc_ptr->p_usr.p_nodeid,
+		proc_ptr->p_usr.p_name
+		);
+
+	endpoint = proc_ptr->p_usr.p_endpoint;
+	
+	VM_INCREF(vm_ptr);
+	WUNLOCK_VM(vm_ptr);
+	return(endpoint);
+}
+
+#endif /*MOLAUTOFORK */
diff -Naur /home/jara/linux-2.6.32/kernel/mol-ipc.c /usr/src/linux/kernel/mol-ipc.c
--- /home/jara/linux-2.6.32/kernel/mol-ipc.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-ipc.c	2014-05-03 12:32:02.000000000 -0300
@@ -0,0 +1,1932 @@
+/****************************************************************/
+/*			MINIX IPC KERNEL 			*/
+/* It uses the same Interrupt Vector than MINIX (0x21)		*/
+/* It considers different Virtual Machines (Virtual Minix Envi-	*/
+/* ronments or VME) that let execute multiple Minix Over Linux	*/
+/* on the same real machine					*/
+/* MINIX IPC Calls: send, receive, sendrec, notify, vcopy 	*/
+/* Hypervisor Calls: vm_init, vm_dump, proc_dump, bind, unbind  */
+/* setpriv							*/ 
+/****************************************************************/
+
+#include "mol.h"
+
+#include "mol-proto.h"
+#include "mol-glo.h"
+#include "mol-macros.h"
+
+/*2345678901234567890123456789012345678901234567890123456789012345678901234567*/
+
+/*--------------------------------------------------------------*/
+/*			mol_mini_send				*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_mini_send(int dst_ep, message* m_ptr, long timeout_ms)
+{
+	struct proc *dst_ptr, *caller_ptr, *sproxy_ptr;
+	VM_desc_t *vm_ptr;
+	int ret, retry;
+	int caller_nr, caller_ep, caller_pid;
+	int dst_nr, vmid, nodeid;
+	struct task_struct *task_ptr;
+
+	if( DRVS_NOT_INIT() ) 				ERROR_RETURN(EMOLDRVSINIT);
+
+	MOLDEBUG(DBGPARAMS,"dst_ep=%d\n",dst_ep);
+	
+	ret = check_lock_caller(&task_ptr, &caller_ptr, &caller_pid);
+	if(ret) ERROR_RETURN(ret);
+	
+	caller_nr   = caller_ptr->p_usr.p_nr;
+	caller_ep   = caller_ptr->p_usr.p_endpoint;
+	MOLDEBUG(DBGPARAMS,"caller_nr=%d caller_ep=%d dst_ep=%d \n", caller_nr, caller_ep, dst_ep);
+	caller_ptr->p_umsg	= m_ptr;
+
+	/*------------------------------------------
+	 * Checks the caller process PID
+ 	 * Gets the VMID
+	 * Checks if the VM is RUNNING
+	 * Locks the VM
+      *------------------------------------------*/
+	ret = OK;
+	do {
+		if (caller_pid != caller_ptr->p_usr.p_lpid) 	{ret = EMOLBADPID; break;}
+		vmid		= caller_ptr->p_usr.p_vmid;
+		MOLDEBUG(INTERNAL,"vmid=%d\n", vmid);
+		if( vmid < 0 || vmid >= drvs.d_nr_vms) 		{ret =EMOLBADVMID; break;}
+		vm_ptr 	= &vm[vmid];
+		RLOCK_VM(vm_ptr);
+		if( vm_ptr->vm_usr.vm_flags)  ret = EMOLVMNOTRUN;
+		RUNLOCK_VM(vm_ptr);	
+	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}
+
+
+send_replay: /* Return point for a migrated destination process */
+	ret = OK;
+
+	/*------------------------------------------
+	 * get the destination process number
+	*------------------------------------------*/
+	do {
+		dst_nr = _ENDPOINT_P(dst_ep);
+		if( dst_nr < (-vm_ptr->vm_usr.vm_nr_tasks)		
+		 || dst_nr >= vm_ptr->vm_usr.vm_nr_procs)	{ret = EMOLRANGE; break;}
+		dst_ptr   = NBR2PTR(vm_ptr, dst_nr);
+		if( dst_ptr == NULL) 				{ret = EMOLDSTDIED; break;}
+		if( caller_ep == dst_ep) 			{ret = EMOLENDPOINT; break;}
+	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}
+
+	/*------------------------------------------
+	 * check the destination process status
+	*------------------------------------------*/
+	WLOCK_ORDERED2(caller_ptr,dst_ptr);
+	MOLDEBUG(DBGPARAMS,"dst_nr=%d dst_ep=%d\n",dst_nr, dst_ptr->p_usr.p_endpoint);
+
+	do	{
+		ret = OK;
+		retry = 0;
+		if (caller_ptr->p_usr.p_rts_flags ) 		{ret = EMOLNOTREADY; break;} 	/* Caller is NOT READY! 	*/
+		if (dst_ptr->p_usr.p_endpoint != dst_ep) 	{ret = EMOLENDPOINT; break;} 	/* Paranoid checking		*/
+		if( test_bit(BIT_SLOT_FREE, &dst_ptr->p_usr.p_rts_flags))	{ret = EMOLDSTDIED; break;} 	/*destination died		*/
+		if( test_bit(BIT_MIGRATE, &dst_ptr->p_usr.p_rts_flags))	{
+			set_bit(BIT_WAITMIGR, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_waitmigr = dst_ep;
+			INIT_LIST_HEAD(&caller_ptr->p_mlink);
+			list_add_tail(&caller_ptr->p_mlink, &dst_ptr->p_mlist);
+			sleep_proc2(caller_ptr, dst_ptr, timeout_ms);
+			ret = caller_ptr->p_rcode;
+			retry = 1;
+		} 	
+	} while(retry);
+	if(ret) {							
+		WUNLOCK_PROC2(caller_ptr, dst_ptr);
+		ERROR_RETURN(ret);
+	}
+	
+	MOLDEBUG(DBGPARAMS,"vmid=%d caller_pid=%d caller_nr=%d dst_ep=%d \n",vmid, caller_pid,caller_nr, dst_ep);
+	caller_ptr->p_rcode= OK;
+	if( IT_IS_REMOTE(dst_ptr)) {		/* the destination is REMOTE */
+		/*---------------------------------------------------------------------------------------------------*/
+		/*						REMOTE 								 */
+		/*---------------------------------------------------------------------------------------------------*/
+
+		/* get destination nodeid */
+		nodeid = dst_ptr->p_usr.p_nodeid;
+		MOLDEBUG(INTERNAL,"nodeid=%d\n",nodeid);
+		if( nodeid < 0 || nodeid >= drvs.d_nr_nodes) 	 {							
+			ret = EMOLBADNODEID;
+		} else {
+			sproxy_ptr = get_sproxy(nodeid);
+			RLOCK_PROC(sproxy_ptr);
+			do {
+				ret = OK;
+				if( ! test_bit(nodeid, &vm_ptr->vm_usr.vm_nodes)) 	{ret = EMOLNOVMNODE ;break;}
+				if( sproxy_ptr->p_usr.p_lpid == PROC_NO_PID)		{ret = EMOLNOPROXY ;break;}
+//				if( nptr->n_usr.n_flags == NODE_FREE) 			{ret = EMOLNOPROXY;break;}
+				if( test_bit( BIT_SLOT_FREE, &sproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLNOPROXY ;break;} 
+				if( !test_bit(MIS_BIT_PROXY, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOTCONN;break;}  
+			} while(0);
+			RUNLOCK_PROC(sproxy_ptr);
+		}
+ 		if(ret) {							
+			WUNLOCK_PROC2(caller_ptr, dst_ptr);
+			ERROR_RETURN(ret);
+		}
+
+		clear_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags);
+		if(	dst_ptr->p_usr.p_getfrom == caller_ptr->p_usr.p_endpoint){
+					dst_ptr->p_usr.p_getfrom = NONE;
+		}
+		WUNLOCK_PROC(dst_ptr); 
+
+		/* fill the caller's rmtcmd fields */
+		caller_ptr->p_rmtcmd.c_cmd 	= CMD_SEND_MSG;
+		caller_ptr->p_rmtcmd.c_src 		= caller_ep;
+		caller_ptr->p_rmtcmd.c_dst 		= dst_ep;
+		caller_ptr->p_rmtcmd.c_vmid		= vmid;
+		caller_ptr->p_rmtcmd.c_snode  	= atomic_read(&local_nodeid);
+		caller_ptr->p_rmtcmd.c_dnode  	= nodeid;
+		caller_ptr->p_rmtcmd.c_rcode  	= OK;
+		caller_ptr->p_rmtcmd.c_len  	= sizeof(message);
+
+		INIT_LIST_HEAD(&caller_ptr->p_link);
+		set_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+		caller_ptr->p_usr.p_sendto = dst_ep;
+		set_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+		
+		ret = sproxy_enqueue(caller_ptr);
+			
+		/* wait for the SENDACK */
+		sleep_proc(caller_ptr, timeout_ms);
+		ret = caller_ptr->p_rcode;
+		if( ret == OK){
+			caller_ptr->p_usr.p_rmtsent++;
+
+		}else{
+			if( test_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags)) {
+				MOLDEBUG(GENERIC,"removing %d link from sender's proxy list.\n", 
+					caller_ptr->p_usr.p_endpoint);
+				list_del(&caller_ptr->p_link); /* remove from queue ATENCION: HAY Q PROTEGER PROXY ?? */
+			}
+			clear_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_sendto = NONE;
+			clear_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_proxy = PROC_NO_PID;
+
+			if( ret == EMOLMIGRATE) goto send_replay;
+
+		}
+	} else {					/* the destination is LOCAL  */
+		/*---------------------------------------------------------------------------------------------------*/
+		/*						LOCAL								 */
+		/*---------------------------------------------------------------------------------------------------*/
+		/* Check if 'dst' is blocked waiting for this message.   */
+		if ( (test_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags) && !test_bit(BIT_SENDING, &dst_ptr->p_usr.p_rts_flags)) &&
+			(dst_ptr->p_usr.p_getfrom == ANY || dst_ptr->p_usr.p_getfrom == caller_ep)) {
+			MOLDEBUG(GENERIC,"destination is waiting. Copy the message and wakeup destination\n");
+
+			COPY_USR2USR_PROC(ret, caller_ep, caller_ptr, (char *) m_ptr, dst_ptr, (char *)dst_ptr->p_umsg, sizeof(message) );
+			if(ret) {
+				WUNLOCK_PROC2(caller_ptr, dst_ptr);
+				ERROR_RETURN(ret);
+			}
+			clear_bit(BIT_RECEIVING,&dst_ptr->p_usr.p_rts_flags);
+			dst_ptr->p_usr.p_getfrom 	= NONE;
+			if(dst_ptr->p_usr.p_rts_flags == 0) 
+				LOCAL_PROC_UP(dst_ptr, ret);
+			WUNLOCK_PROC(dst_ptr); 
+			caller_ptr->p_usr.p_lclsent++;
+		} else { 
+			MOLDEBUG(GENERIC,"destination is not waiting dst_ptr->p_usr.p_rts_flags=%lX. Enqueue at the TAIL.\n",dst_ptr->p_usr.p_rts_flags);
+			/* The destination is not waiting for this message 			*/
+			/* Append the caller at the TAIL of the destination senders' queue	*/
+			/* blocked sending the message */
+			set_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_sendto 	= dst_ep;
+			caller_ptr->p_umsg		= m_ptr;
+			INIT_LIST_HEAD(&caller_ptr->p_link);
+			list_add_tail(&caller_ptr->p_link, &dst_ptr->p_list);
+
+			sleep_proc2(caller_ptr, dst_ptr, timeout_ms);
+			ret = caller_ptr->p_rcode;
+
+			if( ret == OK){
+				caller_ptr->p_usr.p_lclsent++;
+				WUNLOCK_PROC(dst_ptr);
+			}else{
+				if( test_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags)) {
+					MOLDEBUG(GENERIC,"removing %d link from %d list.\n", caller_ptr->p_usr.p_endpoint, dst_ep);
+					/* remove from queue ATENCION: HAY Q PROTEGER DESTINATION ?? */
+					list_del(&caller_ptr->p_link); 
+				}
+				clear_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+				caller_ptr->p_usr.p_sendto 	= NONE;
+				WUNLOCK_PROC(dst_ptr);
+				if( ret == EMOLMIGRATE) goto send_replay;
+			}
+		}
+	}
+
+	WUNLOCK_PROC(caller_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(ret);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_mini_receive			*/
+/* Receives a message from another MOL process of the same VM	*/
+/* Differences with MINIX:					*/
+/*	- The receiver copies the message from sender's buffer  */
+/*	   to receiver's userspace 				*/
+/*	- After a the receiver is unblocked, it must check if 	*/
+/*	   it was for doing a copy command (CMD_COPY_IN, CMD_COPY_OUT)	*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_mini_receive(int src_ep, message* m_ptr, long timeout_ms)
+{
+	struct proc *caller_ptr, *xpp, *tmp_ptr, *src_ptr, *rproxy_ptr;
+	VM_desc_t *vm_ptr;
+	int sys_id, sys_nr;
+//	int sys_ep = NONE;
+	int i, ret, src_nr;
+	sys_map_t *map;
+  	bitchunk_t *chunk;
+	int caller_nr, caller_pid, caller_ep;
+	int vmid, nodeid;
+	struct task_struct *task_ptr;	
+	struct timespec *t_ptr;
+	message *mptr;
+
+
+	if( DRVS_NOT_INIT() ) 				ERROR_RETURN(EMOLDRVSINIT);
+
+	MOLDEBUG(DBGPARAMS,"src_ep=%d\n",src_ep);
+	
+	ret = check_lock_caller(&task_ptr, &caller_ptr, &caller_pid);
+	if(ret) ERROR_RETURN(ret);
+
+	caller_nr   = caller_ptr->p_usr.p_nr;
+	caller_ep   = caller_ptr->p_usr.p_endpoint;
+	MOLDEBUG(DBGPARAMS,"caller_nr=%d caller_ep=%d src_ep=%d \n", caller_nr, caller_ep, src_ep);
+	caller_ptr->p_umsg 	= m_ptr;
+
+	/*------------------------------------------
+	 * Checks the caller process 
+ 	 * Gets the VMID
+	 * Checks if the VM is RUNNING
+	 * Locks the VM
+      *------------------------------------------*/
+	ret = OK;
+	do {
+		if (caller_pid != caller_ptr->p_usr.p_lpid) 	{ret = EMOLBADPID; break;}
+		vmid		= caller_ptr->p_usr.p_vmid;
+		MOLDEBUG(INTERNAL,"vmid=%d\n", vmid);
+		if( vmid < 0 || vmid >= drvs.d_nr_vms) 		{ret =EMOLBADVMID; break;}
+		vm_ptr 	= &vm[vmid];
+		RLOCK_VM(vm_ptr);
+		if( vm_ptr->vm_usr.vm_flags)  ret = EMOLVMNOTRUN;
+		RUNLOCK_VM(vm_ptr);
+	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}
+	
+	if( src_ep != ANY)	{
+		do {
+			src_nr = _ENDPOINT_P(src_ep);
+			if( src_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 
+			  || src_nr >= vm_ptr->vm_usr.vm_nr_procs) 	{ret = EMOLRANGE ;break;}
+			if( caller_ep == src_ep) 					{ret = EMOLENDPOINT;break;}
+			src_ptr = NBR2PTR(vm_ptr, src_nr);
+			if( src_ptr == NULL) 						{ret = EMOLSRCDIED;break;}
+			if( test_bit(BIT_SLOT_FREE, &src_ptr->p_usr.p_rts_flags))
+														{ret = EMOLSRCDIED;break;}
+			if (src_ptr->p_usr.p_endpoint != src_ep)	{ret = EMOLENDPOINT;break;}
+	
+			if( IT_IS_REMOTE(src_ptr)) {
+				/* verify if the RECEIVER PROXY of the process is CONNECTED and RUNNING */
+				nodeid = src_ptr->p_usr.p_nodeid;
+				if( nodeid < 0 || nodeid >= drvs.d_nr_nodes) 	{ret = EMOLBADNODEID;break;}
+
+				rproxy_ptr = NODE2RPROXY(nodeid); 
+				RLOCK_PROC(rproxy_ptr);
+				if( ! test_bit(nodeid, &vm_ptr->vm_usr.vm_nodes)) 	{ret = EMOLNOVMNODE ;break;}
+				if( rproxy_ptr->p_usr.p_lpid == PROC_NO_PID)		{ret = EMOLNOPROXY ;break;}
+//				if( nptr->n_usr.n_flags == NODE_FREE) 			{ret = EMOLNOPROXY;break;}
+				if( test_bit( BIT_SLOT_FREE, &rproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_PROXY, &rproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_CONNECTED, &rproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOTCONN;break;}  
+				RUNLOCK_PROC(rproxy_ptr);
+			}
+		}while(0);
+		if( ret) ERROR_RETURN(ret);
+	}
+
+	if (caller_ptr->p_usr.p_rts_flags) 	{
+		MOLDEBUG(GENERIC,"caller not ready p_rts_flags=%lX\n",caller_ptr->p_usr.p_rts_flags);
+		WUNLOCK_PROC(caller_ptr);							
+		ERROR_RETURN(EMOLNOTREADY);
+	}
+
+	/*--------------------------------------*/
+	/* NOTIFY PENDING LOOP			*/
+	/*--------------------------------------*/
+
+    	map = &caller_ptr->p_priv.s_notify_pending;
+    	for (chunk=&map->chunk[0]; chunk<&map->chunk[NR_SYS_CHUNKS]; chunk++) {
+    		if (! *chunk) continue; 			/* no bits in chunk */
+    		for (i=0; ! (*chunk & (1<<i)); ++i) {} 	/* look up the bit */
+    		sys_id = (chunk - &map->chunk[0]) * BITCHUNK_BITS + i;
+    		if (sys_id >= vm_ptr->vm_usr.vm_nr_sysprocs) break;		/* out of range */
+		sys_nr = (sys_id-vm_ptr->vm_usr.vm_nr_tasks);	/* get source endpoint */
+		src_ep = sys_nr;
+		MOLDEBUG(INTERNAL  ,"sys_id=%d sys_nr=%d src_ep=%d\n", sys_id, sys_nr, src_ep);
+		if ( (src_ep != ANY) && (_ENDPOINT_P(src_ep) != sys_nr) ) continue;/* source not ok */
+		*chunk &= ~(1 << i);			/* no longer pending */
+		MOLDEBUG(INTERNAL  ,"deliver the notification message sys_id=%d src_ep=%d\n", sys_id, src_ep);
+	   	/* Found a suitable source, deliver the notification message. */
+		BUILD_NOTIFY_MSG( vm_ptr, caller_ptr, src_ep);
+		t_ptr = &caller_ptr->p_message.m9_t1;
+		MOLDEBUG(INTERNAL  ,TIME_FORMAT,TIME_FIELDS(t_ptr) );
+		COPY_TO_USER_PROC(ret, (void *)&caller_ptr->p_message, (void *)m_ptr,  sizeof(message));
+		WUNLOCK_PROC(caller_ptr);
+		if (ret != 0) ERROR_RETURN(EMOLMSGSIZE);
+		return(OK);	/* report success */
+	}
+
+	/*-----------------------------------------*/
+	/* MESSAGE RECEIVE 		*/
+	/*-----------------------------------------*/
+
+	list_for_each_entry_safe(xpp, tmp_ptr, &caller_ptr->p_list, p_link) {
+		if (src_ep == xpp->p_usr.p_endpoint || src_ep == ANY ) {
+			MOLDEBUG(GENERIC,"Found acceptable message from %d. Copy it and update status.\n",xpp->p_usr.p_endpoint );
+			/* Here is a message from xpp process, therefore xpp  must be sleeping in SENDING state */
+
+			WLOCK_ORDERED2(caller_ptr,xpp);
+			list_del(&xpp->p_link); /* remove from queue */
+
+			/* test the sender status */
+			do	{
+				if( test_bit(BIT_SLOT_FREE, &xpp->p_usr.p_rts_flags))	{ret = EMOLSRCDIED; break;} 	
+				if( !test_bit(BIT_SENDING, &xpp->p_usr.p_rts_flags))	{ret = EMOLPROCSTS; break;} 	
+				if( xpp->p_usr.p_sendto != caller_ptr->p_usr.p_endpoint) 	{ret = EMOLPROCSTS; break;} 
+				if( (src_ep != ANY) && (xpp->p_usr.p_endpoint != src_ep))	{ret = EMOLENDPOINT;break;}
+				ret = OK;
+			} while(0);
+		
+			if(ret == OK) {			
+				if( IT_IS_REMOTE(xpp) ){ 
+					COPY_TO_USER_PROC(ret, (void *)&xpp->p_message, (void *) m_ptr, sizeof(message));
+		 			if( !test_bit(BIT_RECEIVING, &xpp->p_usr.p_rts_flags)) {
+						send_ack_lcl2rmt(xpp, caller_ptr, ret);
+					}
+				}else {
+					COPY_USR2USR_PROC(ret, xpp->p_usr.p_endpoint, xpp, (char *)xpp->p_umsg,
+						caller_ptr, (char *)m_ptr, sizeof(message) );
+				} 
+				clear_bit(BIT_SENDING, &xpp->p_usr.p_rts_flags);
+				xpp->p_usr.p_sendto 	= NONE;
+				if(xpp->p_usr.p_rts_flags == 0) 
+					LOCAL_PROC_UP(xpp, ret);
+			}
+				
+			WUNLOCK_PROC(xpp);
+			WUNLOCK_PROC(caller_ptr);
+			if( ret) ERROR_RETURN(ret);
+			return(OK);
+		}else{
+			MOLDEBUG(GENERIC,"Found a message from %d but not acceptable \n",xpp->p_usr.p_endpoint );	
+		}
+	}
+		
+	set_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+	clear_bit(MIS_BIT_NOTIFY, &caller_ptr->p_usr.p_misc_flags);
+	caller_ptr->p_usr.p_getfrom 	= src_ep;
+	caller_ptr->p_rcode		= OK;
+	MOLDEBUG(GENERIC,"Any suitable message from %d was not found.\n", src_ep);	
+
+	sleep_proc(caller_ptr, timeout_ms);
+
+	ret = caller_ptr->p_rcode;
+	if( ret != OK){
+		clear_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+		caller_ptr->p_usr.p_getfrom 	= NONE;
+	}else {
+		if(test_bit(MIS_BIT_NOTIFY,&caller_ptr->p_usr.p_misc_flags)){
+			COPY_TO_USER_PROC(ret, &caller_ptr->p_message, caller_ptr->p_umsg, sizeof(message) );
+			mptr = &caller_ptr->p_message;
+			MOLDEBUG(DBGMESSAGE, MSG9_FORMAT, MSG9_FIELDS(mptr));			
+		}
+	}
+	clear_bit(MIS_BIT_NOTIFY, &caller_ptr->p_usr.p_misc_flags);
+
+	WUNLOCK_PROC(caller_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(OK);
+}	
+
+/*--------------------------------------------------------------*/
+/*			mol_mini_sendrec			*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_mini_sendrec(int srcdst_ep, message* m_ptr, long timeout_ms)
+{
+	struct proc *srcdst_ptr, *caller_ptr, *sproxy_ptr;
+	VM_desc_t *vm_ptr;
+	int ret, retry;
+	int caller_nr, caller_pid, caller_ep;
+	int srcdst_nr;
+	int vmid, nodeid;
+	struct task_struct *task_ptr;	
+
+	MOLDEBUG(DBGPARAMS,"srcdst_ep=%d\n", srcdst_ep);
+	if( DRVS_NOT_INIT() ) 				ERROR_RETURN(EMOLDRVSINIT);
+
+	ret = check_lock_caller(&task_ptr, &caller_ptr, &caller_pid);
+	if(ret) ERROR_RETURN(ret);
+
+	caller_nr   = caller_ptr->p_usr.p_nr;
+	caller_ep   = caller_ptr->p_usr.p_endpoint;
+	MOLDEBUG(DBGPARAMS,"caller_nr=%d caller_ep=%d \n", caller_nr, caller_ep);
+	caller_ptr->p_umsg 		= m_ptr;
+
+	/*------------------------------------------
+	 * Checks the caller process 
+ 	 * Gets the VMID
+	 * Checks if the VM is RUNNING
+	 * Locks the VM
+      *------------------------------------------*/
+	ret = OK;
+	do {
+		if (caller_pid != caller_ptr->p_usr.p_lpid) 	{ret = EMOLBADPID; break;}
+		vmid		= caller_ptr->p_usr.p_vmid;
+		MOLDEBUG(INTERNAL,"vmid=%d\n", vmid);
+		if( vmid < 0 || vmid >= drvs.d_nr_vms) 		{ret =EMOLBADVMID; break;}
+		vm_ptr 	= &vm[vmid];
+		RLOCK_VM(vm_ptr);
+		if( vm_ptr->vm_usr.vm_flags)  ret = EMOLVMNOTRUN;
+		RUNLOCK_VM(vm_ptr);	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}
+
+sendrec_replay:
+	ret = OK;
+
+	/*------------------------------------------
+	 * get the destination process number
+	*------------------------------------------*/
+	do {
+		srcdst_nr = _ENDPOINT_P(srcdst_ep);
+		if( srcdst_nr < (-vm_ptr->vm_usr.vm_nr_tasks)		
+		 || srcdst_nr >= vm_ptr->vm_usr.vm_nr_procs)	{ret = EMOLRANGE; break;}
+		srcdst_ptr   = NBR2PTR(vm_ptr, srcdst_nr);
+		if( srcdst_ptr == NULL) 			{ret = EMOLDSTDIED; break;}
+		if( caller_ep == srcdst_ep) 			{ret = EMOLENDPOINT; break;}
+	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}
+
+	/*------------------------------------------
+	 * check the destination process status
+	*------------------------------------------*/
+	WLOCK_ORDERED2(caller_ptr,srcdst_ptr);
+	MOLDEBUG(DBGPARAMS,"srcdst_nr=%d srcdst_ep=%d\n",srcdst_nr, srcdst_ptr->p_usr.p_endpoint);
+
+	do	{
+		ret = OK;
+		retry = 0;
+		if (caller_ptr->p_usr.p_rts_flags ) 				{ret = EMOLNOTREADY; break;} 	/* Caller is NOT READY! 	*/
+		if (srcdst_ptr->p_usr.p_endpoint != srcdst_ep) 			{ret = EMOLENDPOINT; break;} 	/* Paranoid checking	*/
+		if (test_bit(BIT_SLOT_FREE, &srcdst_ptr->p_usr.p_rts_flags))	{ret = EMOLDEADSRCDST; break;} 	/*destination died		*/
+		if( test_bit(BIT_MIGRATE, &srcdst_ptr->p_usr.p_rts_flags))	{
+			set_bit(BIT_WAITMIGR, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_waitmigr = srcdst_ep;
+			INIT_LIST_HEAD(&caller_ptr->p_mlink);
+			list_add_tail(&caller_ptr->p_mlink, &srcdst_ptr->p_mlist);
+			sleep_proc2(caller_ptr, srcdst_ptr, timeout_ms);
+			ret = caller_ptr->p_rcode;
+			retry = 1;
+		} 	
+	} while(retry);
+	if(ret) {							
+		WUNLOCK_PROC2(caller_ptr, srcdst_ptr);
+		ERROR_RETURN(ret);
+	}
+
+	MOLDEBUG(DBGPARAMS,"vmid=%d caller_pid=%d caller_nr=%d srcdst_ep=%d \n",vmid, caller_pid,caller_nr, srcdst_ep);
+
+	/*--------------------------------------*/
+	/* SENDING/RECEIVING		*/
+	/*--------------------------------------*/
+	MOLDEBUG(GENERIC,"SENDING HALF\n");
+
+	caller_ptr->p_rcode	= OK;
+	caller_ptr->p_usr.p_getfrom  = srcdst_ep;
+
+	if( IT_IS_REMOTE(srcdst_ptr)) {		/* the destination is REMOTE */
+		/*---------------------------------------------------------------------------------------------------*/
+		/*						REMOTE 								 */
+		/*---------------------------------------------------------------------------------------------------*/
+
+		/* get destination nodeid */
+		nodeid = srcdst_ptr->p_usr.p_nodeid;
+		if( nodeid < 0 || nodeid >= drvs.d_nr_nodes) 	 {							
+			ret = EMOLBADNODEID;
+		} else {
+			sproxy_ptr = get_sproxy(nodeid); 
+			RLOCK_PROC(sproxy_ptr);
+			do {
+				ret = OK;
+				if( ! test_bit(nodeid, &vm_ptr->vm_usr.vm_nodes)) 	{ret = EMOLNOVMNODE ;break;}
+				if( sproxy_ptr->p_usr.p_lpid == PROC_NO_PID)		{ret = EMOLNOPROXY ;break;}
+//				if( nptr->n_usr.n_flags == NODE_FREE) 			{ret = EMOLNOPROXY;break;}
+				if( test_bit( BIT_SLOT_FREE, &sproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_PROXY, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOTCONN;break;}  
+			} while(0);
+			RUNLOCK_PROC(sproxy_ptr);
+		}
+
+		if(ret) {							
+			WUNLOCK_PROC2(caller_ptr, srcdst_ptr);
+			ERROR_RETURN(ret);
+		}
+		WUNLOCK_PROC(srcdst_ptr);
+
+		/* fill the caller's rmtcmd fields */
+		caller_ptr->p_rmtcmd.c_cmd 	= CMD_SNDREC_MSG;
+		caller_ptr->p_rmtcmd.c_src 	= caller_ep;
+		caller_ptr->p_rmtcmd.c_dst 	= srcdst_ep;
+		caller_ptr->p_rmtcmd.c_vmid	= vmid;
+		caller_ptr->p_rmtcmd.c_snode  	= atomic_read(&local_nodeid);
+		caller_ptr->p_rmtcmd.c_dnode  	= nodeid;
+		caller_ptr->p_rmtcmd.c_rcode  	= OK;
+		caller_ptr->p_rmtcmd.c_len  	= sizeof(message);
+
+		INIT_LIST_HEAD(&caller_ptr->p_link);
+		set_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+		set_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+		set_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+		caller_ptr->p_usr.p_sendto  = srcdst_ep;
+		caller_ptr->p_usr.p_getfrom = srcdst_ep;
+		
+		ret = sproxy_enqueue(caller_ptr);
+
+		/* wait for the REPLY */
+		sleep_proc(caller_ptr, timeout_ms);
+
+		ret = caller_ptr->p_rcode;
+		if( ret == OK){
+			caller_ptr->p_usr.p_rmtsent++;
+		}else{
+			if( test_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags)) {
+				MOLDEBUG(GENERIC,"removing %d link from sender's proxy list.\n",
+					 caller_ptr->p_usr.p_endpoint);
+				list_del(&caller_ptr->p_link); /* remove from queue ATENCION: HAY Q PROTEGER PROXY ?? */
+			}
+			clear_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+			clear_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+			clear_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_sendto  = NONE;
+			caller_ptr->p_usr.p_getfrom = NONE;
+			caller_ptr->p_usr.p_proxy = PROC_NO_PID;
+			if( ret == EMOLMIGRATE) goto sendrec_replay;
+		}
+	} else {
+		/*---------------------------------------------------------------------------------------------------*/
+		/*						LOCAL  								 */
+		/*---------------------------------------------------------------------------------------------------*/
+		/* Check if 'dst' is blocked waiting for this message.   */
+		if (  (test_bit(BIT_RECEIVING, &srcdst_ptr->p_usr.p_rts_flags) && !test_bit(BIT_SENDING, &srcdst_ptr->p_usr.p_rts_flags)) &&
+			(srcdst_ptr->p_usr.p_getfrom == ANY || srcdst_ptr->p_usr.p_getfrom == caller_ep)) {
+			MOLDEBUG(GENERIC,"destination is waiting. Copy the message and wakeup destination\n");
+			clear_bit(BIT_RECEIVING, &srcdst_ptr->p_usr.p_rts_flags);
+			srcdst_ptr->p_usr.p_getfrom 	= NONE;
+
+			COPY_USR2USR_PROC(ret, caller_ep, caller_ptr, (char *) m_ptr, srcdst_ptr, (char *) srcdst_ptr->p_umsg, sizeof(message) );
+			if(srcdst_ptr->p_usr.p_rts_flags == 0) 
+				LOCAL_PROC_UP(srcdst_ptr, ret); 
+			if(ret) {
+				caller_ptr->p_usr.p_getfrom  	= NONE;
+				caller_ptr->p_usr.p_sendto 	= NONE;
+				WUNLOCK_PROC2(caller_ptr, srcdst_ptr);
+				ERROR_RETURN(ret);
+			}
+			set_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags); /* Sending part: completed, now receiving.. */
+			WUNLOCK_PROC(srcdst_ptr);
+			sleep_proc(caller_ptr, timeout_ms); 
+			ret = caller_ptr->p_rcode;
+			if( ret) {
+				clear_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+				clear_bit(BIT_SENDING,   &caller_ptr->p_usr.p_rts_flags);
+				caller_ptr->p_usr.p_getfrom    	= NONE;
+				caller_ptr->p_usr.p_sendto 	= NONE;
+			}else {
+				caller_ptr->p_usr.p_lclsent++;
+			}
+		} else { 
+			MOLDEBUG(GENERIC,"destination is not waiting srcdst_ptr->p_usr.p_rts_flags=%lX. Enqueue at the TAIL.\n",srcdst_ptr->p_usr.p_rts_flags);
+			/* The destination is not waiting for this message 			*/
+			/* Append the caller at the TAIL of the destination senders' queue	*/
+			/* blocked sending the message */
+					
+			caller_ptr->p_message.m_source = caller_ptr->p_usr.p_endpoint;
+			set_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+			set_bit(BIT_SENDING,   &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_sendto 	= srcdst_ep;	
+			INIT_LIST_HEAD(&caller_ptr->p_link);
+			list_add_tail(&caller_ptr->p_link, &srcdst_ptr->p_list);
+			sleep_proc2(caller_ptr, srcdst_ptr, timeout_ms); 
+			ret = caller_ptr->p_rcode;
+			if( ret) {
+				if( test_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags)){
+					MOLDEBUG(GENERIC,"removing %d link from %d list.\n", caller_ptr->p_usr.p_endpoint, srcdst_ep);
+					list_del(&caller_ptr->p_link); /* remove from queue */
+				} else {
+					caller_ptr->p_usr.p_lclsent++;
+				}
+				clear_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+				clear_bit(BIT_SENDING,   &caller_ptr->p_usr.p_rts_flags);
+				caller_ptr->p_usr.p_getfrom    	= NONE;
+				caller_ptr->p_usr.p_sendto 	= NONE;
+				WUNLOCK_PROC(srcdst_ptr);
+				if( ret == EMOLMIGRATE) goto sendrec_replay;
+			} else {
+				caller_ptr->p_usr.p_lclsent++;
+				WUNLOCK_PROC(srcdst_ptr);
+			}
+		}
+	}
+
+	WUNLOCK_PROC(caller_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(ret);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_mini_notify				*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_mini_notify(int src_ep, int dst_ep)
+{
+
+	struct proc *dst_ptr, *caller_ptr, *sproxy_ptr;
+	VM_desc_t *vm_ptr;
+	int caller_nr, caller_pid, caller_ep;
+	int dst_nr;
+	int vmid, ret, nodeid;
+	struct task_struct *task_ptr;	
+	struct timespec *t_ptr;
+	message *mptr;
+
+	MOLDEBUG(DBGPARAMS,"src_ep=%d dst_ep=%d\n", src_ep, dst_ep);
+	if( DRVS_NOT_INIT() ) 			ERROR_RETURN(EMOLDRVSINIT);
+
+	ret = check_lock_caller(&task_ptr, &caller_ptr, &caller_pid);
+	if(ret) ERROR_RETURN(ret);
+
+	caller_nr   = caller_ptr->p_usr.p_nr;
+	caller_ep   = caller_ptr->p_usr.p_endpoint;
+	MOLDEBUG(DBGPARAMS,"caller_nr=%d caller_ep=%d \n", caller_nr, caller_ep);
+
+	if( src_ep != SELF) caller_ep = src_ep;
+
+	/*------------------------------------------
+	 * Checks the caller process 
+ 	 * Gets the VMID
+	 * Checks if the VM is RUNNING
+	 * Locks the process mutex to avoid thread
+	 * concurrency.
+	 * Locks the VM
+      *------------------------------------------*/
+	ret = OK;
+	do {
+		if (caller_pid != caller_ptr->p_usr.p_lpid) 	{ret = EMOLBADPID; break;}
+		vmid		= caller_ptr->p_usr.p_vmid;
+		MOLDEBUG(INTERNAL,"vmid=%d\n", vmid);
+		if( vmid < 0 || vmid >= drvs.d_nr_vms) 		{ret =EMOLBADVMID; break;}
+		vm_ptr 	= &vm[vmid];
+		RLOCK_VM(vm_ptr);
+		if( vm_ptr->vm_usr.vm_flags)  ret = EMOLVMNOTRUN;
+		RUNLOCK_VM(vm_ptr);
+	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}
+
+notify_replay:
+	ret = OK;
+
+	/*------------------------------------------
+	 * get the destination process number
+	*------------------------------------------*/
+	do {
+		dst_nr = _ENDPOINT_P(dst_ep);
+		if( dst_nr < (-vm_ptr->vm_usr.vm_nr_tasks)		
+		 || dst_nr >= vm_ptr->vm_usr.vm_nr_procs)	{ret = EMOLRANGE; break;}
+		dst_ptr   = NBR2PTR(vm_ptr, dst_nr);
+		if( dst_ptr == NULL) 				{ret = EMOLDSTDIED; break;}
+		if( caller_ep == dst_ep) 			{ret = EMOLENDPOINT; break;}
+	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}
+
+	/*------------------------------------------
+	 * check the destination process status
+	*------------------------------------------*/
+	WLOCK_ORDERED2(caller_ptr,dst_ptr);
+	MOLDEBUG(DBGPARAMS,"dst_nr=%d dst_ep=%d\n",dst_nr, dst_ptr->p_usr.p_endpoint);
+	do	{
+		ret = OK;
+		if (caller_ptr->p_usr.p_rts_flags ) 		{ret = EMOLNOTREADY; break;} 	/* Caller is NOT READY! 	*/
+		if (dst_ptr->p_usr.p_endpoint != dst_ep) 	{ret = EMOLENDPOINT; break;} 	/* Paranoid checking		*/
+		if( test_bit(BIT_SLOT_FREE, &dst_ptr->p_usr.p_rts_flags))	{ret = EMOLDSTDIED; break;} 	/*destination died		*/
+		if( test_bit(BIT_MIGRATE, &dst_ptr->p_usr.p_rts_flags)) {	/*destination is migrating	*/
+			MOLDEBUG(GENERIC,"destination is migrating dst_ptr->p_usr.p_rts_flags=%lX\n",dst_ptr->p_usr.p_rts_flags);
+  			/* Add to destination the bit map with pending notifications  */
+			if(get_sys_bit(dst_ptr->p_priv.s_notify_pending, caller_ptr->p_priv.s_usr.s_id))
+									{ret = EMOLOVERRUN; break;}
+			MOLDEBUG(INTERNAL,"set_sys_bit caller_ptr->p_priv.s_usr.s_id=%d\n",caller_ptr->p_priv.s_usr.s_id);
+			set_sys_bit(dst_ptr->p_priv.s_notify_pending, caller_ptr->p_priv.s_usr.s_id);
+			WUNLOCK_PROC2(caller_ptr, dst_ptr);
+			return(OK);
+		}
+	} while(0);
+	if(ret) {							
+		WUNLOCK_PROC2(caller_ptr, dst_ptr);
+		ERROR_RETURN(ret);
+	}
+	
+	MOLDEBUG(DBGPARAMS,"vmid=%d caller_pid=%d caller_nr=%d dst_ep=%d \n",vmid, caller_pid,caller_nr, dst_ep);
+
+	caller_ptr->p_rcode= OK;
+	if( IT_IS_REMOTE(dst_ptr)) {		/* the destination is REMOTE */
+		/*---------------------------------------------------------------------------------------------------*/
+		/*						REMOTE  								 */
+		/*---------------------------------------------------------------------------------------------------*/	
+
+		/* get destination nodeid */
+		nodeid = dst_ptr->p_usr.p_nodeid;
+		if( nodeid < 0 || nodeid >= drvs.d_nr_nodes) 	 {							
+			ret = EMOLBADNODEID;
+		} else {
+			sproxy_ptr = get_sproxy(nodeid); 
+			RLOCK_PROC(sproxy_ptr);
+			do {
+				ret = OK;
+				if( ! test_bit(nodeid, &vm_ptr->vm_usr.vm_nodes)) 	{ret = EMOLNOVMNODE ;break;}
+				if( sproxy_ptr->p_usr.p_lpid == PROC_NO_PID)		{ret = EMOLNOPROXY ;break;}
+//				if( nptr->n_usr.n_flags == NODE_FREE) 			{ret = EMOLNOPROXY;break;}
+				if( test_bit( BIT_SLOT_FREE, &sproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_PROXY, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOTCONN;break;}  
+			} while(0);
+			RUNLOCK_PROC(sproxy_ptr);
+		}
+ 
+		if(ret) {							
+			WUNLOCK_PROC2(caller_ptr, dst_ptr);
+			ERROR_RETURN(ret);
+		}
+
+		clear_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags);
+		if(	dst_ptr->p_usr.p_getfrom == caller_ptr->p_usr.p_endpoint){
+					dst_ptr->p_usr.p_getfrom = NONE;
+		}
+
+		/* fill the caller's rmtcmd fields */
+		caller_ptr->p_rmtcmd.c_cmd 	= CMD_NTFY_MSG;
+		caller_ptr->p_rmtcmd.c_src 	= caller_ep;
+		caller_ptr->p_rmtcmd.c_dst 	= dst_ep;
+		caller_ptr->p_rmtcmd.c_vmid	= vmid;
+		caller_ptr->p_rmtcmd.c_snode  	= atomic_read(&local_nodeid);
+		caller_ptr->p_rmtcmd.c_dnode  	= nodeid;
+		caller_ptr->p_rmtcmd.c_rcode  	= OK;
+		caller_ptr->p_rmtcmd.c_len  	= 0;
+
+		INIT_LIST_HEAD(&caller_ptr->p_link);
+		set_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+		set_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+		caller_ptr->p_usr.p_sendto = dst_ep;
+		
+		ret = sproxy_enqueue(caller_ptr);
+
+		/* wait that the proxy wakes up  to free the caller's descriptor  */
+		sleep_proc2(caller_ptr, dst_ptr, TIMEOUT_FOREVER);
+		ret = caller_ptr->p_rcode;
+		if( ret == OK){
+			caller_ptr->p_usr.p_rmtsent++;
+		}else{
+			if( test_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags)) {
+				MOLDEBUG(GENERIC,"removing %d link from sender's proxy list.\n", caller_ptr->p_usr.p_endpoint);
+				list_del(&caller_ptr->p_link); /* remove from queue ATENCION: HAY Q PROTEGER PROXY ?? */
+			}
+			clear_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+			clear_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_sendto = NONE;
+			caller_ptr->p_usr.p_proxy = PROC_NO_PID;
+			if( ret == EMOLMIGRATE) {
+				WUNLOCK_PROC(dst_ptr);
+				goto notify_replay;
+			}
+		}
+	} else {							/* Destination is LOCAL */
+		/*---------------------------------------------------------------------------------------------------*/
+		/*						LOCAL  								 */
+		/*---------------------------------------------------------------------------------------------------*/
+		/* Check if 'dst' is blocked waiting for this message.   */
+		if (  (test_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags) && !test_bit(BIT_SENDING, &dst_ptr->p_usr.p_rts_flags) )&&
+			(dst_ptr->p_usr.p_getfrom == ANY || dst_ptr->p_usr.p_getfrom == caller_ep)) {
+			MOLDEBUG(GENERIC,"destination is waiting. Build the message and wakeup destination\n");
+
+			/* Build the message in the destination buffer */
+			BUILD_NOTIFY_MSG(vm_ptr, dst_ptr, caller_ep);
+			mptr = &dst_ptr->p_message;
+			MOLDEBUG(DBGMESSAGE, MSG9_FORMAT, MSG9_FIELDS(mptr));			
+
+			set_bit(MIS_BIT_NOTIFY, &dst_ptr->p_usr.p_misc_flags);
+
+			t_ptr = &caller_ptr->p_message.m9_t1;
+			MOLDEBUG(GENERIC,TIME_FORMAT,TIME_FIELDS(t_ptr) );
+			clear_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags);
+			dst_ptr->p_usr.p_getfrom 	= NONE;
+			if(dst_ptr->p_usr.p_rts_flags == 0)
+				LOCAL_PROC_UP(dst_ptr, OK); /* ATENTI puede haber mas de una razon para despertar al proceso!! */
+		} else { 
+			MOLDEBUG(GENERIC,"destination is not waiting dst_ptr->p_usr.p_rts_flags=%lX\n",dst_ptr->p_usr.p_rts_flags);
+  			/* Add to destination the bit map with pending notifications  */
+			if(get_sys_bit(dst_ptr->p_priv.s_notify_pending, caller_ptr->p_priv.s_usr.s_id))
+				ERROR_PRINT(EMOLOVERRUN);
+			MOLDEBUG(INTERNAL,"set_sys_bit caller_ptr->p_priv.s_usr.s_id=%d\n",caller_ptr->p_priv.s_usr.s_id);
+			set_sys_bit(dst_ptr->p_priv.s_notify_pending, caller_ptr->p_priv.s_usr.s_id); 
+		}
+	}
+
+	ret = caller_ptr->p_rcode;
+	if(ret == OK){
+		if( IT_IS_REMOTE(dst_ptr)) 	caller_ptr->p_usr.p_rmtsent++;
+		else				caller_ptr->p_usr.p_lclsent++;
+	} else { /* Only for remote destination */ 
+		clear_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+		caller_ptr->p_usr.p_sendto 	= NONE;
+	}
+
+	WUNLOCK_PROC2(caller_ptr, dst_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(ret);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_mini_relay				*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_mini_relay(int dst_ep, message* m_ptr)
+{
+	return(OK);
+}
+
+/*----------------------------------------------------------------*/
+/*			mol_vcopy				*/
+/* This function is used to:			*/
+/*  - Copy messages: when src_ep =! NONE and bytes=sizeof(message) */
+/*   - Copy data blocks: when src_ep == NONE	*/
+/*----------------------------------------------------------------*/
+
+asmlinkage long mol_vcopy(int src_ep, char *src_addr, int dst_ep,char *dst_addr, int bytes)
+{
+	struct proc *src_ptr, *dst_ptr, *caller_ptr, *sproxy_ptr;
+	int src_nr, dst_nr, caller_nr;
+	int caller_pid;
+	int src_pid , src_tgid;
+	int dst_pid , dst_tgid;
+	VM_desc_t *vm_ptr;
+	int caller_ep;
+	int vmid, dnodeid, snodeid;
+	int copylen;
+	int retry, ret = OK;
+	struct task_struct *task_ptr;
+	cmd_t *cmd_ptr;
+	
+	MOLDEBUG(DBGPARAMS,"src_ep=%d dst_ep=%d bytes=%d\n",src_ep, dst_ep, bytes);
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(-EPERM);
+
+	if( bytes < 0 || bytes  > drvs.d_max_copylen) ERROR_RETURN(EMOLRANGE);
+ 
+	if( (src_ep == dst_ep) 	|| 	(src_ep == ANY)	|| 
+		(dst_ep == ANY) ||	(src_ep == NONE)|| 
+		(dst_ep == NONE) )		ERROR_RETURN(EMOLENDPOINT);
+
+	if( DRVS_NOT_INIT() ) 		ERROR_RETURN(EMOLDRVSINIT);
+
+	ret = check_lock_caller(&task_ptr, &caller_ptr, &caller_pid);
+	if(ret) ERROR_RETURN(ret);
+
+	/*------------------------------------------
+	 * Checks the caller process 
+ 	 * Gets the VMID
+	 * Checks if the VM is RUNNING
+	 * Locks the process mutex to avoid thread
+	 * concurrency.
+	 * Locks the VM
+      *------------------------------------------*/
+	ret = OK;
+	do {
+		if (caller_pid != caller_ptr->p_usr.p_lpid) 	{ret = EMOLBADPID; break;}
+		vmid		= caller_ptr->p_usr.p_vmid;
+		MOLDEBUG(INTERNAL,"vmid=%d\n", vmid);
+		if( vmid < 0 || vmid >= drvs.d_nr_vms) 		{ret =EMOLBADVMID; break;}
+		vm_ptr 	= &vm[vmid];
+		RLOCK_VM(vm_ptr);
+		if( vm_ptr->vm_usr.vm_flags)  ret = EMOLVMNOTRUN;
+		RUNLOCK_VM(vm_ptr);
+	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}
+		
+	/*-------------------------------------------------------------*/
+	/*	get info about SOURCE and DESTINATION processes */
+	/*-------------------------------------------------------------*/
+
+	src_nr  = _ENDPOINT_P(src_ep);
+	CHECK_P_NR(task_ptr, vm_ptr,src_nr);	/* check process number limits */
+	src_ptr = NBR2PTR(vm_ptr,src_nr);
+
+
+	dst_nr  = _ENDPOINT_P(dst_ep);
+	CHECK_P_NR(task_ptr, vm_ptr,dst_nr);	/* check process number limits */
+	dst_ptr = NBR2PTR(vm_ptr, dst_nr);
+
+	/*-------------------------------------------------------------*/
+	/*	LOCK PROCESSES IN ASCENDENT ORDER		*/
+	/*-------------------------------------------------------------*/
+	MOLDEBUG(GENERIC,"LOCK PROCESSES IN ASCENDENT ORDER\n");
+	WUNLOCK_PROC(caller_ptr);
+	if( src_ptr != caller_ptr && dst_ptr != caller_ptr ) {	/* Requester is a third process */
+		WLOCK_PROC3(caller_ptr,src_ptr,dst_ptr);
+	}else {
+		if( dst_ptr != caller_ptr) {					/* requester is the source	*/
+			WLOCK_PROC2(caller_ptr,dst_ptr);
+		}else{
+			WLOCK_PROC2(caller_ptr,src_ptr);			/* requester is the destination */
+		}
+	}
+	
+	MOLDEBUG(GENERIC,"CHECK FOR SOURCE/DESTINATION STATUS\n");
+	do	{
+		retry = 0;
+		ret = OK;
+		if(caller_ptr->p_usr.p_rts_flags ) 							{ret = EMOLNOTREADY; break;} 	/* Caller is NOT READY! 		*/
+		
+		if(src_ptr->p_usr.p_endpoint != src_ep) 					{ret = EMOLENDPOINT; break;} 	/* Paranoid checking		*/
+		if(test_bit(BIT_SLOT_FREE, &src_ptr->p_usr.p_rts_flags))	{ret = EMOLSRCDIED; break;} 	/* source  died			*/
+		if(test_bit(BIT_ONCOPY, &src_ptr->p_usr.p_rts_flags)) 		{ret = EMOLBUSY; break;}	/* source  busy			*/
+		if( caller_ptr != src_ptr) {
+			if(IT_IS_REMOTE(src_ptr)){
+				if(test_bit(BIT_RMTOPER,&src_ptr->p_usr.p_rts_flags)){ret = EMOLBUSY; break;}	/*source is enqueue in SPROXY	*/
+			}else{
+				if(!test_bit(BIT_RECEIVING,&src_ptr->p_usr.p_rts_flags)){ret = EMOLPROCSTS; break;}	/* source is not blocked receiving */
+			}
+		}
+		if( src_ptr != caller_ptr ) {
+			if( test_bit(BIT_MIGRATE, &src_ptr->p_usr.p_rts_flags))	{
+				set_bit(BIT_WAITMIGR, &caller_ptr->p_usr.p_rts_flags);
+				caller_ptr->p_usr.p_waitmigr = src_ep;
+				INIT_LIST_HEAD(&caller_ptr->p_mlink);
+				list_add_tail(&caller_ptr->p_mlink, &src_ptr->p_mlist);
+				if( caller_ptr == dst_ptr) 
+					sleep_proc2(caller_ptr, src_ptr, TIMEOUT_FOREVER);
+				else
+					sleep_proc3(caller_ptr, src_ptr, dst_ptr, TIMEOUT_FOREVER);				
+				ret = caller_ptr->p_rcode;
+				retry = 1;
+				continue;
+			}
+		} 
+
+		if(dst_ptr->p_usr.p_endpoint != dst_ep) 			{ret = EMOLENDPOINT; break;} 	/* Paranoid checking		*/
+		if(test_bit(BIT_SLOT_FREE, &dst_ptr->p_usr.p_rts_flags))	{ret = EMOLDSTDIED; break;} 	/* destination died			*/
+		if(test_bit(BIT_ONCOPY, & dst_ptr->p_usr.p_rts_flags)) 		{ret = EMOLBUSY; break;}	/* destination busy			*/
+		if( caller_ptr != dst_ptr) {
+			if(IT_IS_REMOTE(dst_ptr)){
+				if(test_bit(BIT_RMTOPER,&dst_ptr->p_usr.p_rts_flags)) 	{ret = EMOLBUSY; break;} /* destination is enqueue in SPROXY	*/
+			}else{
+				if(!test_bit(BIT_RECEIVING,&dst_ptr->p_usr.p_rts_flags)){ret = EMOLPROCSTS; break;} /* destination is not blocked receiving */
+			}
+		}
+		if( dst_ptr != caller_ptr ) {
+			if( test_bit(BIT_MIGRATE, &dst_ptr->p_usr.p_rts_flags))	{
+				set_bit(BIT_WAITMIGR, &caller_ptr->p_usr.p_rts_flags);
+				caller_ptr->p_usr.p_waitmigr = dst_ep;
+				INIT_LIST_HEAD(&caller_ptr->p_mlink);
+				list_add_tail(&caller_ptr->p_mlink, &dst_ptr->p_mlist);
+				if( caller_ptr == src_ptr) 
+					sleep_proc2(caller_ptr, dst_ptr, TIMEOUT_FOREVER);
+				else
+					sleep_proc3(caller_ptr, dst_ptr, src_ptr, TIMEOUT_FOREVER);				
+				ret = caller_ptr->p_rcode;
+				retry = 1;
+				continue;
+			}
+		}
+	} while(retry);
+
+	if(ret) {	
+		if( src_ptr != caller_ptr && dst_ptr != caller_ptr ) {
+			WUNLOCK_PROC3(caller_ptr,src_ptr,dst_ptr);
+		}else {
+			if( dst_ptr != caller_ptr) {
+				WUNLOCK_PROC2(caller_ptr,dst_ptr);
+			}else{
+				WUNLOCK_PROC2(caller_ptr,src_ptr);
+			}
+		}
+		ERROR_RETURN(ret);
+	}
+
+	caller_nr   = caller_ptr->p_usr.p_nr;
+	caller_ep   = caller_ptr->p_usr.p_endpoint;
+	MOLDEBUG(DBGPARAMS,"CALLER vmid=%d caller_pid=%d caller_nr=%d caller_ep=%d \n",
+		vmid,caller_pid,caller_nr,caller_ep);
+		
+	set_bit(BIT_ONCOPY, &caller_ptr->p_usr.p_rts_flags);/* to signal other process that this is busy */
+	set_bit(BIT_ONCOPY, &src_ptr->p_usr.p_rts_flags); 	/* to signal other process that this is busy */
+	set_bit(BIT_ONCOPY, &dst_ptr->p_usr.p_rts_flags); 	/* to signal other process that this is busy */
+
+	MOLDEBUG(DBGPARAMS,"CALLER p_endpoint=%d \n", caller_ptr->p_usr.p_endpoint);
+	MOLDEBUG(DBGPARAMS,"SOURCE p_endpoint=%d \n", src_ptr->p_usr.p_endpoint);
+	MOLDEBUG(DBGPARAMS,"DESTIN p_endpoint=%d \n", dst_ptr->p_usr.p_endpoint);
+	MOLDEBUG(DBGPARAMS,"BYTES  bytes	=%d \n", bytes);
+
+	caller_ptr->p_rcode = ret =  OK;
+    
+	if( (IT_IS_LOCAL(src_ptr)) && (IT_IS_LOCAL(dst_ptr))) { 	/* source=LOCAL and destination=LOCAL 	*/
+		src_pid  = src_ptr->p_task->pid;
+		src_tgid = src_ptr->p_task->tgid;
+		dst_pid  = dst_ptr->p_task->pid;
+		dst_tgid = dst_ptr->p_task->tgid;
+		if( dst_tgid == src_tgid){ 
+			ret = EMOLPERM;
+		}else{
+			while( bytes > 0) {
+				copylen = (bytes > drvs.d_max_copybuf)?drvs.d_max_copybuf:bytes;
+				MOLDEBUG(INTERNAL,"COPY_USR2USR_PROC copylen=%d\n", copylen);
+				COPY_USR2USR_PROC(ret, NONE, src_ptr,  (char *)src_addr, dst_ptr, (char *) dst_addr, copylen);
+				if(ret) break;
+				bytes -=copylen;
+				src_addr += copylen;
+				dst_addr += copylen;
+			}
+		}
+		caller_ptr->p_rcode= ret;
+	} else if( (IT_IS_LOCAL(src_ptr)) && (IT_IS_REMOTE(dst_ptr))) {/* source=LOCAL and destination=REMOTE */
+		/* get destination nodeid */
+		dnodeid = dst_ptr->p_usr.p_nodeid;
+		if( dnodeid < 0 || dnodeid >= drvs.d_nr_nodes) 	 {							
+			ret = EMOLBADNODEID;
+		} else {
+			sproxy_ptr = get_sproxy(dnodeid); 
+			RLOCK_PROC(sproxy_ptr);
+			do {
+				if( ! test_bit(dnodeid, &vm_ptr->vm_usr.vm_nodes)) 	{ret = EMOLNOVMNODE ;break;}
+				if( sproxy_ptr->p_usr.p_lpid == PROC_NO_PID)		{ret = EMOLNOPROXY ;break;}
+//				if( dnptr->n_usr.n_flags == NODE_FREE) 			{ret = EMOLNOPROXY;break;}
+				if( test_bit( BIT_SLOT_FREE, &sproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_PROXY, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOTCONN;break;}  
+			} while(0);
+			RUNLOCK_PROC(sproxy_ptr);
+		}
+
+		if(ret == OK) {
+			while( bytes > 0) {
+				copylen = (bytes > drvs.d_max_copybuf)?drvs.d_max_copybuf:bytes;
+				MOLDEBUG(INTERNAL,"CMD_COPYIN_DATA copylen=%d\n", copylen);
+
+				/* Header of the message */
+				caller_ptr->p_rmtcmd.c_cmd   = CMD_COPYIN_DATA;
+				caller_ptr->p_rmtcmd.c_vmid  = vmid;
+				caller_ptr->p_rmtcmd.c_src   = caller_ptr->p_usr.p_endpoint;	
+				caller_ptr->p_rmtcmd.c_dst   = dst_ptr->p_usr.p_endpoint;	
+				caller_ptr->p_rmtcmd.c_snode = atomic_read(&local_nodeid); 
+				caller_ptr->p_rmtcmd.c_dnode = dst_ptr->p_usr.p_nodeid;		
+				caller_ptr->p_rmtcmd.c_rcode = OK;
+				caller_ptr->p_rmtcmd.c_len   = copylen;
+
+				/* subheader for the vcopy operation */
+				caller_ptr->p_rmtcmd.c_vcopy.v_src   = src_ptr->p_usr.p_endpoint;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_dst   = dst_ptr->p_usr.p_endpoint;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_rqtr  = caller_ptr->p_usr.p_endpoint;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_saddr = src_addr;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_daddr = dst_addr;	
+				caller_ptr->p_rmtcmd.c_vcopy.v_bytes = copylen;	
+
+				set_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+
+				cmd_ptr = &caller_ptr->p_rmtcmd;
+				MOLDEBUG(DBGCMD,"CMD_COPYIN_DATA " CMD_FORMAT, CMD_FIELDS(cmd_ptr));
+				MOLDEBUG(DBGVCOPY,"CMD_COPYIN_DATA " VCOPY_FORMAT, VCOPY_FIELDS(cmd_ptr));
+
+				ret = sproxy_enqueue(caller_ptr);
+				if(ret) break;
+
+				if(src_ptr != caller_ptr)
+					ret = sleep_proc3(caller_ptr, src_ptr, dst_ptr,TIMEOUT_FOREVER);
+				else
+					ret = sleep_proc2(caller_ptr, dst_ptr,TIMEOUT_FOREVER);
+				if(ret) break;
+				bytes -=copylen;
+				src_addr += copylen;
+				dst_addr += copylen;
+			}
+			
+		}
+	} else if( (IT_IS_REMOTE(src_ptr)) && (IT_IS_LOCAL(dst_ptr))){ /* source=REMOTE and destination=LOCAL */
+		snodeid = src_ptr->p_usr.p_nodeid;
+		if( snodeid < 0 || snodeid >= drvs.d_nr_nodes) 	 {							
+			ret = EMOLBADNODEID;
+		} else {
+			sproxy_ptr = get_sproxy(snodeid); 
+			RLOCK_PROC(sproxy_ptr);
+			do {
+				ret = OK;
+				if( ! test_bit(snodeid, &vm_ptr->vm_usr.vm_nodes)) 	{ret = EMOLNOVMNODE ;break;}
+				if( sproxy_ptr->p_usr.p_lpid == PROC_NO_PID)		{ret = EMOLNOPROXY ;break;}
+//				if( snptr->n_usr.n_flags == NODE_FREE) 			{ret = EMOLNOPROXY;break;}
+				if( test_bit( BIT_SLOT_FREE, &sproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_PROXY, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOTCONN;break;}  
+			} while(0);
+			RUNLOCK_PROC(sproxy_ptr);
+		}
+
+		if(ret == OK) {
+			while( bytes > 0) {
+				copylen = (bytes > drvs.d_max_copybuf)?drvs.d_max_copybuf:bytes;
+			
+				/* Header of the command */
+				caller_ptr->p_rmtcmd.c_cmd   = CMD_COPYOUT_RQST;
+				caller_ptr->p_rmtcmd.c_vmid  = vmid;
+				caller_ptr->p_rmtcmd.c_src   = caller_ptr->p_usr.p_endpoint;	
+				caller_ptr->p_rmtcmd.c_dst   = src_ptr->p_usr.p_endpoint;	
+				caller_ptr->p_rmtcmd.c_snode = atomic_read(&local_nodeid); 
+				caller_ptr->p_rmtcmd.c_dnode = src_ptr->p_usr.p_nodeid;		
+				caller_ptr->p_rmtcmd.c_rcode = OK;
+				caller_ptr->p_rmtcmd.c_len   = 0;
+
+				/* subheader for the vcopy operation */
+				caller_ptr->p_rmtcmd.c_vcopy.v_src =  src_ptr->p_usr.p_endpoint;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_dst =  dst_ptr->p_usr.p_endpoint;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_rqtr=  caller_ptr->p_usr.p_endpoint;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_saddr = src_addr;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_daddr = dst_addr;	
+				caller_ptr->p_rmtcmd.c_vcopy.v_bytes = copylen;
+
+				set_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+
+				cmd_ptr = &caller_ptr->p_rmtcmd;
+				MOLDEBUG(DBGCMD,"CMD_COPYOUT_RQST " CMD_FORMAT, CMD_FIELDS(cmd_ptr));
+				MOLDEBUG(DBGVCOPY,"CMD_COPYOUT_RQST " VCOPY_FORMAT, VCOPY_FIELDS(cmd_ptr));
+
+				ret =  sproxy_enqueue(caller_ptr);	
+				if(ret) break;
+
+				if(dst_ptr != caller_ptr)
+					ret = sleep_proc3(caller_ptr, src_ptr, dst_ptr,TIMEOUT_FOREVER);
+				else
+					ret = sleep_proc2(caller_ptr, src_ptr,TIMEOUT_FOREVER);
+				
+				if(ret) break;
+				bytes -=copylen;
+				src_addr += copylen;
+				dst_addr += copylen;
+			}				
+		}
+	} else {						/* source=REMOTE and destination=REMOTE	*/
+		MOLDEBUG(GENERIC,"source=REMOTE and destination=REMOTE\n");
+		/* get source nodeid */
+		if( ret == OK) {
+			snodeid = src_ptr->p_usr.p_nodeid;
+		MOLDEBUG(GENERIC,"snodeid=%d\n", snodeid);
+			if( snodeid < 0 || snodeid >= drvs.d_nr_nodes) 	 {							
+				ret = EMOLBADNODEID;
+			} else {
+				sproxy_ptr = get_sproxy(snodeid); 
+				RLOCK_PROC(sproxy_ptr);
+				do {
+					ret = OK;
+					if( ! test_bit(snodeid, &vm_ptr->vm_usr.vm_nodes)) 	{ret = EMOLNOVMNODE ;break;}
+					if( sproxy_ptr->p_usr.p_lpid == PROC_NO_PID)		{ret = EMOLNOPROXY ;break;}
+//					if( snptr->n_usr.n_flags == NODE_FREE) 			{ret = EMOLNOPROXY;break;}
+					if( test_bit( BIT_SLOT_FREE, &sproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLNOPROXY;break;} 
+					if( !test_bit(MIS_BIT_PROXY, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+					if( !test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOTCONN;break;}  
+				} while(0);
+				RUNLOCK_PROC(sproxy_ptr);
+			}
+		}
+
+		if( ret == OK) {
+			/* get destination nodeid */
+			dnodeid = dst_ptr->p_usr.p_nodeid;
+			MOLDEBUG(GENERIC,"dnodeid=%d\n", dnodeid);
+			if( dnodeid < 0 || dnodeid >= drvs.d_nr_nodes) 	 {							
+				ret = EMOLBADNODEID;
+			} else {
+				sproxy_ptr = get_sproxy(dnodeid); 
+				RLOCK_PROC(sproxy_ptr);
+				do {
+					ret = OK;
+					if( ! test_bit(dnodeid, &vm_ptr->vm_usr.vm_nodes)) 		{ret = EMOLNOVMNODE ;break;}
+					if( sproxy_ptr->p_usr.p_lpid == PROC_NO_PID)			{ret = EMOLNOPROXY ;break;}
+//					if( dnptr->n_usr.n_flags == NODE_FREE) 				{ret = EMOLNOPROXY;break;}
+					if( test_bit( BIT_SLOT_FREE, &sproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLNOPROXY;break;} 
+					if( !test_bit(MIS_BIT_PROXY, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+					if( !test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOTCONN;break;}  
+				} while(0);
+				RUNLOCK_PROC(sproxy_ptr);
+			}
+		}
+		
+		if(ret == OK) {		
+			while( bytes > 0) {
+				copylen = (bytes > drvs.d_max_copybuf)?drvs.d_max_copybuf:bytes;
+				if(src_ptr->p_usr.p_nodeid == dst_ptr->p_usr.p_nodeid) {	/* A remote copy on the same REMOTE node 	*/ 
+					MOLDEBUG(INTERNAL,"CMD_COPYLCL_RQST copylen=%d\n", copylen);
+					caller_ptr->p_rmtcmd.c_cmd   = CMD_COPYLCL_RQST;
+					caller_ptr->p_rmtcmd.c_vmid  = vmid;
+					caller_ptr->p_rmtcmd.c_src   = caller_ptr->p_usr.p_endpoint;	
+					caller_ptr->p_rmtcmd.c_dst   = dst_ptr->p_usr.p_endpoint;	/* Destination endpoint 	*/
+					caller_ptr->p_rmtcmd.c_snode = atomic_read(&local_nodeid); 
+					caller_ptr->p_rmtcmd.c_dnode = dst_ptr->p_usr.p_nodeid;		/* destination node		*/
+					caller_ptr->p_rmtcmd.c_rcode = OK;
+					caller_ptr->p_rmtcmd.c_len   = 0;
+				} else {													/* A remote copy on different nodes */ 
+					MOLDEBUG(INTERNAL,"CMD_COPYRMT_RQST copylen=%d\n", copylen);
+					caller_ptr->p_rmtcmd.c_cmd   = CMD_COPYRMT_RQST;
+					caller_ptr->p_rmtcmd.c_vmid  = vmid;
+					caller_ptr->p_rmtcmd.c_src   = caller_ptr->p_usr.p_endpoint;	
+					caller_ptr->p_rmtcmd.c_dst   = src_ptr->p_usr.p_endpoint;	/* Source endpoint 	*/
+					caller_ptr->p_rmtcmd.c_snode = atomic_read(&local_nodeid); 
+					caller_ptr->p_rmtcmd.c_dnode = src_ptr->p_usr.p_nodeid;		/* source   node		*/
+					caller_ptr->p_rmtcmd.c_rcode = OK;
+					caller_ptr->p_rmtcmd.c_len   = 0;
+				}
+				set_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+				/* subheader for the vcopy operation */
+				caller_ptr->p_rmtcmd.c_vcopy.v_src =  src_ptr->p_usr.p_endpoint;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_dst =  dst_ptr->p_usr.p_endpoint;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_rqtr=  caller_ptr->p_usr.p_endpoint;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_saddr = src_addr;		
+				caller_ptr->p_rmtcmd.c_vcopy.v_daddr = dst_addr;	
+				caller_ptr->p_rmtcmd.c_vcopy.v_bytes = copylen;	
+
+				ret = sproxy_enqueue(caller_ptr);
+				if(ret) break;
+				ret = sleep_proc3(caller_ptr, src_ptr, dst_ptr,TIMEOUT_FOREVER);
+				if(ret) break;
+				bytes -=copylen;
+				src_addr += copylen;
+				dst_addr += copylen;
+			}				
+		}
+	}
+
+/*
+* PROBLEMAS A RESOLVER: La copia de bloques de datos que involucra a nodos remotos debe cumplir con dos condiciones:
+* 	Sincronizacion: si hay una copia remota pendiente se debe estar 
+*   			seguro de que la misma finalizo para continuar con otra operacion
+*	Paralelismo: Si el requester es un TERCERO (por ejemplo la SYSTASK) que 	
+*			tiene q esperar que finalicen las operaciones de COPY pendientes, 
+*			todas aquellas operaciones locales se verian retrasadas.  
+* 	Solucin: Crear un KERNEL Thread encargado de realizar las copias remotas y de responderle al requester cuando 
+*			la copia finaliz. 
+* 			
+*/
+	if( ret == OK)
+		ret = caller_ptr->p_rcode;
+	else {
+		clear_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+		caller_ptr->p_usr.p_proxy = PROC_NO_PID;
+		caller_ptr->p_rcode = ret;
+	}
+
+	/* May be that during the copy, the SOURCE and DESTIONATION (!= REQUESTER) that were 
+	 * sleeping by other reason (RECEIVING) received or sent a message, but 
+	 * because the p_rts_flags &ONCOPY they were not waked up by send(), receive(), sendrec() or notify().
+	 * Now, the COPY has finished, then they must be waked up.
+	 */
+
+	clear_bit(BIT_ONCOPY, &src_ptr->p_usr.p_rts_flags);
+	clear_bit(BIT_ONCOPY, &dst_ptr->p_usr.p_rts_flags);
+	clear_bit(BIT_ONCOPY, &caller_ptr->p_usr.p_rts_flags);
+
+	if( src_ptr != caller_ptr && dst_ptr != caller_ptr ) {
+		if(src_ptr->p_usr.p_rts_flags == 0)
+			LOCAL_PROC_UP(src_ptr, ret);
+		if(dst_ptr->p_usr.p_rts_flags == 0)
+			LOCAL_PROC_UP(dst_ptr, ret);
+		WUNLOCK_PROC3(caller_ptr,src_ptr,dst_ptr);	
+	}else if( dst_ptr != caller_ptr) {
+		if(dst_ptr->p_usr.p_rts_flags == 0)
+			LOCAL_PROC_UP(dst_ptr, ret);
+		WUNLOCK_PROC2(caller_ptr,dst_ptr);
+	}else{ /* src_ptr != caller_ptr */
+		if(src_ptr->p_usr.p_rts_flags == 0)
+			LOCAL_PROC_UP(src_ptr, ret);
+		WUNLOCK_PROC2(caller_ptr,src_ptr);
+	}
+
+	if(ret) ERROR_RETURN(ret);
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_mini_rcvrqst			*/
+/* Receives a message from another MOL process of the same VM	*/
+/* Differences with RECEIVE:					*/
+/* 	The requester process must do sendrec => p_rts_flags =	*/
+/*					(SENDING | RECEIVING)	*/
+/*	The request can be ANY process 				*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_mini_rcvrqst(message* m_ptr, long timeout_ms)
+{
+	struct proc *caller_ptr, *xpp, *tmp_ptr;
+	VM_desc_t *vm_ptr;
+	int s_id, sys_nr, sys_ep = NONE;
+	int i, ret;
+	sys_map_t *map;
+  	bitchunk_t *chunk;
+	int caller_nr, caller_pid, caller_ep;
+	int vmid;
+	struct task_struct *task_ptr;	
+
+	if( DRVS_NOT_INIT() ) 				ERROR_RETURN(EMOLDRVSINIT);
+
+	MOLDEBUG(DBGPARAMS,"timeout=%ld\n",timeout_ms);
+
+	ret = check_lock_caller(&task_ptr, &caller_ptr, &caller_pid);
+	if(ret) ERROR_RETURN(ret);
+
+	caller_nr   = caller_ptr->p_usr.p_nr;
+	caller_ep   = caller_ptr->p_usr.p_endpoint;
+	MOLDEBUG(DBGPARAMS,"caller_nr=%d caller_ep=%d \n", caller_nr, caller_ep);
+	caller_ptr->p_umsg 		= m_ptr;
+
+	/*------------------------------------------
+	 * Checks the caller process 
+ 	 * Gets the VMID
+	 * Checks if the VM is RUNNING
+	 * Locks the VM
+      *------------------------------------------*/
+	ret = OK;
+	do {
+		if (caller_pid != caller_ptr->p_usr.p_lpid) 	{ret = EMOLBADPID; break;}
+		vmid		= caller_ptr->p_usr.p_vmid;
+		MOLDEBUG(INTERNAL,"vmid=%d\n", vmid);
+		if( vmid < 0 || vmid >= drvs.d_nr_vms) 		{ret =EMOLBADVMID; break;}
+		vm_ptr 	= &vm[vmid];
+		RLOCK_VM(vm_ptr);
+		if( vm_ptr->vm_usr.vm_flags)  ret = EMOLVMNOTRUN;
+		RUNLOCK_VM(vm_ptr);
+	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}	
+	
+	if (caller_ptr->p_usr.p_rts_flags ) {
+		WUNLOCK_PROC(caller_ptr);							
+		ERROR_RETURN(EMOLNOTREADY);
+	}
+
+	/*--------------------------------------*/
+	/* NOTIFY PENDING LOOP			*/
+	/*--------------------------------------*/
+
+    	map = &caller_ptr->p_priv.s_notify_pending;
+    	for (chunk=&map->chunk[0]; chunk<&map->chunk[NR_SYS_CHUNKS]; chunk++) {
+    		if (! *chunk) continue; 			/* no bits in chunk */
+    		for (i=0; ! (*chunk & (1<<i)); ++i) {} 	/* look up the bit */
+    		s_id = (chunk - &map->chunk[0]) * BITCHUNK_BITS + i;
+    		if (s_id >= vm_ptr->vm_usr.vm_nr_sysprocs) break;		/* out of range */
+//PENDIENTE	if( vm_ptr->vm_sid2proc[s_id] == NULL) break;
+//PENDIENTE	sys_ptr = vm_ptr->vm_sid2proc[s_id];
+//PENDIENTE	sys_ep = sys_ptr->p_usr.p_endpoint;	/* get source endpoint */
+//PENDIENTE	if (src_ep != ANY && src_ep != sys_ep) continue;/* source not ok */
+		sys_nr = (s_id-vm_ptr->vm_usr.vm_nr_tasks);	/* get source endpoint */
+		MOLDEBUG(INTERNAL,"s_id=%d sys_nr=%d\n", s_id, sys_nr);
+		*chunk &= ~(1 << i);			/* no longer pending */
+		MOLDEBUG(INTERNAL,"deliver the notification message s_id=%d sys_ep=%d\n", s_id, sys_ep);
+	   	/* Found a suitable source, deliver the notification message. */
+		BUILD_NOTIFY_MSG( vm_ptr, caller_ptr, sys_ep);
+		COPY_TO_USER_PROC(ret, (void *)&caller_ptr->p_message, (void *)m_ptr, sizeof(message));
+		WUNLOCK_PROC(caller_ptr);
+		if (ret != 0) ERROR_RETURN(EMOLMSGSIZE);
+		return(OK);	/* report success */
+	}
+
+	/*-----------------------------------------*/
+	/* MESSAGE RECEIVE 		*/
+	/*-----------------------------------------*/
+
+	list_for_each_entry_safe(xpp, tmp_ptr, &caller_ptr->p_list, p_link) {
+		MOLDEBUG(GENERIC,"Found acceptable message from %d. Copy it and update status.\n",xpp->p_usr.p_endpoint );
+			/* Here is a message from xpp process, therefore xpp  must be sleeping in SENDING state */
+
+		WLOCK_ORDERED2(caller_ptr,xpp);
+		list_del(&xpp->p_link); /* remove from queue */
+
+		/* test the sender status */
+		do	{
+			if( test_bit(BIT_SLOT_FREE, &xpp->p_usr.p_rts_flags))		{ret = EMOLSRCDIED; break;} 	
+			if( !test_bit(BIT_SENDING, &xpp->p_usr.p_rts_flags))     	{ret = EMOLPROCSTS; break;} 
+			if( !test_bit(BIT_RECEIVING, &xpp->p_usr.p_rts_flags))     	{ret = EMOLPROCSTS; break;} 
+			if( xpp->p_usr.p_sendto != caller_ptr->p_usr.p_endpoint) 		{ret = EMOLPROCSTS; break;} 
+			if( xpp->p_usr.p_getfrom != caller_ptr->p_usr.p_endpoint) 		{ret = EMOLPROCSTS; break;} 
+			ret = OK;
+		} while(0);
+		
+		if(ret == OK) {			
+			if( IT_IS_REMOTE(xpp) ){ 
+				COPY_TO_USER_PROC(ret, (void *)&xpp->p_message, (void *) m_ptr, sizeof(message));
+		 		if( !test_bit(BIT_RECEIVING, &xpp->p_usr.p_rts_flags)) {
+					send_ack_lcl2rmt(xpp, caller_ptr, ret);
+				}
+			}else {
+				COPY_USR2USR_PROC(ret, xpp->p_usr.p_endpoint, xpp, (char *)xpp->p_umsg,
+					caller_ptr, (char *) m_ptr, sizeof(message) );
+			} 
+			clear_bit(BIT_SENDING, &xpp->p_usr.p_rts_flags);
+			xpp->p_usr.p_sendto 	= NONE;
+			if(xpp->p_usr.p_rts_flags == 0) 
+				LOCAL_PROC_UP(xpp, ret);
+		}
+				
+		WUNLOCK_PROC(xpp);
+		WUNLOCK_PROC(caller_ptr);
+		if( ret) ERROR_RETURN(ret);
+		return(OK);
+	}
+		
+	set_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+	clear_bit(MIS_BIT_NOTIFY, &caller_ptr->p_usr.p_misc_flags);
+	caller_ptr->p_usr.p_getfrom 	= ANY;
+	caller_ptr->p_rcode	= OK;
+	MOLDEBUG(GENERIC,"Any suitable message was not found.\n");	
+
+	sleep_proc(caller_ptr, timeout_ms);
+
+	ret = caller_ptr->p_rcode;
+	if( ret != OK){
+		clear_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+		caller_ptr->p_usr.p_getfrom 	= NONE;
+	}else {
+		if(test_bit(MIS_BIT_NOTIFY,&caller_ptr->p_usr.p_misc_flags)){
+			COPY_TO_USER_PROC(ret, &caller_ptr->p_message, caller_ptr->p_umsg, sizeof(message) );
+		}
+	}
+	clear_bit(MIS_BIT_NOTIFY, &caller_ptr->p_usr.p_misc_flags);
+
+	WUNLOCK_PROC(caller_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(OK);
+}	
+
+/*--------------------------------------------------------------*/
+/*			mol_mini_reply					    */
+/*--------------------------------------------------------------*/
+asmlinkage long mol_mini_reply(int dst_ep, message* m_ptr, long timeout_ms)
+{
+	struct proc *dst_ptr, *caller_ptr, *sproxy_ptr;
+	VM_desc_t *vm_ptr;
+	int ret, retry;
+	int caller_nr, caller_pid,caller_ep;
+	int dst_nr, vmid, nodeid;
+	struct task_struct *task_ptr;
+
+	if( DRVS_NOT_INIT() ) 				ERROR_RETURN(EMOLDRVSINIT);
+
+	MOLDEBUG(DBGPARAMS,"dst_ep=%d\n",dst_ep);
+
+	ret = check_lock_caller(&task_ptr, &caller_ptr, &caller_pid);
+	if(ret) ERROR_RETURN(ret);
+
+	caller_nr   = caller_ptr->p_usr.p_nr;
+	caller_ep   = caller_ptr->p_usr.p_endpoint;
+	MOLDEBUG(DBGPARAMS,"caller_nr=%d caller_ep=%d caller_pid=%d \n", 
+	caller_nr, caller_ep,caller_pid);
+	caller_ptr->p_umsg		= m_ptr;
+
+	/*------------------------------------------
+	 * Checks the caller process PID
+ 	 * Gets the VMID
+	 * Checks if the VM is RUNNING
+	 * Locks the VM
+      *------------------------------------------*/
+	ret = OK;
+	do {
+		MOLDEBUG(INTERNAL,"caller_ptr->p_usr.p_lpid=%d\n", caller_ptr->p_usr.p_lpid);
+		if (caller_pid != caller_ptr->p_usr.p_lpid) 	{ret = EMOLBADPID; break;}
+		vmid		= caller_ptr->p_usr.p_vmid;
+		MOLDEBUG(INTERNAL,"vmid=%d\n", vmid);
+		if( vmid < 0 || vmid >= drvs.d_nr_vms) 		{ret =EMOLBADVMID; break;}
+		vm_ptr 	= &vm[vmid];
+		RLOCK_VM(vm_ptr);
+		if( vm_ptr->vm_usr.vm_flags)  ret = EMOLVMNOTRUN;
+		RUNLOCK_VM(vm_ptr);
+	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}
+	
+reply_replay:
+	ret = OK;
+
+	/*------------------------------------------
+	 * get the destination process number
+	*------------------------------------------*/
+	do {
+		dst_nr = _ENDPOINT_P(dst_ep);
+		if( dst_nr < (-vm_ptr->vm_usr.vm_nr_tasks)		
+		 || dst_nr >= vm_ptr->vm_usr.vm_nr_procs)	{ret = EMOLRANGE; break;}
+		dst_ptr   = NBR2PTR(vm_ptr, dst_nr);
+		if( dst_ptr == NULL) 				{ret = EMOLDSTDIED; break;}
+		if( caller_ep == dst_ep) 			{ret = EMOLENDPOINT; break;}
+	}while(0);
+	if(ret) {
+		WUNLOCK_PROC(caller_ptr);
+		ERROR_RETURN(ret);
+	}
+
+	WLOCK_ORDERED2(caller_ptr,dst_ptr);
+	MOLDEBUG(DBGPARAMS,"dst_nr=%d dst_ep=%d\n",dst_nr, dst_ptr->p_usr.p_endpoint);
+
+	do	{
+		ret = OK;
+		retry = 0;
+		if (caller_ptr->p_usr.p_rts_flags ) 		{ret = EMOLNOTREADY; break;} 	/* Caller is NOT READY! 	*/
+		if (dst_ptr->p_usr.p_endpoint != dst_ep) 	{ret = EMOLENDPOINT; break;} 	/* Paranoid checking		*/
+		if( test_bit(BIT_SLOT_FREE, &dst_ptr->p_usr.p_rts_flags))	{ret = EMOLDSTDIED; break;} 	/*destination died		*/
+		if(!test_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags))	{ret = EMOLPROCSTS; break;} 	/* Bad destination status	*/ 
+		if( dst_ptr->p_usr.p_getfrom != caller_ep) 			{ret = EMOLPROCSTS; break;} 	/* Bad destination status	*/
+		if( test_bit(BIT_MIGRATE, &dst_ptr->p_usr.p_rts_flags))	{
+			set_bit(BIT_WAITMIGR, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_waitmigr = dst_ep;
+			INIT_LIST_HEAD(&caller_ptr->p_mlink);
+			list_add_tail(&caller_ptr->p_mlink, &dst_ptr->p_mlist);
+			sleep_proc2(caller_ptr, dst_ptr, timeout_ms);
+			ret = caller_ptr->p_rcode;
+			retry = 1;
+		} 	
+	} while(retry);
+	if(ret) {							
+		WUNLOCK_PROC2(caller_ptr, dst_ptr);
+		ERROR_RETURN(ret);
+	}
+	
+	MOLDEBUG(DBGPARAMS,"vmid=%d caller_pid=%d caller_nr=%d dst_ep=%d \n",vmid, caller_pid,caller_nr, dst_ep);
+	caller_ptr->p_rcode= OK;
+	if( IT_IS_REMOTE(dst_ptr)) {		/* the destination is REMOTE */
+		/*---------------------------------------------------------------------------------------------------*/
+		/*						REMOTE 								 */
+		/*---------------------------------------------------------------------------------------------------*/
+
+		/* get destination nodeid */
+		nodeid = dst_ptr->p_usr.p_nodeid;
+		if( nodeid < 0 || nodeid >= drvs.d_nr_nodes) 	 {							
+			ret = EMOLBADNODEID;
+		} else {
+			sproxy_ptr = get_sproxy(nodeid); 
+			RLOCK_PROC(sproxy_ptr);
+			do {
+				ret = OK;
+				if( ! test_bit(nodeid, &vm_ptr->vm_usr.vm_nodes)) 	{ret = EMOLNOVMNODE ;break;}
+				if( sproxy_ptr->p_usr.p_lpid == PROC_NO_PID)		{ret = EMOLNOPROXY ;break;}
+//				if( nptr->n_usr.n_flags == NODE_FREE) 			{ret = EMOLNOPROXY;break;}
+				if( test_bit( BIT_SLOT_FREE, &sproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_PROXY, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOTCONN;break;}  
+			} while(0);
+			RUNLOCK_PROC(sproxy_ptr);
+		}
+ 
+		if(ret) {							
+			WUNLOCK_PROC2(caller_ptr, dst_ptr);
+			ERROR_RETURN(ret);
+		}
+
+		clear_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags);
+		if(dst_ptr->p_usr.p_getfrom == caller_ptr->p_usr.p_endpoint){
+					dst_ptr->p_usr.p_getfrom = NONE;
+		}
+		WUNLOCK_PROC(dst_ptr);
+
+		/* fill the caller's rmtcmd fields */
+		caller_ptr->p_rmtcmd.c_cmd 	= CMD_REPLY_MSG;
+		caller_ptr->p_rmtcmd.c_src 	= caller_ep;
+		caller_ptr->p_rmtcmd.c_dst 	= dst_ep;
+		caller_ptr->p_rmtcmd.c_vmid	= vmid;
+		caller_ptr->p_rmtcmd.c_snode  	= atomic_read(&local_nodeid);
+		caller_ptr->p_rmtcmd.c_dnode  	= nodeid;
+		caller_ptr->p_rmtcmd.c_rcode  	= OK;
+		caller_ptr->p_rmtcmd.c_len  	= sizeof(message);
+
+		caller_ptr->p_message.m_source = caller_ptr->p_usr.p_endpoint;
+		INIT_LIST_HEAD(&caller_ptr->p_link);
+
+		set_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+		caller_ptr->p_usr.p_sendto = dst_ep;
+		set_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+
+		ret = sproxy_enqueue(caller_ptr);
+		
+		/* wait for the SENDACK */
+		sleep_proc(caller_ptr, timeout_ms);
+		ret = caller_ptr->p_rcode;
+		if( ret == OK){
+			caller_ptr->p_usr.p_rmtsent++;
+
+		}else{
+			if( test_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags)) {
+			MOLDEBUG(GENERIC,"removing %d link from sender's proxy list.\n", caller_ptr->p_usr.p_endpoint);
+				list_del(&caller_ptr->p_link); /* remove from queue ATENCION: HAY Q PROTEGER PROXY ?? */
+			}
+			clear_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_sendto = NONE;
+			clear_bit(BIT_RMTOPER, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_proxy = PROC_NO_PID;
+			if( ret == EMOLMIGRATE) {
+				WUNLOCK_PROC(dst_ptr);
+				goto reply_replay;
+			}
+		}
+		WUNLOCK_PROC(caller_ptr);
+
+	} else {						/* the destination is LOCAL */
+		/*---------------------------------------------------------------------------------------------------*/
+		/*						LOCAL 								 */
+		/*---------------------------------------------------------------------------------------------------*/
+
+		COPY_USR2USR_PROC(ret, caller_ep, caller_ptr, (char *) m_ptr, dst_ptr,  (char *) dst_ptr->p_umsg, sizeof(message) );
+		if(ret) {
+			WUNLOCK_PROC2(caller_ptr, dst_ptr);
+			ERROR_RETURN(ret);
+		}
+		clear_bit(BIT_RECEIVING,&dst_ptr->p_usr.p_rts_flags);
+		dst_ptr->p_usr.p_getfrom 	= NONE;
+		if(dst_ptr->p_usr.p_rts_flags == 0) 
+			LOCAL_PROC_UP(dst_ptr, ret);
+		caller_ptr->p_usr.p_lclsent++;
+	}
+	WUNLOCK_PROC2(caller_ptr, dst_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(ret);
+}
+
+#ifdef ANULADO
+
+/*--------------------------------------------------------------*/
+/*			kernel_sendrec				*/
+/* PROBLEMA: No est terminado!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
+/* EL MENSAJE NO ESTA EN MEMORIA DE USUARIO !!!                 */
+/*TASK must be LOCKED 						*/
+/*VM must be UNLOCKED						*/
+/*PROC 	must be UNLOCKED					*/
+/*--------------------------------------------------------------*/
+long kernel_sendrec(int srcdst_ep, message* m_ptr)
+{
+	struct proc *srcdst_ptr, *caller_ptr, *sproxy_ptr;
+	VM_desc_t *vm_ptr;
+	int ret;
+	int caller_nr, caller_pid, caller_tgid, caller_ep;
+	int srcdst_nr;
+	int vmid, nodeid;
+	struct task_struct *task_ptr;	
+	cluster_node_t *n_ptr;
+
+
+MOLDEBUG(DBGLVL1,"srcdst_ep=%d\n", srcdst_ep);
+	if( DRVS_NOT_INIT() ) 				ERROR_RETURN(EMOLDRVSINIT);
+
+	caller_pid  = current->pid;
+	caller_tgid = current->tgid;
+MOLDEBUG(DBGLVL1,"caller_pid=%d caller_tgid=%d\n", caller_pid, caller_tgid);
+
+	caller_ptr = (struct proc *) current->proc_ptr;
+	if(caller_ptr == NULL)				ERROR_RETURN(EMOLNOTBIND);
+	caller_nr   = caller_ptr->p_usr.p_nr;
+	caller_ep   = caller_ptr->p_usr.p_endpoint;
+MOLDEBUG(DBGLVL1,"caller_nr=%d caller_ep=%d \n", caller_nr, caller_ep);
+	caller_ptr->p_umsg 		= m_ptr;
+
+	/*------------------------------------------
+	 * Checks the caller process 
+ 	 * Gets the VMID
+	 * Checks if the VM is RUNNING
+	 * Locks the VM
+      *------------------------------------------*/
+	if (caller_pid != caller_ptr->p_usr.p_lpid) 	ERROR_RETURN(EMOLBADPID);
+	vmid		= caller_ptr->p_usr.p_vmid;
+MOLDEBUG(DBGLVL1,"vmid=%d\n", vmid);
+	if( vmid < 0 || vmid >= drvs.d_nr_vms)			ERROR_RETURN(EMOLBADVMID);
+	vm_ptr 	= &vm[vmid];
+	if( vm_ptr->vm_usr.vm_flags) 			ERROR_RETURN(EMOLVMNOTRUN);
+
+	/* gets the destination process number */ 
+	srcdst_nr = _ENDPOINT_P(srcdst_ep);
+	CHECK_P_NR(task_ptr, vm_ptr, srcdst_nr);			/* check process number limits */
+	srcdst_ptr  = NBR2PTR(vm_ptr, srcdst_nr);
+	if( srcdst_ptr  == NULL) 			ERROR_RETURN(EMOLDSTDIED);
+	
+	if(caller_ep == srcdst_ep) 			ERROR_RETURN(EMOLENDPOINT)	
+
+	WLOCK_PROC2(caller_ptr,srcdst_ptr);
+MOLDEBUG(DBGLVL1,"srcdst_nr=%d srcdst_ep=%d\n",srcdst_nr, srcdst_ptr->p_usr.p_endpoint);
+
+	do	{
+		if (caller_ptr->p_usr.p_rts_flags ) 				{ret = EMOLNOTREADY; break;} 	/* Caller is NOT READY! 	*/
+		if (srcdst_ptr->p_usr.p_endpoint != srcdst_ep) 			{ret = EMOLENDPOINT; break;} 	/* Paranoid checking	*/
+		if (test_bit(BIT_SLOT_FREE, &srcdst_ptr->p_usr.p_rts_flags))	{ret = EMOLDSTDIED; break;} 	/*destination died		*/
+		ret = OK;
+	} while(0);
+	
+	if(ret) {							
+		WUNLOCK_PROC2(caller_ptr, srcdst_ptr);
+		ERROR_RETURN(ret);
+	}
+
+MOLDEBUG(DBGLVL1,"vmid=%d caller_pid=%d caller_nr=%d srcdst_ep=%d \n",vmid, caller_pid,caller_nr, srcdst_ep);
+
+	/*--------------------------------------*/
+	/* SENDING/RECEIVING		*/
+	/*--------------------------------------*/
+MOLDEBUG(DBGLVL1,"SENDING HALF\n");
+
+	caller_ptr->p_rcode	= OK;
+	caller_ptr->p_usr.p_getfrom  = srcdst_ep;
+
+	if( IT_IS_REMOTE(srcdst_ptr)) {		/* the destination is REMOTE */
+		/*---------------------------------------------------------------------------------------------------*/
+		/*						REMOTE 								 */
+		/*---------------------------------------------------------------------------------------------------*/
+
+		/* get destination nodeid */
+		nodeid = srcdst_ptr->p_usr.p_nodeid;
+		if( nodeid < 0 || nodeid >= drvs.d_nr_nodes) 	 {							
+			ret = EMOLBADNODEID;
+		} else {
+			sproxy_ptr = get_sproxy(nodeid); 
+			RLOCK_PROC(sproxy_ptr);
+			do {
+				ret = OK;
+				if( ! test_bit(nodeid, &vm_ptr->vm_usr.vm_nodes)) 	{ret = EMOLNOVMNODE ;break;}
+				if( sproxy_ptr->p_usr.p_lpid == PROC_NO_PID)		{ret = EMOLNOPROXY ;break;}
+				if( nptr->n_usr.n_flags == NODE_FREE) 			{ret = EMOLNOPROXY;break;}
+				if( test_bit( BIT_SLOT_FREE, &sproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_PROXY, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+				if( !test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOTCONN;break;}  
+			} while(0);
+			RUNLOCK_PROC(sproxy_ptr);
+		}
+ 
+		if(ret) {							
+			WUNLOCK_PROC2(caller_ptr, srcdst_ptr);
+			ERROR_RETURN(ret);
+		}
+
+		WUNLOCK_PROC(srcdst_ptr);
+
+		/* fill the caller's rmtcmd fields */
+		caller_ptr->p_rmtcmd.c_cmd 	= CMD_SNDREC_MSG;
+		caller_ptr->p_rmtcmd.c_src 	= caller_ep;
+		caller_ptr->p_rmtcmd.c_dst 	= srcdst_ep;
+		caller_ptr->p_rmtcmd.c_vmid	= vmid;
+		caller_ptr->p_rmtcmd.c_snode  	= atomic_read(&local_nodeid);
+		caller_ptr->p_rmtcmd.c_dnode  	= nodeid;
+		caller_ptr->p_rmtcmd.c_rcode  	= OK;
+		caller_ptr->p_rmtcmd.c_len  	= sizeof(message);
+
+		caller_ptr->p_umsg		= m_ptr;
+
+		INIT_LIST_HEAD(&caller_ptr->p_link);
+		set_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+		set_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+		caller_ptr->p_usr.p_sendto  = srcdst_ep;
+		caller_ptr->p_usr.p_getfrom = srcdst_ep;
+		
+		WLOCK_PROC(sproxy_ptr);
+		list_add_tail(&caller_ptr->p_link, &sproxy_ptr->p_list);
+		
+		if ( test_bit(BIT_RECEIVING, &sproxy_ptr->p_usr.p_rts_flags) ) { /* the sender proxy is waiting a message */
+			MOLDEBUG(DBGLVL1,"The SENDER proxy is waiting a message \n");
+			clear_bit(BIT_RECEIVING,&sproxy_ptr->p_usr.p_rts_flags);
+			if(sproxy_ptr->p_usr.p_rts_flags == 0) 
+				LOCAL_PROC_UP(sproxy_ptr, ret);
+		} else {
+			MOLDEBUG(DBGLVL1,"The SENDER proxy is NOT waiting a message \n");
+		}
+		WUNLOCK_PROC(sproxy_ptr); 
+
+		/* wait for the REPLY */
+		sleep_proc(caller_ptr, TIMEOUT_FOREVER);
+		ret = caller_ptr->p_rcode;
+		if( ret == OK){
+			caller_ptr->p_usr.p_rmtsent++;
+		}else{
+			if( test_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags)) {
+				MOLDEBUG(DBGLVL1,"removing %d link from sender's proxy list.\n", caller_ptr->p_usr.p_endpoint);
+				list_del(&caller_ptr->p_link); /* remove from queue ATENCION: HAY Q PROTEGER PROXY ?? */
+				}
+			clear_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
+			clear_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_sendto  = NONE;
+			caller_ptr->p_usr.p_getfrom = NONE;
+			}
+		WUNLOCK_PROC(caller_ptr);
+	} else {
+		/*---------------------------------------------------------------------------------------------------*/
+		/*						LOCAL  								 */
+		/*---------------------------------------------------------------------------------------------------*/
+		/* Check if 'dst' is blocked waiting for this message.   */
+		if (  (test_bit(BIT_RECEIVING, &srcdst_ptr->p_usr.p_rts_flags) && !test_bit(BIT_SENDING, &srcdst_ptr->p_usr.p_rts_flags)) &&
+			(srcdst_ptr->p_usr.p_getfrom == ANY || srcdst_ptr->p_usr.p_getfrom == caller_ep)) {
+			MOLDEBUG(DBGLVL1,"destination is waiting. Copy the message and wakeup destination\n");
+			clear_bit(BIT_RECEIVING, &srcdst_ptr->p_usr.p_rts_flags);
+			srcdst_ptr->p_usr.p_getfrom 	= NONE;
+
+			m_ptr->m_source  = caller_ptr->p_usr.p_endpoint;
+			COPY_TO_USER_PROC(ret, (void *) m_ptr,(void *) &srcdst_ptr->p_umsg, sizeof(message));
+//			memcpy((void *)&srcdst_ptr->p_message, (void *) m_ptr, sizeof(message));
+//			srcdst_ptr->p_message.m_source = caller_ptr->p_usr.p_endpoint;
+		
+			LOCAL_PROC_UP(srcdst_ptr, OK); 
+			set_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags); /* Sending part: completed, now receiving.. */
+			WUNLOCK_PROC(srcdst_ptr);
+			sleep_proc(caller_ptr, TIMEOUT_FOREVER); 
+			ret = caller_ptr->p_rcode;
+			if( ret) {
+				clear_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+				clear_bit(BIT_SENDING,   &caller_ptr->p_usr.p_rts_flags);
+				caller_ptr->p_usr.p_getfrom    = NONE;
+				caller_ptr->p_usr.p_sendto 	= NONE;
+			} else {
+//				memcpy((void *) m_ptr, (void *)&caller_ptr->p_message, sizeof(message));
+				caller_ptr->p_usr.p_lclsent++;
+			}
+		} else { 
+			MOLDEBUG(DBGLVL1,"destination is not waiting srcdst_ptr->p_usr.p_rts_flags=%lX. Enqueue at the TAIL.\n",srcdst_ptr->p_usr.p_rts_flags);
+			/* The destination is not waiting for this message 			*/
+			/* Append the caller at the TAIL of the destination senders' queue	*/
+			/* blocked sending the message */
+			memcpy((void *)&caller_ptr->p_message, (void *) m_ptr, sizeof(message));
+			caller_ptr->p_message.m_source = caller_ptr->p_usr.p_endpoint;
+			set_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+			set_bit(BIT_SENDING,   &caller_ptr->p_usr.p_rts_flags);
+			caller_ptr->p_usr.p_sendto 	= srcdst_ep;	
+			INIT_LIST_HEAD(&caller_ptr->p_link);
+			list_add_tail(&caller_ptr->p_link, &srcdst_ptr->p_list);
+			WUNLOCK_PROC(srcdst_ptr);
+			sleep_proc(caller_ptr, TIMEOUT_FOREVER); 
+			ret = caller_ptr->p_rcode;
+			if( ret) {
+				if( test_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags)){
+					MOLDEBUG(DBGLVL1,"removing %d link from %d list.\n", caller_ptr->p_usr.p_endpoint, srcdst_ep);
+					list_del(&caller_ptr->p_link); /* remove from queue */
+				} else {
+					caller_ptr->p_usr.p_lclsent++;
+				}
+				clear_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
+				clear_bit(BIT_SENDING,   &caller_ptr->p_usr.p_rts_flags);
+				caller_ptr->p_usr.p_getfrom    = NONE;
+				caller_ptr->p_usr.p_sendto 	= NONE;
+			} else {
+//				memcpy( (void *) m_ptr, (void *)&caller_ptr->p_message, sizeof(message));
+				caller_ptr->p_usr.p_lclsent++;
+			}
+		}
+	}
+
+	WUNLOCK_PROC(caller_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(ret);
+}
+#endif /* ANULADO */
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/mol-macros.h /usr/src/linux/kernel/mol-macros.h
--- /home/jara/linux-2.6.32/kernel/mol-macros.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-macros.h	2014-06-15 09:50:39.000000000 -0300
@@ -0,0 +1,585 @@
+/****************************************************************/
+/*			MOL MACROS   			*/
+/****************************************************************/
+
+/*----------------------------------------------------------------*/
+/*				ERROR CHECKING MACROS 				*/
+/*----------------------------------------------------------------*/
+
+#define CHECK_VMID(vmid) 	if( vmid < 0 || vmid >= drvs.d_nr_vms) 	ERROR_RETURN(EMOLBADVMID);
+#define CHECK_NODEID(nodeid) 	if( nodeid < 0 || nodeid >= drvs.d_nr_nodes) 	ERROR_RETURN(EMOLBADNODEID);
+#define CHECK_PID(pid, p_ptr)	if (pid != p_ptr->p_usr.p_lpid) 		ERROR_RETURN(EMOLBADPID);
+
+#define CHECK_IF_VM_RUN(v_ptr) 	if( v_ptr->vm_usr.vm_flags) 			ERROR_RUNLOCK_VM(v_ptr,EMOLVMNOTRUN);
+
+#define VM_PROC(vm_ptr,i)	((struct proc *) (((char *) vm_ptr->vm_proc) + ( i << log2_proc_size)))
+#define IT_IS_REMOTE(proc)	test_bit(BIT_REMOTE, &proc->p_usr.p_rts_flags)
+#define IT_IS_LOCAL(proc)	!test_bit(BIT_REMOTE, &proc->p_usr.p_rts_flags)
+
+#define ENDPOINT2PTR(vm_ptr, ep) VM_PROC(vm_ptr,(_ENDPOINT_P(ep)+vm_ptr->vm_usr.vm_nr_tasks))
+#define NBR2PTR(vm_ptr, nr)	VM_PROC(vm_ptr,(nr+vm_ptr->vm_usr.vm_nr_tasks))
+#define DRVS_NOT_INIT()		(atomic_read(&local_nodeid) == DRVS_NO_INIT)
+
+#define VM_INCREF(v)		kref_get(&v->vm_kref); 
+#define VM_DECREF(v)		kref_put(&v->vm_kref, vm_release); 
+
+#define NODE2SPROXY(n) 	  &proxies[node[n].n_usr.n_proxies].px_sproxy
+#define NODE2RPROXY(n) 	  &proxies[node[n].n_usr.n_proxies].px_rproxy
+
+#define KREF_GET(rc) do { \
+  	MOLDEBUG(DBGREFCOUNT ,"KREF_GET counter=%d\n",atomic_read(rc.refcount));\
+	kref_get(rc);\
+}while(0);
+
+#define KREF_PUT(rc, function) do { \
+  	MOLDEBUG(DBGREFCOUNT ,"KREF_PUT counter=%d\n",atomic_read(rc.refcount));\
+	kref_put(rc, function);\
+}while(0);
+
+/*----------------------------------------------------------------*/
+/*				MACROS 				*/
+/*----------------------------------------------------------------*/
+#define ERROR_PRINT(rcode) \
+ do { \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__,rcode); \
+ }while(0);
+ 
+#define ERROR_RETURN(rcode) \
+ do { \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__,rcode); \
+	return(rcode); \
+ }while(0);
+
+
+#define ERROR_RUNLOCK_VM(v,rcode) \
+ do { \
+	RUNLOCK_VM(v); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+
+#define ERROR_WUNLOCK_VM(v,rcode) \
+ do { \
+	WUNLOCK_VM(v); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+ 
+#define ERROR_RUNLOCK_PROC(p,rcode) \
+ do { \
+	RUNLOCK_PROC(p); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+
+#define ERROR_WUNLOCK_PROC(p,rcode) \
+ do { \
+	WUNLOCK_PROC(p); \
+     	printk("ERROR: %d:%s:%u: rcode=%d\n",current->pid, __FUNCTION__ ,__LINE__, rcode); \
+	return(rcode); \
+ }while(0);
+
+#define ERROR_UNLOCK_TASK(task, rcode) \
+ do { \
+	UNLOCK_TASK(task);\
+	ERROR_RETURN(rcode);\
+ }while(0);
+ 
+#define LOCAL_PROC_UP(proc, rcode) \
+ do { \
+	inherit_cpu(proc); \
+ 	proc->p_rcode = rcode; \
+MOLDEBUG(DBGPROCSEM,"BEFORE UP lpid=%d p_sem=%d rcode=%d\n",proc->p_usr.p_lpid,proc->p_pseudosem, rcode); \
+	proc->p_pseudosem += 1; \
+	wake_up_interruptible(&proc->p_wqhead); \
+}while(0);
+
+#define READY_UP_SHUTDOWN(proc) \
+ do { \
+ 	inherit_cpu(proc); \
+   	proc->p_rcode = EMOLSHUTDOWN; \
+MOLDEBUG(DBGPROCSEM,"BEFORE UP lpid=%d p_sem=%d\n",proc->p_usr.p_lpid,proc->p_pseudosem); \
+	proc->p_pseudosem += 1; \
+	wake_up_interruptible(&proc->p_wqhead); \
+	}\
+ }while(0);
+
+#define READY_UP_RCODE(proc, cmd, rcode) \
+ do { \
+ 	inherit_cpu(proc); \
+	proc->p_rcode = rcode; \
+MOLDEBUG(DBGPROCSEM,"BEFORE UP lpid=%d p_sem=%d\n",proc->p_usr.p_lpid,proc->p_pseudosem); \
+	proc->p_pseudosem += 1; \
+	wake_up_interruptible(&proc->p_wqhead); \
+ }while(0); 
+
+#define BUILD_NOTIFY_MSG(v, p, ep) \
+ do { \
+	p->p_message.m_source 	= ep;\
+	p->p_message.m_type 	= NOTIFY_FROM(p->p_usr.p_nr+v->vm_usr.vm_nr_tasks);\
+	p->p_message.NOTIFY_TIMESTAMP = current_kernel_time();\
+	switch (p->p_usr.p_nr) {\
+		case HARDWARE:\
+		p->p_message.NOTIFY_ARG = (long) p->p_priv.s_int_pending;\
+			p->p_priv.s_int_pending = 0;\
+			break;\
+		case SYSTEM:\
+			p->p_message.NOTIFY_ARG = (long) p->p_priv.s_sig_pending;\
+			p->p_priv.s_sig_pending = 0;\
+			break;\
+		}\
+ }while(0); 
+
+/* !!!! ATENTION !!! p is already WLOCKED !!! */
+#define WLOCK_ORDERED2(p,q)		\
+do {\
+	if( p->p_usr.p_nr < q->p_usr.p_nr) { \
+		WLOCK_PROC(q);\
+	}else{\
+		WUNLOCK_PROC(p);\
+		WLOCK_PROC(q);\
+		WLOCK_PROC(p);\
+	}\
+}while(0);
+
+#define WLOCK_PROC2(p,q)		\
+do {\
+	if( p->p_usr.p_nr < q->p_usr.p_nr) { \
+		WLOCK_PROC(p);\
+		WLOCK_PROC(q);\
+	}else{\
+		WLOCK_PROC(q);\
+		WLOCK_PROC(p);\
+	}\
+}while(0);
+
+#define WUNLOCK_PROC2(p,q)	\
+do {\
+	WUNLOCK_PROC(p);\
+	WUNLOCK_PROC(q);\
+}while(0); 
+
+#define WLOCK_PROC3(p,q,r)		\
+do {\
+	if( p->p_usr.p_nr < q->p_usr.p_nr) { \
+		if( r->p_usr.p_nr < q->p_usr.p_nr) {\
+			WLOCK_PROC2(p,r);\
+			WLOCK_PROC(q);\
+		}else{ \
+			WLOCK_PROC2(p,q);\
+			WLOCK_PROC(r);\
+		}\
+	}else{\
+		if( r->p_usr.p_nr < p->p_usr.p_nr) {\
+			WLOCK_PROC2(q,r);\
+			WLOCK_PROC(p);\
+		}else{ \
+			WLOCK_PROC2(q,p);\
+			WLOCK_PROC(r);\
+		}\
+	}\
+}while(0);
+
+#define WUNLOCK_PROC3(p,q,r)	\
+do {\
+	WUNLOCK_PROC(p);\
+	WUNLOCK_PROC(q);\
+	WUNLOCK_PROC(r);\
+}while(0);
+
+#define LOCK_TASK(task) 	\
+do {\
+	mutex_lock(&task->proc_mutex);\
+MOLDEBUG(DBGTASKLOCK ,"LOCK_TASK pid=%d count=%d\n",task->pid,atomic_read(&task->proc_mutex.count));\
+}while(0);
+
+#define UNLOCK_TASK(task) 	\
+do {\
+MOLDEBUG(DBGTASKLOCK ,"UNLOCK_TASK pid=%d count=%d\n",task->pid,atomic_read(&task->proc_mutex.count));\
+	mutex_unlock(&task->proc_mutex);\
+}while(0);
+
+#define CHECK_ENDPOINT(t, p_ptr,ep) \
+do {\
+	if( p_ptr->p_usr.p_endpoint != ep) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLENDPOINT);\
+	}\
+}while(0)
+
+#define CHECK_IF_NULL(t, p_ptr)	\
+do {\
+	if( p_ptr == NULL ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLBADPROC);\
+	}\
+}while(0)
+
+#define CHECK_IF_REMOTE(t, p_ptr)	\
+do {\
+	if( IT_IS_REMOTE(p_ptr) ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLRMTPROC);\
+	}\
+}while(0)
+
+#define CHECK_IF_LOCAL(t, p_ptr)	\
+do {\
+	if( !IT_IS_REMOTE(p_ptr) ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLLCLPROC);\
+	}\
+}while(0)
+
+#define CHECK_IF_EMPTY(t, p_ptr)	\
+do {\
+	if( p_ptr->p_usr.p_rts_flags == SLOT_FREE ) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLDSTDIED);\
+	}\
+}while(0)
+
+#define CHECK_P_NR(t, v_ptr, p_nr)		\
+do {\
+	if( p_nr < (-v_ptr->vm_usr.vm_nr_tasks) || p_nr >= v_ptr->vm_usr.vm_nr_procs) {\
+		UNLOCK_TASK(t);\
+		ERROR_RETURN(EMOLRANGE);\
+	}\
+}while(0)
+
+
+/*--------------------------------------------------------- USE_PROC_RWLOCKS ---------------------------------------*/
+#if LOCK_PROC_TYPE == USE_PROC_RWLOCK
+
+#define RUNLOCK_PROC(p)	\
+	do {\
+		read_unlock(&p->p_rwlock);\
+	}while(0); 
+
+#define WUNLOCK_PROC(p)	\
+do {\
+	write_unlock(&p->p_rwlock);\
+}while(0); 
+
+#define WLOCK_PROC(p)		\
+do {\
+	write_lock(&p->p_rwlock);\
+}while(0);
+
+#define RLOCK_PROC(p)		\
+do {\
+	read_lock(&p->p_rwlock);\
+}while(0);
+
+#define COPY_TO_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+	 	ret = copy_to_user(uaddr, kaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#define COPY_FROM_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+ 	ret = copy_from_user(kaddr, uaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#define COPY_USR2USR_PROC(ret, endpoint, src, srcaddr, dst, dstaddr, len )		\
+do {\
+		preempt_enable();\
+	ret = copy_usr2usr(endpoint, src, srcaddr, dst, dstaddr, len);\
+		preempt_disable();\
+}while(0)
+
+
+#else 
+/*--------------------------------------------------------- USE_PROC_MUTEX  ---------------------------------------*/
+#define RUNLOCK_PROC(p)	\
+	do {\
+MOLDEBUG(DBGPROCLOCK,"RUNLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint, atomic_read(&p->p_mutex.count));\
+		mutex_unlock(&p->p_mutex);\
+	}while(0); 
+
+#define WUNLOCK_PROC(p)	\
+do {\
+MOLDEBUG(DBGPROCLOCK,"WUNLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+	mutex_unlock(&p->p_mutex);\
+}while(0); 
+
+#define WLOCK_PROC(p)		\
+do {\
+	mutex_lock(&p->p_mutex);\
+MOLDEBUG(DBGPROCLOCK,"WLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+}while(0);
+
+#define RLOCK_PROC(p)		\
+do {\
+	mutex_lock(&p->p_mutex);\
+MOLDEBUG(DBGPROCLOCK,"RLOCK_PROC ep=%d count=%d\n",p->p_usr.p_endpoint,atomic_read(&p->p_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+	 	ret = copy_to_user(uaddr, kaddr, len);\
+}while(0)
+
+#define COPY_FROM_USER_PROC(ret, kaddr, uaddr, len )		\
+do {\
+ 	ret = copy_from_user(kaddr, uaddr, len);\
+}while(0)
+
+#define COPY_USR2USR_PROC(ret, endpoint, src, srcaddr, dst, dstaddr, len )		\
+do {\
+	ret = copy_usr2usr(endpoint, src, srcaddr, dst, dstaddr, len);\
+}while(0)
+
+#endif
+
+#define LOCK_ALL_PROCS(vm_ptr, tmp_ptr, i) do { \
+MOLDEBUG(INTERNAL,"Locking all processes of VM=%d\n",vm_ptr->vm_usr.vm_vmid); \
+	for (i = 0; i < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs); i++) {\
+		tmp_ptr = VM_PROC(vm_ptr,i);\
+		WLOCK_PROC(tmp_ptr); \
+	}\
+}while(0)
+
+#define UNLOCK_ALL_PROCS(vm_ptr, tmp_ptr,i) do{ \
+MOLDEBUG(INTERNAL,"Unlocking all processes of VM=%d\n",vm_ptr->vm_usr.vm_vmid);\
+	for (i = 0; i < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs); i++) {\
+		tmp_ptr = VM_PROC(vm_ptr,i);\
+		WUNLOCK_PROC(tmp_ptr); \
+	}\
+}while(0)
+
+#define FOR_EACH_PROC(vm_ptr, i) \
+	for (i = 0; i < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs); i++) \
+
+
+/*--------------------------------------------------------- USE_VM_RWLOCKS ---------------------------------------*/
+#if LOCK_VM_TYPE == USE_VM_RWLOCK
+#define WUNLOCK_VM(v)	\
+do {\
+	write_unlock(&v->vm_rwlock);\
+}while(0); 
+
+#define RUNLOCK_VM(v)	\
+do {\
+	read_unlock(&v->vm_rwlock);\
+}while(0); 
+	
+#define WLOCK_VM(v)		\
+do {\
+	write_lock(&v->vm_rwlock);\
+}while(0);
+
+#define RLOCK_VM(v)		\
+do {\
+	read_lock(&v->vm_rwlock);\
+}while(0);
+
+#define COPY_TO_USER_VM(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#else
+/*--------------------------------------------------------- USE_VM_MUTEX  ---------------------------------------*/
+#define WUNLOCK_VM(v)	\
+do {\
+MOLDEBUG(DBGVMLOCK,"WUNLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+	mutex_unlock(&v->vm_mutex);\
+}while(0); 
+
+#define RUNLOCK_VM(v)	\
+do {\
+MOLDEBUG(DBGVMLOCK,"RUNLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+	mutex_unlock(&v->vm_mutex);\
+}while(0); 
+	
+#define WLOCK_VM(v)		\
+do {\
+	mutex_lock(&v->vm_mutex);\
+MOLDEBUG(DBGVMLOCK,"WLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+}while(0);
+
+#define RLOCK_VM(v)		\
+do {\
+	mutex_lock(&v->vm_mutex);\
+MOLDEBUG(DBGVMLOCK,"RLOCK_VM vm=%d count=%d\n",vm->vm_usr.vm_vmid, atomic_read(&v->vm_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_VM(ret, kaddr, uaddr, len )		\
+do {\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+}while(0)
+
+#endif
+
+/*--------------------------------------------------------- USE_DRVS_RWLOCKS ---------------------------------------*/
+#if LOCK_DRVS_TYPE == USE_DRVS_RWLOCK
+#define WUNLOCK_DRVS	\
+do {\
+	write_unlock(&drvs_rwlock);\
+}while(0); 
+
+#define RUNLOCK_DRVS	\
+do {\
+	read_unlock(&drvs_rwlock);\
+}while(0); 
+	
+#define WLOCK_DRVS		\
+do {\
+	write_lock(&drvs_rwlock);\
+}while(0);
+
+#define RLOCK_DRVS		\
+do {\
+	read_lock(&drvs_rwlock);\
+}while(0);
+
+
+#else
+/*--------------------------------------------------------- USE_DRVS_MUTEX  ---------------------------------------*/
+#define WUNLOCK_DRVS	\
+do {\
+	mutex_unlock(&drvs_mutex);\
+}while(0); 
+
+#define RUNLOCK_DRVS	\
+do {\
+	mutex_unlock(&drvs_mutex);\
+}while(0); 
+	
+#define WLOCK_DRVS		\
+do {\
+	mutex_lock(&drvs_mutex);\
+}while(0);
+
+#define RLOCK_DRVS		\
+do {\
+	mutex_lock(&drvs_mutex);\
+}while(0);
+
+
+#endif
+
+/*--------------------------------------------------------- USE_NODE_RWLOCKS ---------------------------------------*/
+#if LOCK_NODE_TYPE == USE_NODE_RWLOCK
+#define WUNLOCK_NODE(n)	\
+do {\
+	write_unlock(&n->n_rwlock);\
+}while(0); 
+
+#define RUNLOCK_NODE(n)	\
+do {\
+	read_unlock(&n->n_rwlock);\
+}while(0); 
+	
+#define WLOCK_NODE(n)		\
+do {\
+	write_lock(&n->n_rwlock);\
+}while(0);
+
+#define RLOCK_NODE(n)		\
+do {\
+	read_lock(&n->n_rwlock);\
+}while(0);
+
+#define COPY_TO_USER_NODE(ret, kaddr, uaddr, len )		\
+do {\
+		preempt_enable();\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+		preempt_disable();\
+}while(0)
+
+#else
+/*--------------------------------------------------------- USE_NODE_MUTEX  ---------------------------------------*/
+#define WUNLOCK_NODE(n)	\
+do {\
+MOLDEBUG(DBGNODELOCK,"WUNLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+	mutex_unlock(&n->n_mutex);\
+}while(0); 
+
+#define RUNLOCK_NODE(n)	\
+do {\
+MOLDEBUG(DBGNODELOCK,"RUNLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+	mutex_unlock(&n->n_mutex);\
+}while(0); 
+	
+#define WLOCK_NODE(n)		\
+do {\
+	mutex_lock(&n->n_mutex);\
+MOLDEBUG(DBGNODELOCK,"WLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+}while(0);
+
+#define RLOCK_NODE(n)		\
+do {\
+	mutex_lock(&n->n_mutex);\
+MOLDEBUG(DBGNODELOCK,"RLOCK_NODE node=%d count=%d\n",n->n_usr.n_nodeid, atomic_read(&n->n_mutex.count));\
+}while(0);
+
+#define COPY_TO_USER_NODE(ret, kaddr, uaddr, len )		\
+do {\
+ 	ret = copy_to_user(uaddr, kaddr, len);\
+}while(0)
+
+#endif
+
+/*--------------------------------------------------------- USE_PROXY_RWLOCKS ---------------------------------------*/
+#if LOCK_PROXY_TYPE == USE_PROXY_RWLOCK
+#define WUNLOCK_PROXY(px)	\
+do {\
+	write_unlock(&px->px_rwlock);\
+}while(0); 
+
+#define RUNLOCK_PROXY(px)	\
+do {\
+	read_unlock(&px->px_rwlock);\
+}while(0); 
+	
+#define WLOCK_PROXY(px)		\
+do {\
+	write_lock(&px->px_rwlock);\
+}while(0);
+
+#define RLOCK_PROXY(px)		\
+do {\
+	read_lock(&px->px_rwlock);\
+}while(0);
+
+
+#else
+/*--------------------------------------------------------- USE_PROXY_MUTEX  ---------------------------------------*/
+#define WUNLOCK_PROXY(px)	\
+do {\
+MOLDEBUG(DBGPROXYLOCK,"WUNLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+	mutex_unlock(&px->px_mutex);\
+}while(0); 
+
+#define RUNLOCK_PROXY(px)	\
+do {\
+MOLDEBUG(DBGPROXYLOCK,"RUNLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+	mutex_unlock(&px->px_mutex);\
+}while(0); 
+	
+#define WLOCK_PROXY(px)		\
+do {\
+	mutex_lock(&px->px_mutex);\
+MOLDEBUG(DBGPROXYLOCK,"WLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+}while(0);
+
+#define RLOCK_PROXY(px)		\
+do {\
+	mutex_lock(&px->px_mutex);\
+MOLDEBUG(DBGPROXYLOCK,"RLOCK_PROXY pxid=%d count=%d\n",px->px_usr.px_id, atomic_read(&px->px_mutex.count));\
+}while(0);
+
+#endif
+
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/mol-migrate.c /usr/src/linux/kernel/mol-migrate.c
--- /home/jara/linux-2.6.32/kernel/mol-migrate.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-migrate.c	2013-10-21 11:59:05.000000000 -0300
@@ -0,0 +1,510 @@
+/****************************************************************/
+/*		MINIX OVER LINUX IPC MIGRATION SUPPORT 		*/
+/* MIGRATION START: On REMOTE nodes, the process descriptor is signaled */
+/*                                    On LOCAL old node, only the thread group leader */
+/* 					can START the migration and the descriptor is	*/
+/*					signaled							*/
+/* MIGRATION FAILED: On REMOTE nodes, the process descriptor are reset */
+/*                                    On LOCAL old node, only the thread group leader */
+/* 					can FAIL the migration					*/
+/*					ALL threads are reset					*/
+/* MIGRATION END:  EVERY thread migrated needs a mol_migrate call	*/
+/****************************************************************/
+
+
+#include "mol.h"
+#include "mol-proto.h"
+
+
+extern int send_sig_info(int, struct siginfo *, struct task_struct *);
+extern struct cpuinfo_x86 boot_cpu_data;
+
+#include "mol-glo.h"
+#include "mol-macros.h"
+
+/*------------------------------------------------------*/
+/* Searchs all processes at the MIGRATION list and*/
+/* clear the BIT_WAITMIGR flag			*/
+/* They includes all processes that trying to send a	*/
+/*  message AFTER MIGRATE_START			*/
+/* and BEFORE MIGRATE_END				*/
+/* ON INPUT: proc WLOCKED				*/
+/* ON OUTPUT: proc WLOCKED				*/
+/*------------------------------------------------------*/
+void flush_migr_list( struct proc *proc_ptr)
+{
+	struct proc *xpp, *tmp_ptr;
+	
+	MOLDEBUG(GENERIC,"Searchs all processes at the MIGRATING list of ep=%d\n", proc_ptr->p_usr.p_endpoint);		
+	list_for_each_entry_safe(xpp, tmp_ptr, &proc_ptr->p_mlist, p_mlink) {
+	
+		WLOCK_ORDERED2(proc_ptr, xpp);
+		list_del(&xpp->p_mlink); /* remove from queue */	
+		if( xpp->p_usr.p_waitmigr == proc_ptr->p_usr.p_endpoint) {
+			MOLDEBUG(GENERIC,"endpoint=%d name=%s\n", xpp->p_usr.p_endpoint,xpp->p_usr.p_name);
+			clear_bit(BIT_WAITMIGR, &xpp->p_usr.p_rts_flags);
+			xpp->p_usr.p_waitmigr = NONE;
+			if(xpp->p_usr.p_rts_flags == 0) 
+				LOCAL_PROC_UP(xpp, EMOLMIGRATE);
+		}else{	
+			ERROR_PRINT(EMOLENDPOINT);
+		}
+	 	WUNLOCK_PROC(xpp); /* proc LOCK is just locked */
+	}
+}
+
+/* 
+* Searchs all processes at the migrating process SENDING list
+* and returns then EMOLMIGRATE to replay the IPC
+* They includes all processes that trying to send a message BEFORE MIGRATE_START
+* ON INPUT: proc WLOCKED				
+* ON OUTPUT: proc WLOCKED				
+*/
+void flush_sending_list(struct proc *proc_ptr)
+{
+	struct proc *xpp, *tmp_ptr;
+	proxy_hdr_t header, *h_ptr;
+
+	MOLDEBUG(GENERIC,"Searchs all processes at the process sending list of ep=%d\n", proc_ptr->p_usr.p_endpoint);		
+	list_for_each_entry_safe(xpp, tmp_ptr, &proc_ptr->p_list, p_link) {
+		MOLDEBUG(GENERIC,"endpoint=%d name=%s\n", xpp->p_usr.p_endpoint,xpp->p_usr.p_name);
+
+		WLOCK_ORDERED2(proc_ptr, xpp);
+		list_del(&xpp->p_link); /* remove from queue */	
+		if( IT_IS_LOCAL(xpp)) {
+			MOLDEBUG(GENERIC,"Replay IPC from endpoint=%d\n", xpp->p_usr.p_endpoint);
+			clear_bit(BIT_SENDING,&xpp->p_usr.p_rts_flags);
+			clear_bit(BIT_RECEIVING,&xpp->p_usr.p_rts_flags);
+			xpp->p_usr.p_getfrom = NONE;
+			xpp->p_usr.p_sendto  = NONE;
+			if(xpp->p_usr.p_rts_flags == PROC_RUNNING) {
+				LOCAL_PROC_UP(xpp, EMOLMIGRATE);
+			}	
+		}else{
+			/*
+			* Return an EMOLMIGRATE error to the sender of the message
+			*/
+			if( !(xpp->p_rmtcmd.c_cmd & (1 << BIT_ACKNOWLEDGE))){
+				MOLDEBUG(GENERIC,"send EMOLMIGRATE remote=%d\n", xpp->p_usr.p_endpoint);
+				memcpy(&header, &xpp->p_rmtcmd, sizeof(proxy_hdr_t));
+				h_ptr = &header;
+				/* Send an ACKNOWLEDGE to the sending process with EMOLMIGRATE error */
+				error_lcl2rmt( xpp->p_rmtcmd.c_cmd | (1 << BIT_ACKNOWLEDGE), xpp, h_ptr, EMOLMIGRATE);
+			}else{
+				MOLDEBUG(GENERIC,"Ignore ACKs message from remote=%d\n", xpp->p_usr.p_endpoint);
+			}
+		}
+		WUNLOCK_PROC(xpp);
+	}
+}
+	
+/*------------------------------------------------------*/
+/*		migr_rollback				*/
+/* MIGR_ROLLBACK:  The process migration has failed. 	*/
+/* Reset the BIT_MIGRATE.				*/
+/* Reset the BIT_WAITMIGR and the p_waitmigr descriptor */
+/* field of all "waiting to send" processes 		*/
+/*------------------------------------------------------*/
+long int migr_rollback(struct proc *proc_ptr)
+{
+
+	struct task_struct *task_ptr, *thread_ptr;
+	proc_usr_t *pu_ptr; 
+	struct proc *p_ptr;
+	int ret;
+	
+	pu_ptr= &proc_ptr->p_usr;
+	MOLDEBUG(DBGPARAMS,PROC_USR_FORMAT, PROC_USR_FIELDS(pu_ptr));
+	ret = OK;
+
+	if( IT_IS_REMOTE(proc_ptr)) {
+		do {
+			if( test_bit(BIT_SLOT_FREE, &proc_ptr->p_usr.p_rts_flags))	{ret = EMOLNOTBIND; break;}
+			if( test_bit(BIT_ONCOPY, &proc_ptr->p_usr.p_rts_flags))		{ret = EMOLONCOPY; break;}
+			if( test_bit(BIT_RMTOPER, &proc_ptr->p_usr.p_rts_flags))	{ret = EMOLBUSY; break;}
+			if(test_bit(BIT_NO_ENDPOINT, &proc_ptr->p_usr.p_rts_flags))	{ret = EMOLENDPOINT; break;}
+			if(!test_bit(BIT_MIGRATE, &proc_ptr->p_usr.p_rts_flags)) 	{ret = EMOLMIGRATE; break;}
+		}while(0);
+		if(ret) ERROR_RETURN(ret);
+		clear_bit(MIS_BIT_NEEDMIGR, &proc_ptr->p_usr.p_misc_flags);
+		clear_bit(BIT_MIGRATE, &proc_ptr->p_usr.p_rts_flags);
+		return(OK);
+	}
+	
+	if(!test_bit(MIS_BIT_GRPLEADER, &proc_ptr->p_usr.p_misc_flags))	ERROR_RETURN(EMOLGRPLEADER);
+
+	/* FIRST LOOP: Check the correct status of all process' threads */
+	task_ptr = thread_ptr = proc_ptr->p_task;
+	WUNLOCK_PROC(proc_ptr);
+	read_lock(&tasklist_lock);
+	do {
+		p_ptr = thread_ptr->proc_ptr;
+		if( p_ptr != NULL) {		/* Ignore not binded threads */
+			RLOCK_PROC(p_ptr);
+			do {
+				if( test_bit(BIT_SLOT_FREE, &p_ptr->p_usr.p_rts_flags))	{ret = EMOLNOTBIND; break;}
+				if( test_bit(BIT_ONCOPY, &p_ptr->p_usr.p_rts_flags))	{ret = EMOLONCOPY; break;}
+				if( test_bit(BIT_RMTOPER, &p_ptr->p_usr.p_rts_flags))	{ret = EMOLBUSY; break;}
+				if(test_bit(BIT_NO_ENDPOINT, &p_ptr->p_usr.p_rts_flags)){ret = EMOLENDPOINT; break;}
+				if(!test_bit(BIT_MIGRATE, &p_ptr->p_usr.p_rts_flags)) 	{ret = EMOLMIGRATE; break;}
+			}while(0);
+			RUNLOCK_PROC(p_ptr);
+			if(ret) { 
+				read_unlock(&tasklist_lock);
+				WLOCK_PROC(proc_ptr);
+				ERROR_RETURN(ret);	
+			}
+		}
+	}while_each_thread(task_ptr, thread_ptr);
+	WLOCK_PROC(proc_ptr);
+	/* SECOND LOOP: Clear the MIGRATION BITS from the process' threads descriptors */
+	task_ptr = thread_ptr = proc_ptr->p_task;
+	WUNLOCK_PROC(proc_ptr);
+	do {
+		p_ptr = thread_ptr->proc_ptr;
+		if( p_ptr != NULL) {		/* Ignore not binded threads */
+			WLOCK_PROC(p_ptr);
+			clear_bit(MIS_BIT_NEEDMIGR, &p_ptr->p_usr.p_misc_flags);
+			clear_bit(BIT_MIGRATE, &p_ptr->p_usr.p_rts_flags);
+			flush_migr_list(p_ptr);
+			if(p_ptr->p_usr.p_rts_flags == PROC_RUNNING )
+				LOCAL_PROC_UP(p_ptr, OK);
+			WUNLOCK_PROC(p_ptr);
+		}
+	}while_each_thread(task_ptr, thread_ptr);
+	
+	read_unlock(&tasklist_lock);
+	WLOCK_PROC(proc_ptr);
+
+	return(OK);
+}
+
+/*------------------------------------------------------*/
+/*		migr_start				*/
+/* MIGR_START:  The process migration has started. 	*/
+/* The process descriptor is WRITE LOCKED		*/
+/* Set the BIT_MIGRATE to change the behaviour of IPC 	*/
+/* if the local node is the old node of the process 	*/
+/* sets the NEED MIGRATION bit to signal the 	*/
+/* IPC kernel to set the BIT_MIGRATE in the next IPC call */
+/*------------------------------------------------------*/
+long int migr_start(struct proc *proc_ptr)
+{
+	struct task_struct *task_ptr, *thread_ptr;
+	struct proc *p_ptr;
+	proc_usr_t *pu_ptr; 
+	int ret;
+	
+	pu_ptr= &proc_ptr->p_usr;
+	MOLDEBUG(DBGPARAMS,PROC_USR_FORMAT, PROC_USR_FIELDS(pu_ptr));
+	ret = OK;
+
+	if( IT_IS_REMOTE(proc_ptr)) {
+		do {
+			if( test_bit(BIT_SLOT_FREE, &proc_ptr->p_usr.p_rts_flags))	{ret = EMOLNOTBIND; break;}
+			if( test_bit(BIT_ONCOPY, &proc_ptr->p_usr.p_rts_flags))		{ret = EMOLONCOPY; break;}
+			if( test_bit(BIT_RMTOPER, &proc_ptr->p_usr.p_rts_flags))	{ret = EMOLBUSY; break;}
+			if(test_bit(BIT_NO_ENDPOINT, &proc_ptr->p_usr.p_rts_flags))	{ret = EMOLENDPOINT; break;}
+			if(test_bit(BIT_MIGRATE, &proc_ptr->p_usr.p_rts_flags)) 	{ret = EMOLMIGRATE; break;}
+		}while(0);
+		if(ret) ERROR_RETURN(ret);
+		/* Signal the REMOTE process with the  BIT_MIGRATE */
+		set_bit(BIT_MIGRATE, &proc_ptr->p_usr.p_rts_flags);
+		return(OK);
+	}
+	
+	if(!test_bit(MIS_BIT_GRPLEADER, &proc_ptr->p_usr.p_misc_flags))	ERROR_RETURN(EMOLGRPLEADER);
+
+	/* FIRST LOOP: Check the correct status of all process' threads */
+	task_ptr = thread_ptr = proc_ptr->p_task;
+	WUNLOCK_PROC(proc_ptr);
+	read_lock(&tasklist_lock);
+	do {
+		p_ptr = thread_ptr->proc_ptr;
+		if( p_ptr != NULL) {		/* Ignore not binded threads */
+			RLOCK_PROC(p_ptr);
+			do {
+				if( test_bit(BIT_SLOT_FREE, &p_ptr->p_usr.p_rts_flags))	{ret = EMOLNOTBIND; break;}
+				if( test_bit(BIT_ONCOPY, &p_ptr->p_usr.p_rts_flags))		{ret = EMOLONCOPY; break;}
+				if( test_bit(BIT_RMTOPER, &p_ptr->p_usr.p_rts_flags))	{ret = EMOLBUSY; break;}
+				if(test_bit(BIT_NO_ENDPOINT, &p_ptr->p_usr.p_rts_flags))	{ret = EMOLENDPOINT; break;}
+				if(test_bit(BIT_MIGRATE, &p_ptr->p_usr.p_rts_flags)) 	{ret = EMOLMIGRATE; break;}
+			}while(0);
+			RUNLOCK_PROC(p_ptr);
+			if(ret) {
+				read_unlock(&tasklist_lock);
+				WLOCK_PROC(proc_ptr);
+				ERROR_RETURN(ret);
+			}
+		}
+	}while_each_thread(task_ptr, thread_ptr);
+
+	WLOCK_PROC(proc_ptr);
+	/* SECOND LOOP: Signal all LOCAL process' threads with the  MIS_BIT_NEEDMIGR */
+	task_ptr = thread_ptr = proc_ptr->p_task;
+	do {
+		/* Cant set BIT_MIGRATE because the process is running */
+		/* Set the MIS_BIT_NEEDMIGR to set this BIT_MIGRATE in the next IPC call  */
+		p_ptr = thread_ptr->proc_ptr;
+		if( p_ptr != NULL) 		/* Ignore not binded threads */
+			set_bit(MIS_BIT_NEEDMIGR, &p_ptr->p_usr.p_misc_flags);
+	}while_each_thread(task_ptr, thread_ptr);
+	read_unlock(&tasklist_lock);
+	return(OK);
+}
+
+/*------------------------------------------------------*/
+/*		old_migrate				*/
+/* LOCAL node is OLD node				*/
+/* The process descriptor is WRITE LOCKED		*/
+/* Convert the LOCAL descriptor into a REMOTE descriptor */
+/* if a LOCAL process remainder is into IPC kernel 	*/
+/* wakeup it with error					*/
+/* ON INPUT: proc WLOCKED				*/
+/* ON OUTPUT: proc WLOCKED				*/
+/*------------------------------------------------------*/
+long int old_migrate(struct proc *proc_ptr, int new_nodeid)
+{
+	struct task_struct *task_ptr, *thread_ptr; 
+	struct proc *p_ptr;	
+	int ret;
+
+	MOLDEBUG(GENERIC,"new_nodeid=%d\n", new_nodeid );
+
+	/* Verify that all THREADS of the same process has the BIT_MIGRATE flag */
+	thread_ptr = proc_ptr->p_task;	
+	task_ptr   = proc_ptr->p_task;
+	WUNLOCK_PROC(proc_ptr);
+	ret = OK;
+	read_lock(&tasklist_lock);
+	do {
+		p_ptr = thread_ptr->proc_ptr;
+		if( p_ptr != NULL) {		/* Ignore not binded threads */
+			RLOCK_PROC(p_ptr);		
+			if( !test_bit(BIT_MIGRATE, &p_ptr->p_usr.p_rts_flags)) ret = EMOLMIGRATE;
+			RUNLOCK_PROC(p_ptr);
+			if(ret) {
+				read_unlock(&tasklist_lock);
+				WLOCK_PROC(proc_ptr);
+				ERROR_RETURN(ret);
+			}
+		}
+	}while_each_thread(task_ptr, thread_ptr);  /*!!!! DONT USE BREAK, BECAUSE HERE ARE TWO LOOPS !!!! */
+	read_unlock(&tasklist_lock);
+
+	WLOCK_PROC(proc_ptr);
+	if(!test_bit(MIS_BIT_GRPLEADER, &proc_ptr->p_usr.p_misc_flags)) ERROR_RETURN(EMOLGRPLEADER);
+	thread_ptr = proc_ptr->p_task;	
+	task_ptr   = proc_ptr->p_task;
+	WUNLOCK_PROC(proc_ptr);
+
+	read_lock(&tasklist_lock);
+	do {
+		p_ptr = thread_ptr->proc_ptr;
+		if( p_ptr != NULL) {		/* Ignore not binded threads */
+			WLOCK_PROC(p_ptr);
+			if(test_bit(MIS_BIT_GRPLEADER, &p_ptr->p_usr.p_misc_flags))
+				clear_bit(MIS_BIT_GRPLEADER, &p_ptr->p_usr.p_misc_flags);
+			/* Convert the LOCAL descriptor into a REMOTE descriptor */
+			p_ptr->p_usr.p_lpid 	= PROC_NO_PID;	/* Update PID		*/
+			p_ptr->p_usr.p_nodeid 	= new_nodeid;
+			thread_ptr->proc_ptr	= NULL;
+			p_ptr->p_task 			= NULL;
+			put_task_struct(thread_ptr);		/* decrement the reference count of the task struct */
+
+			/* if a LOCAL process remainder is into IPC kernel 	*/
+			/* wakeup it with error					*/
+			clear_bit(BIT_MIGRATE,&p_ptr->p_usr.p_rts_flags);
+			if (p_ptr->p_usr.p_rts_flags != PROC_RUNNING) {	
+				set_bit(BIT_REMOTE,&p_ptr->p_usr.p_rts_flags);
+				LOCAL_PROC_UP(p_ptr, EMOLRMTPROC);
+			}else{
+				set_bit(BIT_REMOTE,&p_ptr->p_usr.p_rts_flags);
+			}
+			flush_sending_list(p_ptr);
+			flush_migr_list(p_ptr);
+			WUNLOCK_PROC(p_ptr);
+		}
+	}while_each_thread(task_ptr, thread_ptr);  /*!!!! DONT USE BREAK, BECAUSE HERE ARE TWO LOOPS !!!! */
+	read_unlock(&tasklist_lock);
+	WLOCK_PROC(proc_ptr);
+	return(OK);
+}
+
+/*------------------------------------------------------*/
+/*		new_migrate				*/
+/* LOCAL node is NEW node				*/
+/*------------------------------------------------------*/
+long int new_migrate(VM_desc_t *vm_ptr, struct proc *proc_ptr, int pid)
+{
+	struct task_struct *task_ptr;
+
+	MOLDEBUG(GENERIC,"pid=%d\n", pid);
+	
+	if(! test_bit(MIS_BIT_RMTBACKUP, &proc_ptr->p_usr.p_misc_flags)) {  /* it is NOT a remote process' backup */
+		/* Search for the local proc */
+		read_lock(&tasklist_lock);
+		task_ptr = pid_task(find_vpid(pid), PIDTYPE_PID);  
+		if(task_ptr == NULL ) {
+			read_unlock(&tasklist_lock);
+			ERROR_RETURN(EMOLBADPROC);
+		}
+		read_unlock(&tasklist_lock);
+		get_task_struct(task_ptr);		/* increment the reference count of the task struct */
+		proc_ptr->p_task = task_ptr;		/* Set the task descriptor into the process descriptor */
+
+		LOCK_TASK(task_ptr);
+		task_ptr->proc_ptr = (struct proc *) proc_ptr;	/* Set the  process descriptor into the task descriptor */
+		strncpy((char* )&proc_ptr->p_usr.p_name, (char*)task_ptr->comm, MAXPROCNAME-1);
+		proc_ptr->p_name_ptr = (char*)task_ptr->comm;
+		UNLOCK_TASK(task_ptr);
+		proc_ptr->p_usr.p_lpid 		= pid;				/* Update PID		*/
+	}else{
+		if( proc_ptr->p_usr.p_lpid != pid) ERROR_RETURN(EMOLBADPID);
+	}
+	
+	proc_ptr->p_usr.p_nodeid	= atomic_read(&local_nodeid);	
+	proc_ptr->p_usr.p_rts_flags	= PROC_RUNNING;			/* set to RUNNING STATE	*/
+
+	return(OK);
+}
+
+/*------------------------------------------------------*/
+/*		migr_commit				*/
+/* MIGR_START:  The process migration has started. 	*/
+/* Set the BIT_MIGRATE to change the behaviour of IPC 	*/
+/* ON INPUT: proc WLOCKED				*/
+/* ON OUTPUT: proc WLOCKED				*/
+/*------------------------------------------------------*/
+long int migr_commit(VM_desc_t *vm_ptr, struct proc *proc_ptr, int pid, int new_nodeid)
+{
+	int ret;
+	proc_usr_t *pu_ptr;
+	cluster_node_t *newnode_ptr;
+
+	MOLDEBUG(DBGPARAMS,"pid=%d local_nodeid=%d new_nodeid=%d\n",
+		pid, atomic_read(&local_nodeid), new_nodeid)
+
+	if( new_nodeid < 0 || new_nodeid >= drvs.d_nr_nodes) ERROR_RETURN(EMOLNOPROXY);
+	newnode_ptr = &node[new_nodeid];
+	RLOCK_NODE(newnode_ptr);
+	ret = OK;
+	do {
+		if(newnode_ptr->n_usr.n_flags == NODE_FREE) 		{ret = EMOLNOPROXY; break;}
+		if(!test_bit(new_nodeid, &vm_ptr->vm_usr.vm_nodes))	{ret = EMOLVMNODE; break;}
+		if(!test_bit(vm->vm_usr.vm_vmid, &newnode_ptr->n_usr.n_vms)) 		{ret = EMOLVMNODE; break;} 
+	}while(0);
+	RUNLOCK_NODE(newnode_ptr);
+	if(ret) ERROR_RETURN(ret);
+	
+	if( atomic_read(&local_nodeid) == proc_ptr->p_usr.p_nodeid) {
+		ret = old_migrate(proc_ptr, new_nodeid);
+	}else if(atomic_read(&local_nodeid) == new_nodeid) {		
+		ret = new_migrate(vm_ptr, proc_ptr, pid);
+	}else{
+		proc_ptr->p_usr.p_nodeid = new_nodeid;
+		flush_migr_list(proc_ptr);
+		ret = OK;
+	}
+	if(ret) ERROR_RETURN(ret);
+
+	/* Set the new node where the process migrate to */
+//	set_node_bit(proc_ptr->p_usr.p_nodemap, new_nodeid);
+	set_bit(new_nodeid, &proc_ptr->p_usr.p_nodemap);
+
+	/* clear  BIT_MIGRATE  */
+	clear_bit(BIT_MIGRATE, &proc_ptr->p_usr.p_rts_flags);
+	clear_bit(MIS_BIT_NEEDMIGR, &proc_ptr->p_usr.p_misc_flags);
+
+	pu_ptr = &proc_ptr->p_usr;
+	MOLDEBUG(INTERNAL,PROC_USR_FORMAT, PROC_USR_FIELDS(pu_ptr));
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_migrate				*/
+/* A process can only migrate when it request a service		*/
+/* to its SYSTASK (sendrec operation), therefore its p_rts_flags*/
+/* must have only de BIT_RECEIVING and the p_getfrom = SYSTASK  */
+/* The caller of mol_migrate would be:				*/
+/*	- MIGR_START: old node's SYSTASK 			*/
+/*	- MIGR_COMMIT:   new node's SYSTASK 			*/
+/*	- MIGR_ROLLBACK: old node's SYSTASK 			*/
+/* vmid: get from caller => must be binded in the VM		*/
+/* ONLY THE MAIN THREAD aka GROUP LEADER		*/
+/* can be invoked in mol_migrate					*/
+/* All threads in the process must be in the correct		*/
+/* state to be migrated							*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_migrate(int oper, int pid, int vmid, int endpoint, int new_nodeid)
+{
+	VM_desc_t *vm_ptr;
+	int ret, p_nr;
+	struct proc *proc_ptr;
+	struct task_struct *task_ptr;
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(-EPERM);
+
+	if( DRVS_NOT_INIT() )   ERROR_RETURN(EMOLDRVSINIT );
+	
+	MOLDEBUG(DBGPARAMS,"oper=%d pid=%d vmid=%d endpoint=%d new_nodeid=%d\n",
+		oper, pid, vmid, endpoint, new_nodeid);
+
+	if( oper != MIGR_START 	&& 
+		oper != MIGR_COMMIT	&& 
+		oper != MIGR_ROLLBACK	)		ERROR_RETURN(EMOLNOSYS);
+	
+	if( vmid < 0 || vmid >= drvs.d_nr_vms) 		ERROR_RETURN(EMOLBADVMID);
+	vm_ptr 	= &vm[vmid];
+	RLOCK_VM(vm_ptr);
+
+	ret = OK;  	
+	p_nr = _ENDPOINT_P(endpoint);
+	MOLDEBUG(GENERIC,"check endpoint=%d p_nr=%d \n", endpoint, p_nr);
+	do {
+		if( p_nr < (-vm_ptr->vm_usr.vm_nr_tasks)		
+		 || p_nr >= vm_ptr->vm_usr.vm_nr_procs) 	{ret = EMOLRANGE; break;}
+		proc_ptr   = NBR2PTR(vm_ptr, p_nr);
+		if( proc_ptr == NULL) 						{ret = EMOLDSTDIED; break;}
+	}while(0);
+	if(ret) {
+		RUNLOCK_VM(vm_ptr);
+		ERROR_RETURN(ret);
+	}
+	
+	WLOCK_PROC(proc_ptr);
+	if(IT_IS_LOCAL(proc_ptr) ){
+		task_ptr = proc_ptr->p_task;
+		if(task_ptr == NULL) {
+			WUNLOCK_PROC(proc_ptr);
+			RUNLOCK_VM(vm_ptr);
+			ERROR_RETURN(EMOLBADPROC);
+		}
+	}  	
+
+	MOLDEBUG(GENERIC,"Operation=%d\n", oper);		
+	switch(oper) {
+		case MIGR_START:
+			ret = migr_start(proc_ptr);
+			break;
+		case MIGR_ROLLBACK:
+			ret = migr_rollback(proc_ptr);
+			break;
+		case MIGR_COMMIT:
+
+			ret = migr_commit(vm_ptr, proc_ptr, pid, new_nodeid);
+			break;
+		default:
+			ret = EMOLNOSYS;
+			break;
+	}
+	
+	WUNLOCK_PROC(proc_ptr);
+	RUNLOCK_VM(vm_ptr);
+
+	if(ret) ERROR_RETURN(ret);	
+
+	return(OK);
+}
+
+	
diff -Naur /home/jara/linux-2.6.32/kernel/mol-procfs.c /usr/src/linux/kernel/mol-procfs.c
--- /home/jara/linux-2.6.32/kernel/mol-procfs.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-procfs.c	2013-10-16 12:01:08.000000000 -0300
@@ -0,0 +1,415 @@
+/****************************************************************/
+/****************************************************************/
+/*			MINIX OVER LINUX PROC FS ROUTINES 			*/
+/****************************************************************/
+
+#include "mol.h"
+#include "mol-proto.h"
+#include "mol-glo.h"
+#include "mol-macros.h"
+
+/*
+       * How to be a proc read function
+       * ------------------------------
+                     * Prototype:
+                     *    int f(char *buffer, char **start, off_t offset,
+                     *          int count, int *peof, void *dat)
+                     *
+                     * Assume that the buffer is "count" bytes in size.
+                     *
+                     * If you know you have supplied all the data you
+                     * have, set *peof.
+                     *
+                     * You have three ways to return data:
+                     * 0) Leave *start = NULL.  (This is the default.)
+                     *    Put the data of the requested offset at that
+                     *    offset within the buffer.  Return the number (n)
+                     *    of bytes there are from the beginning of the
+                     *    buffer up to the last byte of data.  If the
+                     *    number of supplied bytes (= n - offset) is 
+                     *    greater than zero and you didn't signal eof
+                     *    and the reader is prepared to take more data
+                     *    you will be called again with the requested
+                     *    offset advanced by the number of bytes 
+                     *    absorbed.  This interface is useful for files
+                     *    no larger than the buffer.
+                     * 1) Set *start = an unsigned long value less than
+                     *    the buffer address but greater than zero.
+                     *    Put the data of the requested offset at the
+                     *    beginning of the buffer.  Return the number of
+                     *    bytes of data placed there.  If this number is
+                     *    greater than zero and you didn't signal eof
+                     *    and the reader is prepared to take more data
+                     *    you will be called again with the requested
+                     *    offset advanced by *start.  This interface is
+                     *    useful when you have a large file consisting
+                     *    of a series of blocks which you want to count
+                     *    and return as wholes.
+                     *    (Hack by Paul.Russell@rustcorp.com.au)
+                     * 2) Set *start = an address within the buffer.
+                     *    Put the data of the requested offset at *start.
+                     *    Return the number of bytes of data placed there.
+                     *    If this number is greater than zero and you
+                     *    didn't signal eof and the reader is prepared to
+                     *    take more data you will be called again with the
+                     *    requested offset advanced by the number of bytes
+                     *    absorbed.
+                     */
+/*--------------------------------------------------------------*/
+/*			/proc read functions			*/
+/*--------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------*/
+/*			/proc/drvs/info 			*/
+/*--------------------------------------------------------------*/
+int info_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int len=0;
+
+  	len += sprintf(page+len, "nodeid=%d\n", atomic_read(&local_nodeid));
+  	len += sprintf(page+len, "nr_vms=%d\n", drvs.d_nr_vms);
+  	len += sprintf(page+len, "nr_nodes=%d\n", drvs.d_nr_nodes);
+  	len += sprintf(page+len, "max_nr_procs=%d\n", drvs.d_nr_procs);
+  	len += sprintf(page+len, "max_nr_tasks=%d\n", drvs.d_nr_tasks);
+  	len += sprintf(page+len, "max_sys_procs=%d\n", drvs.d_nr_sysprocs);
+  	len += sprintf(page+len, "max_copy_buf=%d\n", drvs.d_max_copybuf);
+  	len += sprintf(page+len, "max_copy_len=%d\n", drvs.d_max_copylen);
+  	len += sprintf(page+len, "dbglvl=%lX\n", drvs.d_dbglvl);
+  	len += sprintf(page+len, "version=%d.%d\n", drvs.d_version, drvs.d_subver);
+  	len += sprintf(page+len, "sizeof(proc)=%d\n", sizeof(struct proc));
+  	len += sprintf(page+len, "sizeof(proc) aligned=%d\n", sizeof_proc_aligned);
+  	len += sprintf(page+len, "sizeof(vm)=%d\n", sizeof(VM_desc_t));
+  	len += sprintf(page+len, "sizeof(node)=%d\n", sizeof(cluster_node_t));
+
+  return len;
+}
+
+
+/*--------------------------------------------------------------*/
+/*			/proc/drvs/VMx/info 						*/
+/*--------------------------------------------------------------*/
+int vm_info_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int len=0, masklen, vmid;
+	int *ptr;
+	VM_desc_t *vm_ptr;
+	char bmbuf[BITMAP_BITS+1];
+
+	masklen = (BITS_TO_LONGS(NR_CPUS) * 10) + 1;
+
+	ptr  = (int *) data;
+	vmid = *ptr;
+	MOLDEBUG(DBGPARAMS,"vmid=%d\n", vmid);
+	vm_ptr = &vm[vmid];
+
+	RLOCK_VM(vm_ptr);
+	bm2ascii(bmbuf, vm_ptr->vm_usr.vm_nodes);      
+
+	if(vm_ptr->vm_usr.vm_flags != VM_FREE) {
+		len += sprintf(page, "vmid=%d\nflags=%X\nnr_procs=%d\nnr_tasks=%d\nnr_sysprocs=%d\nnr_nodes=%d\nvm_nodes=%lX\nvm_name=%s\n",
+			vm_ptr->vm_usr.vm_vmid,
+			vm_ptr->vm_usr.vm_flags,
+			vm_ptr->vm_usr.vm_nr_procs,
+			vm_ptr->vm_usr.vm_nr_tasks,
+			vm_ptr->vm_usr.vm_nr_sysprocs,
+			vm_ptr->vm_usr.vm_nr_nodes,
+			vm_ptr->vm_usr.vm_nodes,
+			vm_ptr->vm_usr.vm_name);
+		len += sprintf(page+len,"nodes 33222222222211111111110000000000\n"); 
+		len += sprintf(page+len,"      10987654321098765432109876543210\n");
+		len += sprintf(page+len,"      %s\n", bmbuf);
+		len += sprintf(page+len,"cpumask=");
+		len += cpumask_scnprintf(page+len, masklen, &vm_ptr->vm_usr.vm_cpumask);
+		len += sprintf(page+len,"\n");
+	}
+	
+	RUNLOCK_VM(vm_ptr);
+  return len;
+}
+
+/*--------------------------------------------------------------*/
+/*			/proc/drvs/VMx/procs			*/
+/*--------------------------------------------------------------*/
+int vm_procs_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int len, vmid;
+	int *ptr;
+	VM_desc_t *vm_ptr;
+	struct proc *proc_ptr;
+	static int index, n;
+	
+	ptr  = (int *) data;
+	vmid = *ptr;
+MOLDEBUG(DBGPARAMS,"vmid=%d off=%ld count=%d index=%d eof=%d\n", vmid, off, count, index, *eof);
+	vm_ptr = &vm[vmid];
+#define LINELEN	80
+
+	len = 0;
+	RLOCK_VM(vm_ptr);
+	if( vm_ptr->vm_usr.vm_flags != VM_FREE)  {
+		if(index == 0) {
+			len = sprintf(page, "VMID p_nr -endp- -lpid- node -flag- -getf- -sndt- -wmig- -prxy- name\n");	
+		}
+		while(index < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs)) {
+			proc_ptr = VM_PROC(vm_ptr,index);
+			RLOCK_PROC(proc_ptr);
+			if (proc_ptr->p_usr.p_rts_flags != SLOT_FREE) {
+				n++;
+				RUNLOCK_PROC(proc_ptr);
+				break;
+			}
+			RUNLOCK_PROC(proc_ptr);
+			index++;
+		}
+		
+		if(index < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs) ) {
+			MOLDEBUG(INTERNAL,"index=%d\n", index);
+			index++;
+			len += sprintf(page+len, "%4d %4d %6d %6d %4d %6lX %6d %6d %6d %6d %-15.15s\n",
+					proc_ptr->p_usr.p_vmid,
+					proc_ptr->p_usr.p_nr,
+					proc_ptr->p_usr.p_endpoint,
+					proc_ptr->p_usr.p_lpid,
+					proc_ptr->p_usr.p_nodeid,
+					proc_ptr->p_usr.p_rts_flags,
+					proc_ptr->p_usr.p_getfrom,
+					proc_ptr->p_usr.p_sendto,
+					proc_ptr->p_usr.p_waitmigr,
+					proc_ptr->p_usr.p_proxy,
+					proc_ptr->p_usr.p_name);
+		} else {
+			index=0;
+			n=0;
+		}
+	}
+	RUNLOCK_VM(vm_ptr);
+	if(n==0) len = 0;
+	*start=(char *)len;
+	*eof = 1;
+    return len;
+}
+
+/*--------------------------------------------------------------*/
+/*			/proc/drvs/VMx/stats			*/
+/*--------------------------------------------------------------*/
+int vm_stats_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int len, vmid;
+	int *ptr;
+	VM_desc_t *vm_ptr;
+	struct proc *proc_ptr;
+	static int index, n;
+	
+	ptr  = (int *) data;
+	vmid = *ptr;
+	MOLDEBUG(DBGPARAMS,"vmid=%d off=%ld count=%d index=%d eof=%d\n", vmid, off, count, index, *eof);
+	vm_ptr = &vm[vmid];
+#define LINELEN	80
+
+	len = 0;
+	RLOCK_VM(vm_ptr);
+	if( vm_ptr->vm_usr.vm_flags != VM_FREE)  {
+		if(index == 0) {
+			len = sprintf(page, "VMID p_nr -endp- -lpid- node --lsnt-- --rsnt--\n");	
+		}
+		while(index < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs)) {
+			proc_ptr = VM_PROC(vm_ptr,index);
+			RLOCK_PROC(proc_ptr);
+			if (proc_ptr->p_usr.p_rts_flags != SLOT_FREE) {
+				n++;
+				RUNLOCK_PROC(proc_ptr);
+				break;
+			}
+			RUNLOCK_PROC(proc_ptr);
+			index++;
+		}
+		
+		if(index < (vm_ptr->vm_usr.vm_nr_tasks + vm_ptr->vm_usr.vm_nr_procs) ) {
+			MOLDEBUG(INTERNAL,"index=%d\n", index);
+			index++;
+			len += sprintf(page+len, "%4d %4d %6d %6d %4d %8ld %8ld\n",
+					proc_ptr->p_usr.p_vmid,
+					proc_ptr->p_usr.p_nr,
+					proc_ptr->p_usr.p_endpoint,
+					proc_ptr->p_usr.p_lpid,
+					proc_ptr->p_usr.p_nodeid,
+					proc_ptr->p_usr.p_lclsent,
+					proc_ptr->p_usr.p_rmtsent);
+		} else {
+			index=0;
+			n=0;
+		}
+	}
+	RUNLOCK_VM(vm_ptr);
+	if(n==0) len = 0;
+	*start=(char *)len;
+	*eof = 1;
+    return len;
+}
+
+
+/*--------------------------------------------------------------*/
+/*			/proc/drvs/nodes 				*/
+/*--------------------------------------------------------------*/
+int nodes_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int i, len;
+	cluster_node_t *n_ptr;
+	char bmbuf[BITMAP_BITS+1];
+	
+	len = sprintf(page, "Node Flags Proxies 10987654321098765432109876543210 Name\n");
+	for (i = 0; i < drvs.d_nr_nodes; i++) {
+		n_ptr = &node[i];
+		WLOCK_NODE(n_ptr);
+		if( n_ptr->n_usr.n_flags != NODE_FREE) {
+			bm2ascii(bmbuf, n_ptr->n_usr.n_vms);      
+			len += sprintf(page+len, "%4d %5lX %7d %32s %-16.16s\n",
+				n_ptr->n_usr.n_nodeid,
+				n_ptr->n_usr.n_flags,
+				n_ptr->n_usr.n_proxies,
+				bmbuf,
+				n_ptr->n_usr.n_name);
+		}
+		WUNLOCK_NODE(n_ptr);
+	}
+
+   return len;
+}
+
+
+int node_info_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int len=0, nodeid;
+	int *ptr;
+	cluster_node_t *n_ptr;
+	char bmbuf[BITMAP_BITS+1];
+
+	ptr  = (int *) data;
+	nodeid = *ptr;
+	MOLDEBUG(DBGPARAMS,"nodeid=%d\n", nodeid);
+	
+	len = sprintf(page, "Node Flags Proxies 10987654321098765432109876543210 Name\n");
+	n_ptr = &node[nodeid];
+	WLOCK_NODE(n_ptr);
+	bm2ascii(bmbuf, n_ptr->n_usr.n_vms);      
+	len += sprintf(page+len, "%4d %5lX %7d %32s %-16.16s\n",
+		n_ptr->n_usr.n_nodeid,
+		n_ptr->n_usr.n_flags,
+		n_ptr->n_usr.n_proxies,
+		bmbuf,
+		n_ptr->n_usr.n_name);
+	WUNLOCK_NODE(n_ptr);
+
+   return len;
+}
+
+int node_stats_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+
+	int len=0, nodeid;
+	cluster_node_t *n_ptr;
+	int *ptr;
+
+	ptr  = (int *) data;
+	nodeid = *ptr;
+	MOLDEBUG(DBGPARAMS,"nodeid=%d\n", nodeid);
+	n_ptr = &node[nodeid];
+	WLOCK_NODE(n_ptr);
+	len = sprintf(page, "Node Flags\n");
+	len += sprintf(page+len, "%-8.8s %lX \n", 
+		n_ptr->n_usr.n_name, 
+		n_ptr->n_usr.n_flags);
+	WUNLOCK_NODE(n_ptr);
+
+   return len;
+}
+
+/*--------------------------------------------------------------*/
+/*			/proc/drvs/proxies/info			*/
+/*--------------------------------------------------------------*/
+int proxies_info_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int i, len;
+	struct proc *proc_ptr;
+	proxies_t *px_ptr;
+	char bmbuf[BITMAP_BITS+1];
+
+	len = sprintf(page, "Proxies Flags Sender Receiver --Proxies_Name- 10987654321098765432109876543210 \n");
+	for (i = 0; i < drvs.d_nr_nodes; i++) {
+		px_ptr = &proxies[i];
+		RLOCK_PROXY(px_ptr);
+		if( px_ptr->px_usr.px_flags != PROXIES_FREE) {
+			proc_ptr = &px_ptr->px_sproxy;
+			bm2ascii(bmbuf, proc_ptr->p_usr.p_nodemap);     
+			MOLDEBUG(INTERNAL,"flags=%lX pxnr=%d map=%lX\n",
+				px_ptr->px_usr.px_flags, i, proc_ptr->p_usr.p_nodemap);
+ 			len += sprintf(page+len, "%7d %5lX %6d %8d %15s %s\n",
+				px_ptr->px_usr.px_id,
+				px_ptr->px_usr.px_flags,
+				px_ptr->px_sproxy.p_usr.p_lpid,
+				px_ptr->px_rproxy.p_usr.p_lpid,
+				px_ptr->px_usr.px_name,
+				bmbuf);
+		}
+		RUNLOCK_PROXY(px_ptr);
+	}
+
+   return len;
+}
+
+/*--------------------------------------------------------------*/
+/*			/proc/drvs/proxies/procs			*/
+/*--------------------------------------------------------------*/
+int proxies_procs_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int i, len;
+	proxies_t *px_ptr;
+	struct proc *sproc_ptr,*rproc_ptr;
+
+	len = 0;
+	
+	len = sprintf(page, "PXID -Type- -lpid- -flag- -misc- -getf- -sendt -wmig- name\n");	
+	for (i = 0; i < drvs.d_nr_nodes; i++) {
+		px_ptr = &proxies[i];
+		RLOCK_PROXY(px_ptr);
+		if( px_ptr->px_usr.px_flags == PROXIES_FREE) {
+			RUNLOCK_PROXY(px_ptr);
+			continue;
+		}
+
+		sproc_ptr = &proxies[i].px_sproxy;
+		RLOCK_PROC(sproc_ptr);
+		len += sprintf(page+len, "%4d %6s %6d %6lX %6lX %6d %6d %6d %-15.15s\n",
+					i,
+					"sender",
+					sproc_ptr->p_usr.p_lpid,
+					sproc_ptr->p_usr.p_rts_flags,
+					sproc_ptr->p_usr.p_misc_flags,
+					sproc_ptr->p_usr.p_getfrom,
+					sproc_ptr->p_usr.p_sendto,
+					sproc_ptr->p_usr.p_waitmigr,
+					sproc_ptr->p_usr.p_name);
+		RUNLOCK_PROC(sproc_ptr);
+
+		rproc_ptr = &proxies[i].px_rproxy;
+		RLOCK_PROC(rproc_ptr);
+		len += sprintf(page+len, "%4d %6s %6d %6lX %6lX %6d %6d %6d %-15.15s\n",
+					i,
+					"recver",
+					rproc_ptr->p_usr.p_lpid,
+					rproc_ptr->p_usr.p_rts_flags,
+					rproc_ptr->p_usr.p_misc_flags,
+					rproc_ptr->p_usr.p_getfrom,
+					rproc_ptr->p_usr.p_sendto,
+					rproc_ptr->p_usr.p_waitmigr,
+					rproc_ptr->p_usr.p_name);
+		RUNLOCK_PROC(rproc_ptr);
+
+		RUNLOCK_PROXY(px_ptr);
+	}
+
+    return len;
+}
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/mol-proto.h /usr/src/linux/kernel/mol-proto.h
--- /home/jara/linux-2.6.32/kernel/mol-proto.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-proto.h	2013-10-21 10:58:52.000000000 -0300
@@ -0,0 +1,90 @@
+/****************************************************************/
+/*			MOL FUNCTION PROTOTYPES 			*/
+/****************************************************************/
+
+int check_lock_caller(struct task_struct **t_ptr, struct proc **c_ptr, int *c_pid);
+
+
+void init_proc_desc(struct proc *proc_ptr, int vmid, int index);
+long do_vm_end(VM_desc_t *vm_ptr);
+asmlinkage long do_unbind(VM_desc_t *vm_ptr, struct proc *proc_ptr, int nodeid);
+
+asmlinkage long send_rmt2lcl(int cmd, struct proc *src_ptr,struct proc *dst_ptr, proxy_payload_t *usr_pay_ptr);
+asmlinkage long notify_rmt2lcl(struct proc *src_ptr,struct proc *dst_ptr);
+asmlinkage long send_ack_rmt2lcl(struct proc *src_ptr,struct proc *dst_ptr, int rcode);
+asmlinkage long copyout_data_rmt2lcl(struct proc *caller_ptr, struct proc *src_ptr,struct proc *dst_ptr, 
+		proxy_hdr_t *h_ptr, proxy_payload_t *usr_pay_ptr);
+asmlinkage long copyin_data_rmt2lcl(struct proc *caller_ptr, struct proc *src_ptr, struct proc *dst_ptr, 
+		proxy_hdr_t *h_ptr, proxy_payload_t *usr_pay_ptr);
+asmlinkage long copyout_rqst_rmt2lcl( struct proc *caller_ptr, struct proc *src_ptr, struct proc *dst_ptr, 
+		proxy_hdr_t *h_ptr, proxy_payload_t *usr_pay_ptr);
+asmlinkage long copylcl_rqst_lcl2lcl(struct proc *rproxy_ptr, struct proc *rmt_ptr, 
+		struct proc *lcl_ptr, proxy_hdr_t *h_ptr, proxy_payload_t *usr_pay_ptr);
+
+long generic_ack_lcl2rmt(int ack, struct proc *rmt_ptr, struct proc *lcl_ptr, int rcode);
+long generic_ack_rmt2lcl(int ack, struct proc *rmt_ptr, struct proc *lcl_ptr, int rcode);
+
+long copyin_rqst_lcl2rmt(struct proc *dst_ptr, struct proc *lcl_ptr);	
+long copyout_data_lcl2rmt(struct proc *rmt_ptr, struct proc *lcl_ptr, int rcode);
+long error_lcl2rmt(int ack, struct proc *rmt_ptr, proxy_hdr_t *h_ptr,   int rcode);
+
+long sproxy_enqueue(struct proc *proc_ptr);
+long kill_unbind(struct proc *dst_ptr, struct proc *src_ptr);
+// long kernel_sendrec(int srcdst_ep, message* m_ptr);
+
+#ifdef MOLAUTOFORK
+struct proc* fork_bind(struct proc *proc_ptr, int lpid);
+long kernel_lclbind(int vmid, int pid, int p_nr);
+#endif /*MOLAUTOFORK */
+
+int do_proxies_unbind(struct proc *proc_ptr);
+int do_node_end(cluster_node_t *n_ptr);
+void clear_node(cluster_node_t *nptr);
+void init_node(int nodeid);
+void clear_proxies(proxies_t *px_ptr);
+void init_proxies(int pxid);
+long do_autobind(VM_desc_t *vm_ptr, struct proc *rmt_ptr, int endpoint, int nodeid);
+
+long flush_sending_procs(int nodeid, struct proc *sproxy_ptr);
+long flush_receiving_procs(int nodeid, struct proc *rproxy_ptr);
+
+long copy_usr2usr(int source, struct proc *src_proc, char *src_addr, struct proc *dst_proc, char *dst_addr, int bytes);
+#define copy_msg(src_ptr, src_msg, dst_ptr, dst_msg) \
+	copy_usr2usr(src_ptr->p_endpoint, src_ptr, (char*) src_msg, dst_ptr, (char*)dst_msg, sizeof(message));
+void vm_release(struct kref *kref);
+void drvs_release(struct kref *kref);
+int sleep_proc(struct proc *proc, long timeout_ms);
+int sleep_proc2(struct proc *proc, struct proc *other, long timeout_ms);	
+int sleep_proc3(struct proc *proc, struct proc *other1, struct proc *other2, long timeout_ms);	
+void bm2ascii( char *buf, unsigned long int bitmap);
+void inherit_cpu(struct proc *proc_ptr);
+int check_lock_caller(struct task_struct **t_ptr, struct proc **c_ptr, int *c_pid);
+void resume_migration( struct proc *proc_ptr);
+proc_t *get_sproxy(int nodeid); 
+proc_t *get_rproxy(int nodeid);
+
+
+/* /procs read functions */
+int info_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+int vm_info_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+int vm_procs_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+int vm_stats_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+int nodes_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+int node_info_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+int node_stats_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+int proxies_info_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+int proxies_procs_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+
+
+#define copylcl_ack_rmt2lcl(x,y,z)	generic_ack_rmt2lcl(CMD_COPYLCL_ACK,x,y,z) 
+#define copyrmt_ack_rmt2lcl(x,y,z) 	generic_ack_rmt2lcl(CMD_COPYRMT_ACK,x,y,z)
+#define copyin_ack_rmt2lcl(x,y,z) 	generic_ack_rmt2lcl(CMD_COPYIN_ACK,x,y,z)
+
+#define send_ack_lcl2rmt(r,l,e)   	generic_ack_lcl2rmt(CMD_SEND_ACK, r,l,e) 
+#define copylcl_ack_lcl2rmt(r,l,e) 	generic_ack_lcl2rmt(CMD_COPYLCL_ACK, r,l,e)
+#define copyin_ack_lcl2rmt(r,l,e) 	generic_ack_lcl2rmt(CMD_COPYIN_ACK, r,l,e)
+#define copyrmt_ack_lcl2rmt(r,l,e) 	generic_ack_lcl2rmt(CMD_COPYRMT_ACK, r,l,e)
+
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/mol-rproxy.c /usr/src/linux/kernel/mol-rproxy.c
--- /home/jara/linux-2.6.32/kernel/mol-rproxy.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-rproxy.c	2013-10-21 12:21:01.000000000 -0300
@@ -0,0 +1,743 @@
+/****************************************************************/
+/*		MINIX OVER LINUX IPC PRIMITIVES FOR PROXIES	*/
+/****************************************************************/
+
+#include "mol.h"
+#include "mol-proto.h"
+#include "mol-glo.h"
+#include "mol-macros.h"
+
+asmlinkage long mol_bind(int vmid, int pid, int proc, int nodeid);
+
+
+/****************************************************************/
+/****************************************************************/
+/*	FUNCTIONS FOR RECEIVER PROXY				*/
+/****************************************************************/
+/****************************************************************/
+
+/*--------------------------------------------------------------*/
+/*			send_rmt2lcl				*/
+/* proxy sends a remote message to a local process		 */
+/* The VM mutex must be locked !!!				*/
+/* src_ptr and dst_ptr must be locked 				*/
+/*--------------------------------------------------------------*/
+asmlinkage long send_rmt2lcl(int cmd, struct proc *src_ptr, struct proc *dst_ptr, proxy_payload_t *usr_pay_ptr)
+{
+	message *m_ptr;
+	int ret;
+	struct proc *sproxy_ptr, *rproxy_ptr;
+	VM_desc_t *vm_ptr;
+
+	/* checks if the source has another status than REMOTE  */
+	if( src_ptr->p_usr.p_rts_flags != REMOTE )  ERROR_RETURN(EMOLLCLPROC);
+	
+	sproxy_ptr = NODE2SPROXY(src_ptr->p_usr.p_nodeid);
+	rproxy_ptr = NODE2RPROXY(src_ptr->p_usr.p_nodeid);
+	
+	vm_ptr 	= &vm[src_ptr->p_usr.p_vmid];
+
+	MOLDEBUG(DBGPARAMS,"cmd=%d vmid=%d src_ep=%d src_flags=%lX dst_ep=%d dst_flags=%lX\n"
+		,cmd, vm_ptr->vm_usr.vm_vmid, src_ptr->p_usr.p_endpoint
+		,src_ptr->p_usr.p_rts_flags, dst_ptr->p_usr.p_endpoint,dst_ptr->p_usr.p_rts_flags);
+
+	m_ptr = &usr_pay_ptr->pay_msg;
+	MOLDEBUG(DBGMESSAGE,MSG1_FORMAT,MSG1_FIELDS(m_ptr));
+
+	/* Check if 'dst' is blocked waiting for this message.   */
+	if ( (test_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags) && !test_bit(BIT_SENDING, &dst_ptr->p_usr.p_rts_flags)) &&
+		(dst_ptr->p_usr.p_getfrom == ANY || dst_ptr->p_usr.p_getfrom == src_ptr->p_usr.p_endpoint)) {
+		MOLDEBUG(GENERIC,"destination is waiting.\n");
+//		COPY_FROM_USER_PROC(ret, (void * ) &dst_ptr->p_message, (void *)usr_pay_ptr, sizeof(message));
+		COPY_USR2USR_PROC(ret, NONE, rproxy_ptr , (void *)usr_pay_ptr, dst_ptr, (void *)dst_ptr->p_umsg,  sizeof(message) );
+		if(ret)  ERROR_RETURN(ret);
+		
+		if( cmd == CMD_SNDREC_MSG) {
+			src_ptr->p_usr.p_getfrom = dst_ptr->p_usr.p_endpoint;
+			set_bit(BIT_RECEIVING, &src_ptr->p_usr.p_rts_flags);
+		}else{
+		   	src_ptr->p_rcode = OK;
+			send_ack_lcl2rmt(src_ptr, dst_ptr, OK);
+		}
+		dst_ptr->p_message.m_source = src_ptr->p_usr.p_endpoint;
+		clear_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags);
+		dst_ptr->p_usr.p_getfrom 	= NONE;
+		if(dst_ptr->p_usr.p_rts_flags == 0)
+			LOCAL_PROC_UP(dst_ptr, OK); /* ATENTI puede haber mas de una razon para despertar al proceso!! */
+	} else { 
+		MOLDEBUG(GENERIC,"destination is not waiting dst_ptr->p_usr.p_rts_flags=%lX. Enqueue at the TAIL.\n"
+			,dst_ptr->p_usr.p_rts_flags);
+		/* copies the message into the sender's userspace buffer and wakes up it */
+		COPY_FROM_USER_PROC(ret, (void *) &src_ptr->p_message, (void *)usr_pay_ptr, sizeof(message));
+		if(ret)  ERROR_RETURN(ret);
+
+		set_bit(BIT_SENDING, &src_ptr->p_usr.p_rts_flags);
+		if( cmd == CMD_SNDREC_MSG) {
+			src_ptr->p_usr.p_getfrom = dst_ptr->p_usr.p_endpoint;
+			set_bit(BIT_RECEIVING, &src_ptr->p_usr.p_rts_flags);
+		}
+		src_ptr->p_usr.p_sendto 	= dst_ptr->p_usr.p_endpoint;
+		INIT_LIST_HEAD(&src_ptr->p_link);
+		list_add_tail(&src_ptr->p_link, &dst_ptr->p_list);
+	}
+	return(OK);
+}
+/*--------------------------------------------------------------*/
+/*			notify_rmt2lcl				*/
+/* proxy sends a remote notify to a local process		 */
+/* MODIFICAR: El mensaje ya vino por la RED. NO HAY QUE CONSTRUIR*/
+/* Sino eventualmente dejar el bitmap seteado si es q no esta	*/
+/* bloqueado el receptor					*/
+/* The VM mutex must be locked !!!				*/
+/* src_ptr and dst_ptr must be locked 				*/
+/*--------------------------------------------------------------*/
+asmlinkage long notify_rmt2lcl(struct proc *src_ptr, struct proc *dst_ptr)
+{
+	int ret;
+	struct proc *sproxy_ptr,*rproxy_ptr;
+	VM_desc_t *vm_ptr;
+
+	sproxy_ptr = NODE2SPROXY(src_ptr->p_usr.p_nodeid);
+	rproxy_ptr = NODE2RPROXY(src_ptr->p_usr.p_nodeid);
+	vm_ptr 	= &vm[dst_ptr->p_usr.p_vmid];
+
+	MOLDEBUG(DBGPARAMS,"vmid=%d src_ep=%d src_ptr->p_usr.p_rts_flags=%lX dst_ep=%d dst_ptr->p_usr.p_rts_flags=%lX\n"
+		,vm_ptr->vm_usr.vm_vmid, src_ptr->p_usr.p_endpoint
+		,src_ptr->p_usr.p_rts_flags, dst_ptr->p_usr.p_endpoint,dst_ptr->p_usr.p_rts_flags);
+
+	/* checks if the source has another status than REMOTE  */
+	if( src_ptr->p_usr.p_rts_flags != REMOTE )  ERROR_RETURN(EMOLLCLPROC);
+
+  	/* Check to see if target is blocked waiting for this message. A process 
+   	* can be both sending and receiving during a SENDREC system call.
+  	 */
+	ret = OK;
+	if ( (test_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags) && !test_bit(BIT_SENDING, &dst_ptr->p_usr.p_rts_flags)) &&
+      		(dst_ptr->p_usr.p_getfrom == ANY || dst_ptr->p_usr.p_getfrom == src_ptr->p_usr.p_endpoint)) {
+		MOLDEBUG(GENERIC,"destination is waiting. Build and copy the message to dst userspace \n");
+
+		/* Build the message in the destination buffer */
+		BUILD_NOTIFY_MSG(vm_ptr, dst_ptr, src_ptr->p_usr.p_endpoint);
+
+		/* Set the NOTIFY pending bit in the destination flags */
+		set_bit(MIS_BIT_NOTIFY, &dst_ptr->p_usr.p_misc_flags);
+
+		clear_bit(BIT_RECEIVING, &dst_ptr->p_usr.p_rts_flags);
+		dst_ptr->p_usr.p_getfrom 	= NONE;
+		if(dst_ptr->p_usr.p_rts_flags == 0)
+			LOCAL_PROC_UP(dst_ptr, OK); /* ATENTI puede haber mas de una razon para despertar al proceso!! */
+		if(ret) ERROR_RETURN(ret);
+		return(ret);
+	}
+
+	if(get_sys_bit(dst_ptr->p_priv.s_notify_pending, src_ptr->p_priv.s_usr.s_id))
+		ERROR_PRINT(EMOLOVERRUN);
+	
+	/* Add to destination the bit map with pending notifications  */
+	MOLDEBUG(INTERNAL,"set_sys_bit src_ptr->p_priv.p_usr.s_id=%d\n",src_ptr->p_priv.s_usr.s_id);
+	 
+	set_sys_bit(dst_ptr->p_priv.s_notify_pending, src_ptr->p_priv.s_usr.s_id); 
+	if(ret) ERROR_RETURN(ret);
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			copyrmt_rqst_rmt2lcl			*/
+/* a Remote process (requester) has request a data copy 	*/
+/* between 2 remote  processes 					*/
+/* rmt_ptr = requester 						*/
+/* lcl_ptr = the local process that receive the request    	*/
+/*          that is the same as the source for data 		*/
+/* The VM mutex must be locked !!!				*/
+/* lcl_ptr and rmt_ptr must be locked 				*/
+/*--------------------------------------------------------------*/
+asmlinkage long copyrmt_rqst_rmt2lcl(struct proc *rproxy_ptr, struct proc *rmt_ptr, 
+		struct proc *lcl_ptr, proxy_hdr_t *h_ptr, proxy_payload_t *usr_pay_ptr)
+{
+	int ret;
+	VM_desc_t *vm_ptr;
+	int dst_nr;
+	struct proc *dst_ptr;
+
+	MOLDEBUG(DBGCMD,CMD_FORMAT,CMD_FIELDS(h_ptr));
+	MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+
+	vm_ptr 	= &vm[lcl_ptr->p_usr.p_vmid];
+	do {
+		ret = OK;
+		if( h_ptr->c_vcopy.v_bytes <= 0 
+			|| h_ptr->c_vcopy.v_bytes > MAXCOPYLEN) 
+						{ret = EMOLRANGE; break;}
+
+		/* the local process that receive the request is the same as sender of data */
+		if( test_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags))	{ret = EMOLONCOPY; break;}
+		if( lcl_ptr->p_usr.p_endpoint !=  h_ptr->c_vcopy.v_src)	{ret = EMOLBADPROC; break;}
+		MOLDEBUG(INTERNAL,"SRC OK endpoint=%d\n", lcl_ptr->p_usr.p_endpoint);
+	
+		/*Checks Destination process */
+		dst_nr = _ENDPOINT_P(h_ptr->c_vcopy.v_dst);
+		if( dst_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 
+   		 || dst_nr >= vm_ptr->vm_usr.vm_nr_procs) 	{ret = EMOLRANGE; break;}
+		dst_ptr   = NBR2PTR(vm_ptr, dst_nr);
+
+	}while(0);
+	if(ret) ERROR_RETURN(ret);
+	
+	/* Set ONCOPY bits to protect the descriptors while they are UNLOCKED */
+	set_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags);
+	set_bit(BIT_ONCOPY, &rmt_ptr->p_usr.p_rts_flags);
+	WUNLOCK_PROC2(lcl_ptr, rmt_ptr);
+
+	WLOCK_PROC3(lcl_ptr, rmt_ptr, dst_ptr);
+	clear_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags);
+	clear_bit(BIT_ONCOPY, &rmt_ptr->p_usr.p_rts_flags);
+	do {
+		ret = OK;
+		if(IT_IS_LOCAL(dst_ptr) ) 				{ret = EMOLLCLPROC; break;}
+		if( dst_ptr->p_usr.p_rts_flags == SLOT_FREE)		{ret = EMOLDSTDIED; break;}
+		if( dst_ptr->p_usr.p_endpoint != h_ptr->c_vcopy.v_dst)  {ret = EMOLENDPOINT; break;}
+		if( test_bit(BIT_ONCOPY, &dst_ptr->p_usr.p_rts_flags))	{ret = EMOLONCOPY; break;}
+		if( test_bit(BIT_RMTOPER, &dst_ptr->p_usr.p_rts_flags))	{ret = EMOLENQUEUED; break;}
+		if( test_bit(BIT_SENDING, &dst_ptr->p_usr.p_rts_flags))	{ret = EMOLENQUEUED; break;}
+		MOLDEBUG(INTERNAL,"DST OK endpoint=%d\n", dst_ptr->p_usr.p_endpoint);
+	}while(0);
+	if(ret == OK) {
+		/* copy the header to keep the vcopy data  */ 
+		memcpy( &dst_ptr->p_rmtcmd.c_vcopy, &h_ptr->c_vcopy, sizeof(vcopy_t));
+		set_bit(BIT_ONCOPY, &dst_ptr->p_usr.p_rts_flags);
+		ret = copyin_rqst_lcl2rmt(dst_ptr, lcl_ptr);
+	}else {
+		if(ret != EMOLENQUEUED)
+			ret = copyrmt_ack_lcl2rmt(rmt_ptr, lcl_ptr, ret);			
+	}
+	
+	WUNLOCK_PROC(dst_ptr);  
+	
+	return(ret);
+}
+
+
+/*--------------------------------------------------------------*/
+/*			copylcl_rqst_rmt2lcl			*/
+/* a Remote process (requester) has request a data copy 	*/
+/* between 2 local processes 					*/
+/* rmt_ptr = requester 						*/
+/* lcl_ptr = src_ptr					    	*/
+/* The VM mutex must be locked !!!				*/
+/* lcl_ptr and rmt_ptr must be locked 				*/
+/*--------------------------------------------------------------*/
+asmlinkage long copylcl_rqst_rmt2lcl(struct proc *rproxy_ptr, struct proc *rmt_ptr, 
+		struct proc *lcl_ptr, proxy_hdr_t *h_ptr, proxy_payload_t *usr_pay_ptr)
+{
+	int ret;
+	VM_desc_t *vm_ptr;
+	int dst_nr;
+	struct proc *dst_ptr;
+
+	MOLDEBUG(DBGCMD,CMD_FORMAT,CMD_FIELDS(h_ptr));
+	MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+
+	vm_ptr 	= &vm[lcl_ptr->p_usr.p_vmid];
+	/*Checks Source process */
+	do {
+		ret = OK;
+
+		if( h_ptr->c_vcopy.v_bytes <= 0 
+			|| h_ptr->c_vcopy.v_bytes > MAXCOPYLEN) 	{ret = EMOLRANGE; break;}
+
+		/* the local process that receive the request is the same as sender of data */
+		if( test_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags))	{ret = EMOLONCOPY; break;}
+		if( lcl_ptr->p_usr.p_endpoint !=  h_ptr->c_vcopy.v_src)	{ret = EMOLBADPROC; break;}
+		MOLDEBUG(INTERNAL,"LCL OK endpoint=%d\n", lcl_ptr->p_usr.p_endpoint);
+
+		/*Checks Destination process */
+		dst_nr = _ENDPOINT_P(h_ptr->c_vcopy.v_dst);
+		if( dst_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 
+			|| dst_nr >= vm_ptr->vm_usr.vm_nr_procs) 	{ret = EMOLRANGE; break;}
+		dst_ptr   = NBR2PTR(vm_ptr, dst_nr);
+	}while(0);
+	if(ret) ERROR_RETURN(ret);
+	
+	/* Set ONCOPY bits to protect the descriptors while they are UNLOCKED */
+	set_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags);
+	set_bit(BIT_ONCOPY, &rmt_ptr->p_usr.p_rts_flags);
+	WUNLOCK_PROC2(lcl_ptr, rmt_ptr);
+
+	WLOCK_PROC3(lcl_ptr, rmt_ptr, dst_ptr);
+	clear_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags);
+	clear_bit(BIT_ONCOPY, &rmt_ptr->p_usr.p_rts_flags);
+	do {
+		ret = OK;
+		if( IT_IS_REMOTE(dst_ptr) ) 				{ret = EMOLRMTPROC; break;}
+		if( dst_ptr->p_usr.p_rts_flags == SLOT_FREE)		{ret = EMOLDSTDIED; break;}
+		if( dst_ptr->p_usr.p_endpoint != h_ptr->c_vcopy.v_dst)  {ret = EMOLENDPOINT; break;}
+		if( test_bit(BIT_ONCOPY, &dst_ptr->p_usr.p_rts_flags))	{ret = EMOLONCOPY; break;}
+		if( test_bit(BIT_SENDING, &dst_ptr->p_usr.p_rts_flags))	{ret = EMOLENQUEUED; break;}
+		MOLDEBUG(INTERNAL,"DST OK endpoint=%d\n", dst_ptr->p_usr.p_endpoint);
+	}while(0);
+	if(ret == OK) {
+		COPY_USR2USR_PROC(ret, NONE, lcl_ptr, h_ptr->c_vcopy.v_saddr,
+				dst_ptr, h_ptr->c_vcopy.v_daddr, h_ptr->c_vcopy.v_bytes);
+		memcpy( &rmt_ptr->p_rmtcmd.c_vcopy, &h_ptr->c_vcopy, sizeof(vcopy_t));
+	}
+	ret = copylcl_ack_lcl2rmt(rmt_ptr, lcl_ptr, ret);	
+	WUNLOCK_PROC(dst_ptr); 
+	return(ret);
+}
+
+/*--------------------------------------------------------------*/
+/*			copyin_data_rmt2lcl			*/
+/* proxy sends a remote data to a local process address space   */
+/* The VM mutex must be locked !!!				*/
+/* lcl_ptr and rmt_ptr must be locked 				*/
+/*--------------------------------------------------------------*/
+asmlinkage long copyin_data_rmt2lcl(struct proc *rproxy_ptr, struct proc *rmt_ptr, 
+		struct proc *lcl_ptr, proxy_hdr_t *h_ptr, proxy_payload_t *usr_pay_ptr)
+{
+	int ret;
+
+	MOLDEBUG(DBGCMD,CMD_FORMAT,CMD_FIELDS(h_ptr));
+	MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+
+	do {
+		ret = OK;
+		if( h_ptr->c_vcopy.v_bytes <= 0 
+			|| h_ptr->c_vcopy.v_bytes > MAXCOPYLEN) 	{ret = EMOLRANGE ;break;}
+
+		/* the local process that receive the request is the same as sender of data */
+		if( test_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags))	{ret = EMOLONCOPY; break;}
+		if( test_bit(BIT_SENDING, &lcl_ptr->p_usr.p_rts_flags))	{ret = EMOLENQUEUED; break;}
+		if( lcl_ptr->p_usr.p_endpoint !=  h_ptr->c_vcopy.v_dst)	{ret = EMOLBADPROC; break;}
+		MOLDEBUG(INTERNAL,"DST OK endpoint=%d\n", lcl_ptr->p_usr.p_endpoint);
+
+		/* Copy Data from RPROXY to local process */
+		COPY_USR2USR_PROC(ret, NONE, rproxy_ptr, (char *)usr_pay_ptr,
+				lcl_ptr, h_ptr->c_vcopy.v_daddr, h_ptr->c_vcopy.v_bytes);
+	}while(0);
+	memcpy( &rmt_ptr->p_rmtcmd.c_vcopy, &h_ptr->c_vcopy, sizeof(vcopy_t));		
+	ret = copyin_ack_lcl2rmt(rmt_ptr, lcl_ptr, ret);	
+	return(ret);
+}
+
+/*--------------------------------------------------------------*/
+/*			copyin_rqst_rmt2lcl			*/
+/* proxy sends a remote data to a local process address space   */
+/* The VM mutex must be locked !!!				*/
+/* lcl_ptr and rmt_ptr must be locked 				*/
+/*--------------------------------------------------------------*/
+asmlinkage long copyin_rqst_rmt2lcl(struct proc *rproxy_ptr, struct proc *rmt_ptr, 
+		struct proc *lcl_ptr, proxy_hdr_t *h_ptr, proxy_payload_t *usr_pay_ptr)
+{
+	int ret;
+	struct proc *rqtr_ptr;
+	VM_desc_t *vm_ptr;
+
+	MOLDEBUG(DBGCMD,CMD_FORMAT,CMD_FIELDS(h_ptr));
+	MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+
+	vm_ptr 	= &vm[h_ptr->c_vmid];
+	rqtr_ptr = ENDPOINT2PTR(vm_ptr, h_ptr->c_vcopy.v_rqtr);
+
+	/* set the ONCOPY bits to protect the descriptor while unlocked */
+	set_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags);
+	set_bit(BIT_ONCOPY, &rmt_ptr->p_usr.p_rts_flags);
+	WUNLOCK_PROC2(rmt_ptr, lcl_ptr);
+
+	WLOCK_PROC3(rqtr_ptr, rmt_ptr, lcl_ptr);
+	clear_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags);
+	clear_bit(BIT_ONCOPY, &rmt_ptr->p_usr.p_rts_flags);
+	do {
+		ret = OK;
+		if(IT_IS_LOCAL(rqtr_ptr))		{ret = EMOLLCLPROC; break;}
+		if( h_ptr->c_vcopy.v_bytes <= 0 
+			|| h_ptr->c_vcopy.v_bytes > MAXCOPYLEN) 
+							{ret = EMOLRANGE; break;}
+
+		if( test_bit(BIT_ONCOPY, &rqtr_ptr->p_usr.p_rts_flags))	{ret = EMOLONCOPY; break;}
+		if( test_bit(BIT_RMTOPER, &rqtr_ptr->p_usr.p_rts_flags)){ret = EMOLENQUEUED; break;}
+		if( test_bit(BIT_SENDING, &rqtr_ptr->p_usr.p_rts_flags)) {ret = EMOLENQUEUED; break;}
+		COPY_USR2USR_PROC(ret, NONE, rproxy_ptr, (char *)usr_pay_ptr,
+			lcl_ptr, h_ptr->c_vcopy.v_daddr, h_ptr->c_vcopy.v_bytes);		
+	}while(0);
+	memcpy( &rqtr_ptr->p_rmtcmd.c_vcopy, &h_ptr->c_vcopy, sizeof(vcopy_t));
+	if( ret != EMOLENQUEUED)
+		copyrmt_ack_lcl2rmt(rqtr_ptr, lcl_ptr, ret);
+	WUNLOCK_PROC(rqtr_ptr);
+	
+	return(ret);
+}
+/*--------------------------------------------------------------*/
+/*			copyout_rqst_rmt2lcl				*/
+/*  Enqueue a copyout_data into the sender proxy		*/
+/*--------------------------------------------------------------*/
+asmlinkage long copyout_rqst_rmt2lcl( struct proc *rproxy_ptr, struct proc *rmt_ptr, 
+		struct proc *lcl_ptr, proxy_hdr_t *h_ptr, proxy_payload_t *usr_pay_ptr)
+{
+	int ret;
+
+	MOLDEBUG(DBGCMD,CMD_FORMAT,CMD_FIELDS(h_ptr));
+	MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+
+	do {
+		ret = OK;
+		if( h_ptr->c_vcopy.v_bytes <= 0 
+			|| h_ptr->c_vcopy.v_bytes > MAXCOPYLEN) {ret = EMOLRANGE; break;}
+		if( lcl_ptr->p_usr.p_rts_flags == PROC_RUNNING)	{ret = EMOLPROCSTS; break;}
+
+		/* the local process that receive the request is the same as sender of data */
+		if( test_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags))	{ret = EMOLONCOPY; break;}
+		if( lcl_ptr->p_usr.p_endpoint !=  h_ptr->c_vcopy.v_src)	{ret = EMOLBADPROC; break;}
+	MOLDEBUG(INTERNAL,"SRC OK endpoint=%d\n", lcl_ptr->p_usr.p_endpoint);
+
+		memcpy( &rmt_ptr->p_rmtcmd.c_vcopy, &h_ptr->c_vcopy, sizeof(vcopy_t));
+	}while(0);
+	ret = copyout_data_lcl2rmt(rmt_ptr, lcl_ptr, ret);
+	return(ret);
+}
+
+/*--------------------------------------------------------------*/
+/*			copyout_data_rmt2lcl			*/
+/* proxy sends a remote data to a local process address space  */
+/* lcl_ptr: is the requester of the copyout 			*/
+/* rmt_ptr: is the sender of the data block			*/
+/* dst_ptr: is de destination of the data block			*/
+/*--------------------------------------------------------------*/
+asmlinkage long copyout_data_rmt2lcl(struct proc *rproxy_ptr, struct proc *rmt_ptr, 
+		struct proc *lcl_ptr, proxy_hdr_t *h_ptr, proxy_payload_t *usr_pay_ptr)
+{
+	int ret;
+	struct proc *sproxy_ptr, *dst_ptr;
+	VM_desc_t *vm_ptr;
+
+	MOLDEBUG(DBGCMD,CMD_FORMAT,CMD_FIELDS(h_ptr));
+	MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+
+	if( h_ptr->c_vcopy.v_bytes <= 0 || h_ptr->c_vcopy.v_bytes > MAXCOPYLEN) {
+		ERROR_RETURN(EMOLRANGE);
+	}
+	
+	sproxy_ptr = NODE2SPROXY(rmt_ptr->p_usr.p_nodeid);
+	vm_ptr 	= &vm[lcl_ptr->p_usr.p_vmid];
+
+	dst_ptr = ENDPOINT2PTR(vm_ptr, h_ptr->c_vcopy.v_dst);
+	if( dst_ptr->p_usr.p_endpoint != lcl_ptr->p_usr.p_endpoint) {
+		WUNLOCK_PROC2(rmt_ptr, lcl_ptr);
+		WLOCK_PROC3(rmt_ptr, lcl_ptr, dst_ptr);
+	}
+	
+	do {
+		ret = OK;
+
+		if( lcl_ptr->p_usr.p_rts_flags == PROC_RUNNING) {ret= EMOLPROCRUN; break;}
+		if( dst_ptr->p_usr.p_rts_flags  == PROC_RUNNING) {ret= EMOLPROCRUN; break;}
+
+		/*check that all envolved processes are on ONCOPY state */
+		if(!test_bit(BIT_ONCOPY, &lcl_ptr->p_usr.p_rts_flags))	{ret= EMOLPROCSTS; break;}
+	    if(!test_bit(BIT_ONCOPY, &rmt_ptr->p_usr.p_rts_flags))	{ret= EMOLPROCSTS; break;}
+	    if(!test_bit(BIT_ONCOPY, &rmt_ptr->p_usr.p_rts_flags))	{ret= EMOLPROCSTS; break;}
+	}while(0);
+	if(ret == OK) {
+		if( h_ptr->c_rcode == OK)
+			COPY_USR2USR_PROC(ret, NONE, rproxy_ptr, (char *) usr_pay_ptr,
+				dst_ptr, h_ptr->c_vcopy.v_daddr, h_ptr->c_vcopy.v_bytes);
+
+		/* wake up the requester */
+		if( lcl_ptr->p_usr.p_rts_flags == ONCOPY)
+			READY_UP_RCODE(lcl_ptr, CMD_COPYOUT_DATA, h_ptr->c_rcode);
+	}
+	if( dst_ptr->p_usr.p_endpoint != lcl_ptr->p_usr.p_endpoint) {
+		WUNLOCK_PROC(dst_ptr);
+	}
+	return(ret);
+}
+
+/*--------------------------------------------------------------*/
+/*			mol_put2lcl				*/
+/* RECEIVER proxy makes an operation to a local process requested*/
+/* by a remote process						*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_put2lcl(proxy_hdr_t *usr_hdr_ptr, proxy_payload_t *usr_pay_ptr)
+{
+	VM_desc_t *vm_ptr;
+	struct proc *rmt_ptr, *lcl_ptr, *rqtr_ptr, *rproxy_ptr, *sproxy_ptr;
+	proxy_hdr_t header, *h_ptr;
+	int ret, rmt_nr, lcl_nr, vmid, ack;
+	long unsigned int *bm_ptr;
+	int rproxy_pid;
+	struct task_struct *task_ptr;	
+	cluster_node_t *node_ptr;
+	struct timespec *t_ptr;
+
+	if(current_euid() != USER_ROOT) return(-EPERM);
+
+	if( DRVS_NOT_INIT() )   return(EMOLDRVSINIT );
+
+	ret = check_lock_caller(&task_ptr, &rproxy_ptr, &rproxy_pid);
+	if(ret) ERROR_RETURN(ret);
+	
+	ret = OK;
+	/*------------------------------------------
+	  * checks the if the caller is a proxy
+	 *  and it is in the correct state 
+	  *------------------------------------------*/
+	do {
+		if( test_bit( BIT_SLOT_FREE, &rproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLPROCSTS;break;} 
+		if( !test_bit(MIS_BIT_PROXY, &rproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+		if( !test_bit(MIS_BIT_CONNECTED, &rproxy_ptr->p_usr.p_misc_flags)){ret = EMOLNOTCONN;break;}  
+		rproxy_ptr->p_umsg = (message * )usr_pay_ptr;
+	} while(0);
+	WUNLOCK_PROC(rproxy_ptr);
+	if(ret) ERROR_RETURN(ret);
+
+	/*------------------------------------------
+	 * copy the header from user space to kernel 
+	 *------------------------------------------*/
+	ret = copy_from_user(&header, usr_hdr_ptr, sizeof(proxy_hdr_t));
+	if(ret) ERROR_RETURN(ret);
+	h_ptr = &header;
+	MOLDEBUG(DBGCMD,HDR_FORMAT, HDR_FIELDS(h_ptr));
+
+	/*------------------------------------------
+ 	 * Gets the VMID
+           *------------------------------------------*/
+	vmid		= h_ptr->c_vmid;
+	MOLDEBUG(INTERNAL,"vmid=%d\n", vmid);
+	if( vmid < 0 || vmid >= drvs.d_nr_vms) 	ERROR_RETURN(EMOLBADVMID);
+	vm_ptr 	= &vm[vmid];
+
+	ret = OK;
+	lcl_nr = _ENDPOINT_P(h_ptr->c_dst);
+	rmt_nr = _ENDPOINT_P(h_ptr->c_src);
+	lcl_ptr = NULL;
+	rmt_ptr = NULL;
+
+	/*------------------------------------------
+	 * Checks if the VM is RUNNING
+	 * Locks the VM
+	 * Checks local and remote process 
+           *------------------------------------------*/	
+	WLOCK_VM(vm_ptr);
+	do {
+		if( vm_ptr->vm_usr.vm_flags) 	{ret = EMOLVMNOTRUN; break;}
+
+		if( rmt_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 
+ 	 		|| rmt_nr >= vm_ptr->vm_usr.vm_nr_procs) 
+										{ret = EMOLRANGE; break;}
+		/*Checks Destination (LOCAL)  process */
+		if( lcl_nr < (-vm_ptr->vm_usr.vm_nr_tasks) 
+   		 || lcl_nr >= vm_ptr->vm_usr.vm_nr_procs) 
+										{ret = EMOLRANGE; break;}
+										
+		/* Checks Source NODE */
+		bm_ptr = &vm_ptr->vm_usr.vm_nodes;
+		node_ptr = &node[h_ptr->c_snode];
+		if(!test_bit(h_ptr->c_snode, bm_ptr)) 				{ret = EMOLNOVMNODE; break;}
+		if( h_ptr->c_dnode != atomic_read(&local_nodeid))		{ret = EMOLBADNODEID; break;}	
+
+ 	}while(0);
+	if(ret)	{
+		WUNLOCK_VM(vm_ptr);
+		ERROR_RETURN(ret);
+	}
+
+	node_ptr->n_usr.n_rtimestamp = current_kernel_time();	
+	t_ptr = &node_ptr->n_usr.n_rtimestamp;
+	MOLDEBUG(INTERNAL,TIME_FORMAT, TIME_FIELDS(t_ptr));		
+
+	rmt_ptr  = NBR2PTR(vm_ptr, rmt_nr);
+	lcl_ptr  = NBR2PTR(vm_ptr, lcl_nr);
+
+	WLOCK_PROC2(lcl_ptr, rmt_ptr);
+	do{ 	
+		if( IT_IS_REMOTE(rmt_ptr) 
+		 && (rmt_ptr->p_usr.p_endpoint != h_ptr->c_src)) { /* AUTO - REMOTE UNBIND */
+		MOLDEBUG(INTERNAL,"AUTO REMOTE UNBIND current=%d new=%d\n", rmt_ptr->p_usr.p_endpoint, h_ptr->c_src);
+				ret = do_unbind(vm_ptr, rmt_ptr,rmt_ptr->p_usr.p_nodeid);
+				if(ret) {break;}
+		}
+		
+		if( rmt_ptr->p_usr.p_rts_flags == SLOT_FREE) { /* AUTO REMOTE BIND */
+			MOLDEBUG(INTERNAL,"AUTO REMOTE BIND endpoint=%d node=%d\n", h_ptr->c_src, h_ptr->c_snode);
+			ret = do_autobind(vm_ptr, rmt_ptr, h_ptr->c_src, h_ptr->c_snode);
+			if( ret < 0 ) {break;}
+			ret = OK;		/* because mol_bind return the process endpoint */
+		}
+		
+		if(IT_IS_LOCAL(rmt_ptr) ) 				{ret = EMOLLCLPROC; break;}
+		if( test_bit(BIT_RMTOPER, &rmt_ptr->p_usr.p_rts_flags)) {ret = EMOLENQUEUED; break;}
+		if( test_bit(BIT_SENDING, &rmt_ptr->p_usr.p_rts_flags)) {ret = EMOLENQUEUED; break;}
+		MOLDEBUG(INTERNAL,"REMOTE source OK endpoint=%d\n", rmt_ptr->p_usr.p_endpoint);		
+
+		if( IT_IS_REMOTE(lcl_ptr) ) 				{ret = EMOLRMTPROC; break;}
+		if( lcl_ptr->p_usr.p_rts_flags == SLOT_FREE)		{ret = EMOLDSTDIED; break;}
+		if( lcl_ptr->p_usr.p_endpoint != h_ptr->c_dst) 		{ret = EMOLENDPOINT; break;}
+		if( test_bit(BIT_MIGRATE, &lcl_ptr->p_usr.p_rts_flags)) {ret = EMOLMIGRATE; break;}
+		if( lcl_ptr->p_usr.p_nodeid != atomic_read(&local_nodeid)) {ret = EMOLMIGRATE; break;}
+
+		MOLDEBUG(INTERNAL,"LOCAL destination OK endpoint=%d\n", lcl_ptr->p_usr.p_endpoint);
+
+	}while(0);
+	
+	/* Acknoledge with ERROR to the REMOTE sender if it is necessary */
+	if (ret) {
+		ack = CMD_NONE;
+		sproxy_ptr = NODE2SPROXY(h_ptr->c_snode);
+		WLOCK_PROC(sproxy_ptr);
+		if( test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags)){
+			WUNLOCK_PROC(sproxy_ptr);
+			switch(h_ptr->c_cmd) {
+				case CMD_SEND_MSG:
+				case CMD_REPLY_MSG:
+				case CMD_SNDREC_MSG:
+				case CMD_NTFY_MSG:
+					ack = CMD_SEND_ACK;
+					break;
+				case CMD_COPYIN_DATA:
+					ack = CMD_COPYIN_ACK;
+					break;
+				case CMD_COPYIN_RQST:	
+					/* reply to requester, not to sender */
+					rqtr_ptr = ENDPOINT2PTR(vm_ptr, h_ptr->c_vcopy.v_rqtr);
+					if(IT_IS_LOCAL(rqtr_ptr)) {
+						ret = EMOLLCLPROC; 
+					}else{
+						ack = CMD_COPYRMT_ACK; /* change the ACK type */
+						error_lcl2rmt(ack, rqtr_ptr, h_ptr,  ret);
+					}
+					ack = CMD_NONE; /* Avoid sending an ACK */
+					break;
+				case CMD_COPYOUT_RQST:
+					ack = CMD_COPYOUT_DATA;
+					break;
+			
+				case CMD_COPYLCL_RQST:
+					ack = CMD_COPYLCL_ACK;
+					break;
+				case CMD_COPYRMT_RQST:
+					ack = CMD_COPYRMT_ACK;
+					break;
+				default:
+					break;
+			}
+		}else{
+			WUNLOCK_PROC(sproxy_ptr);
+		}
+		WUNLOCK_VM(vm_ptr);
+		if(ack != CMD_NONE) error_lcl2rmt(ack, rmt_ptr, h_ptr,  ret);
+		WUNLOCK_PROC2(lcl_ptr, rmt_ptr);
+		ERROR_RETURN(ret);
+	}
+
+	VM_INCREF(vm_ptr);
+	WLOCK_PROC(rproxy_ptr);
+	rproxy_ptr->p_usr.p_vmid = vm_ptr->vm_usr.vm_vmid;
+	WUNLOCK_PROC(rproxy_ptr);
+	WUNLOCK_VM(vm_ptr);
+
+	switch(h_ptr->c_cmd) {
+		/*----------------------------------------------------------------------------------------------*/
+		/*		REMOTE REQUESTS 								*/
+		/*----------------------------------------------------------------------------------------------*/
+		case CMD_SNDREC_MSG:	/* The remote process has sent a message to a local process 		*/ 
+			MOLDEBUG(INTERNAL,"CMD_SENDREC_MSG vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);
+			ret = send_rmt2lcl(CMD_SNDREC_MSG, rmt_ptr, lcl_ptr, usr_pay_ptr);
+			break;
+		case CMD_SEND_MSG:	/* The remote process has sent a message to a local process 		*/ 
+			MOLDEBUG(INTERNAL,"CMD_SEND_MSG vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);
+			ret = send_rmt2lcl(CMD_SEND_MSG, rmt_ptr, lcl_ptr, usr_pay_ptr);
+			break;
+		case CMD_REPLY_MSG: 	/*  The remote process has sent a reply message to a local process	*/
+			MOLDEBUG(INTERNAL,"CMD_REPLY_MSG vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);
+			ret = send_rmt2lcl(CMD_REPLY_MSG, rmt_ptr, lcl_ptr, usr_pay_ptr);
+			break;
+		case CMD_NTFY_MSG:	/* The remote process has sent a notify message to a local process 	*/
+			MOLDEBUG(INTERNAL,"CMD_NTFY_MSG vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);	
+			ret = notify_rmt2lcl(rmt_ptr, lcl_ptr);
+			break;
+		case CMD_COPYIN_DATA: 	/* The remote process has requested a COPYIN data into the local process space */
+			MOLDEBUG(INTERNAL,"CMD_COPYIN_DATA vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);
+			ret = copyin_data_rmt2lcl(rproxy_ptr, rmt_ptr, lcl_ptr, h_ptr, usr_pay_ptr);
+			break;
+		case CMD_COPYIN_RQST: 	/* The remote process has requested a COPYIN data into the local process space */
+			MOLDEBUG(INTERNAL,"CMD_COPYIN_RQST vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);
+			ret = copyin_rqst_rmt2lcl(rproxy_ptr, rmt_ptr, lcl_ptr, h_ptr, usr_pay_ptr);
+			break;
+		case CMD_COPYOUT_RQST: /* The remote process has requested to COPYOUT data from a local process space */
+			MOLDEBUG(INTERNAL,"CMD_COPYOUT_RQST vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);
+			ret = copyout_rqst_rmt2lcl(rproxy_ptr, rmt_ptr, lcl_ptr, h_ptr, usr_pay_ptr);
+			break;	
+		case CMD_COPYLCL_RQST: /* The remote process has requested to COPY between 2 process on the local node  */
+			MOLDEBUG(INTERNAL,"CMD_COPYLCL_RQST vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);
+			ret = copylcl_rqst_rmt2lcl(rproxy_ptr, rmt_ptr, lcl_ptr, h_ptr, usr_pay_ptr);
+			break;	
+		case CMD_COPYRMT_RQST: /* The remote process has requested to COPY between local process and other in other node  */
+			MOLDEBUG(INTERNAL,"CMD_COPYRMT_RQST vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);
+			ret = copyrmt_rqst_rmt2lcl(rproxy_ptr, rmt_ptr, lcl_ptr, h_ptr, usr_pay_ptr);
+			break;		
+		/*----------------------------------------------------------------------------------------------*/
+		/*		REMOTE ACKNOWLEGES/REPLIES 	 						*/
+		/*----------------------------------------------------------------------------------------------*/
+		case CMD_SEND_ACK: 	/* The remote process has sent a message acknowledge to local process	*/
+			MOLDEBUG(INTERNAL,"CMD_SEND_ACK vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);
+			ret = send_ack_rmt2lcl(rmt_ptr, lcl_ptr, h_ptr->c_rcode);
+			break;
+		case CMD_COPYIN_ACK: 	/* The remote process has sent COPYIN acknowledge to a local process	*/
+			MOLDEBUG(INTERNAL,"CMD_COPYIN_ACK vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);	
+			ret = copyin_ack_rmt2lcl(rmt_ptr, lcl_ptr, h_ptr->c_rcode);
+			break;
+		case CMD_COPYLCL_ACK: 	/* The remote process has sent COPYLCL acknowledge to a local process	*/
+			MOLDEBUG(INTERNAL,"CMD_COPYLCL_ACK vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);	
+			ret = copylcl_ack_rmt2lcl(rmt_ptr, lcl_ptr, h_ptr->c_rcode);
+			break;
+		case CMD_COPYOUT_DATA: /* The remote process has sent requested DATA by a local process */
+			MOLDEBUG(INTERNAL,"CMD_COPYOUT_DATA vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);
+			ret = copyout_data_rmt2lcl(rproxy_ptr, rmt_ptr, lcl_ptr, h_ptr, usr_pay_ptr);
+			break;
+		case CMD_COPYRMT_ACK: 	/* The remote process has sent COPYRMT acknowledge to a local process	*/
+			MOLDEBUG(INTERNAL,"CMD_COPYRMT_ACK vmid=%d rmt_ep=%d rmt_nr=%d lcl_ep=%d lcl_nr=%d\n"
+				,vmid, rmt_ptr->p_usr.p_endpoint, rmt_nr, lcl_ptr->p_usr.p_endpoint, lcl_nr);	
+			ret = copyrmt_ack_rmt2lcl(rmt_ptr, lcl_ptr, h_ptr->c_rcode);
+			break;
+		default:
+			ret = EMOLBADREQUEST;
+			break;
+	}
+
+	if( ret == OK) 	rproxy_ptr->p_usr.p_lclsent++;	
+	WUNLOCK_PROC2(lcl_ptr, rmt_ptr);
+
+	/* If an error acknowledge says that the remote process does not exist or it is erroneous, unbind it in local node */
+	if( h_ptr->c_cmd & CMD_ACKNOWLEDGE) { /* any kind of acknowledge message */
+		if( h_ptr->c_rcode == EMOLRMTPROC
+		 || h_ptr->c_rcode == EMOLDSTDIED
+		 || h_ptr->c_rcode == EMOLENDPOINT) {
+			WLOCK_VM(vm_ptr);
+			WLOCK_PROC(rmt_ptr);
+			do_unbind(vm_ptr, rmt_ptr, h_ptr->c_snode);
+			WUNLOCK_PROC(rmt_ptr);
+			WUNLOCK_VM(vm_ptr);
+			ret = h_ptr->c_rcode;
+		 }	
+	}  
+
+	WLOCK_PROC(rproxy_ptr);
+	rproxy_ptr->p_usr.p_vmid = (-1);
+	WUNLOCK_PROC(rproxy_ptr);
+
+	VM_DECREF(vm_ptr);
+	if(ret) ERROR_RETURN(ret);
+	return(ret);
+}
diff -Naur /home/jara/linux-2.6.32/kernel/mol-sproxy.c /usr/src/linux/kernel/mol-sproxy.c
--- /home/jara/linux-2.6.32/kernel/mol-sproxy.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-sproxy.c	2013-10-21 18:30:24.000000000 -0300
@@ -0,0 +1,439 @@
+/****************************************************************/
+/*		MINIX OVER LINUX IPC PRIMITIVES FOR PROXIES	*/
+/****************************************************************/
+
+#include "mol.h"
+#include "mol-proto.h"
+#include "mol-glo.h"
+#include "mol-macros.h"
+
+asmlinkage long mol_bind(int vmid, int pid, int proc, int nodeid);
+
+/****************************************************************/
+/****************************************************************/
+/*	FUNCTIONS FOR SENDER PROXY				*/
+/****************************************************************/
+/****************************************************************/
+
+/*--------------------------------------------------------------*/
+/*			sproxy_enqueue				*/
+/* Enqueue into the sender's proxy queue  the proc_ptr   	*/
+/* descriptor with the requester rqtr and remote        	*/
+/* operation rmtoper 						*/
+/*--------------------------------------------------------------*/
+long sproxy_enqueue(struct proc *proc_ptr)
+{
+	struct proc *sproxy_ptr;
+	proc_usr_t *p_ptr;
+	cmd_t *c_ptr;
+ 
+	p_ptr = &proc_ptr->p_usr;
+	MOLDEBUG(DBGPARAMS, PROC_USR_FORMAT, PROC_USR_FIELDS(p_ptr));
+	c_ptr = &proc_ptr->p_rmtcmd;
+	MOLDEBUG(DBGPARAMS, CMD_FORMAT, CMD_FIELDS(c_ptr));
+	
+	sproxy_ptr =  NODE2SPROXY(proc_ptr->p_rmtcmd.c_dnode);
+	WLOCK_PROC(sproxy_ptr);
+	if( sproxy_ptr->p_usr.p_rts_flags == SLOT_FREE) ERROR_WUNLOCK_PROC(sproxy_ptr, EMOLNOPROXY);
+
+	/* save the proxy pair number to simplify garbage collection */
+	proc_ptr->p_usr.p_proxy = sproxy_ptr->p_usr.p_nr;
+
+	/* enqueue the process descriptor at the TAIL of the sender proxy's caller_q */
+	list_add_tail(&proc_ptr->p_link , &sproxy_ptr->p_list);
+	p_ptr = &sproxy_ptr->p_usr;
+	MOLDEBUG(INTERNAL, PROC_USR_FORMAT, PROC_USR_FIELDS(p_ptr));
+	if( test_bit(BIT_RECEIVING, &sproxy_ptr->p_usr.p_rts_flags))  {
+		clear_bit(BIT_RECEIVING,&sproxy_ptr->p_usr.p_rts_flags);
+		if(sproxy_ptr->p_usr.p_rts_flags == 0) {
+			LOCAL_PROC_UP(sproxy_ptr, OK);
+		}
+	}
+	WUNLOCK_PROC(sproxy_ptr);	
+return(OK);
+}
+
+
+/*--------------------------------------------------------------*/
+/*			mol_get2rmt				*/
+/* proxy gets local (messages, notifies, errors, ups, data,etc  */
+/* to send to a remote processes	 			*/
+/* usr_hdr_ptr: buffer address in userspace for the header	*/
+/* usr_pay_ptr: buffer address in userspace for the payload	*/
+/*--------------------------------------------------------------*/
+asmlinkage long mol_get2rmt(proxy_hdr_t *usr_hdr_ptr, proxy_payload_t *usr_pay_ptr)
+{
+	VM_desc_t *vm_ptr;
+	struct proc *src_ptr, *dst_ptr, *xpp, *tmp_ptr,*sproxy_ptr;
+	proxy_hdr_t *h_ptr;
+	struct task_struct *task_ptr;	
+	int ret, vmid;
+	int sproxy_pid;
+	cluster_node_t *node_ptr;
+	struct timespec *t_ptr;
+	proc_usr_t *p_ptr;
+
+	MOLDEBUG(GENERIC,"\n");
+
+	if(current_euid() != USER_ROOT) ERROR_RETURN(-EPERM);
+
+	if( DRVS_NOT_INIT() )   return(EMOLDRVSINIT );
+	
+	ret = check_lock_caller(&task_ptr, &sproxy_ptr, &sproxy_pid);
+	if(ret) 	ERROR_RETURN(ret);
+
+	/*------------------------------------------
+	 * Check the status of the proxy (caller)
+         *------------------------------------------*/
+	ret = OK;
+	do {
+		if( test_bit( BIT_SLOT_FREE, &sproxy_ptr->p_usr.p_rts_flags))	{ret = EMOLPROCSTS;break;} 
+		if( !test_bit(MIS_BIT_PROXY, &sproxy_ptr->p_usr.p_misc_flags))	{ret = EMOLNOPROXY;break;} 
+		if( !test_bit(MIS_BIT_CONNECTED, &sproxy_ptr->p_usr.p_misc_flags)){ret = EMOLNOTCONN;break;}  
+	} while(0);
+	if(ret) {
+		WUNLOCK_PROC(sproxy_ptr);
+		ERROR_RETURN(ret);
+	}
+
+	/*------------------------------------------
+	 * Get the command from the proxy queue
+         *------------------------------------------*/
+	sproxy_ptr->p_umsg = (message *) usr_pay_ptr;
+	while( TRUE )	{
+		MOLDEBUG(GENERIC,"list_for_each_entry_safe\n");
+		ret = OK;
+		list_for_each_entry_safe(xpp, tmp_ptr, &sproxy_ptr->p_list, p_link) {
+			MOLDEBUG(GENERIC,"Found a message. p_endpoint=%d c_cmd=%d\n",
+				xpp->p_usr.p_endpoint,xpp->p_rmtcmd.c_cmd);
+			
+			WUNLOCK_PROC(sproxy_ptr);
+			WLOCK_PROC(xpp);
+			RLOCK_PROC(sproxy_ptr);			
+			p_ptr = &xpp->p_usr;
+			MOLDEBUG(INTERNAL, PROC_USR_FORMAT, PROC_USR_FIELDS(p_ptr));
+
+			list_del_init(&xpp->p_link); /* remove from queue */
+			
+			/* A LOCAL process descriptor must have	(SENDING | ONCOPY) set	*/
+			/* A REMOTE process descriptor must have (RMTOPER | ONCOPY) set	*/
+			/* Those flags protect them when unlocks			*/ 
+			/* RULE TO LOCK: 1st: sender, 2nd: sender proxy */
+
+			do {
+				ret= OK;
+				/*-----------------------------------
+				 * Check process descriptor status
+				 *----------------------------------*/	
+				node_ptr = &node[xpp->p_rmtcmd.c_dnode];
+				if(!test_bit(xpp->p_usr.p_vmid,&node_ptr->n_usr.n_vms)) {ret = EMOLNOVMNODE;break;}
+				if( (xpp->p_usr.p_vmid < 0 )
+				 || (xpp->p_usr.p_vmid >= drvs.d_nr_vms))		{ret = EMOLBADVMID;break;} 	
+				if( test_bit(BIT_MIGRATE, &xpp->p_usr.p_rts_flags)) 	{ret = EMOLMIGRATE; break;}
+				if(!test_bit(xpp->p_rmtcmd.c_dnode,&sproxy_ptr->p_usr.p_nodemap)) {ret = EMOLNONODE;break;}
+ 				vm_ptr 	= &vm[xpp->p_usr.p_vmid];
+				RUNLOCK_PROC(sproxy_ptr);
+				WUNLOCK_PROC(xpp);	
+				
+				/*-----------------------------------
+				 * Check VM status
+				 *----------------------------------*/	
+				RLOCK_VM(vm_ptr);
+				if(vm_ptr->vm_usr.vm_flags) {
+					RUNLOCK_VM(vm_ptr);
+					ret = EMOLVMNOTRUN; 
+				}else{
+					vmid = vm_ptr->vm_usr.vm_vmid;
+					RUNLOCK_VM(vm_ptr);
+					WLOCK_PROC(xpp);	
+					RLOCK_PROC(sproxy_ptr);
+					/* The proxy takes the sender's VMID personality */
+					sproxy_ptr->p_usr.p_vmid = vmid;
+					RUNLOCK_PROC(sproxy_ptr);
+					VM_INCREF(vm_ptr);
+				}
+			}while(0);
+			if(ret) {
+				/*-----------------------------------
+				 * For Requests (LOCAL descriptors) 
+				 * return an ACK with error
+				 *----------------------------------*/
+				xpp->p_usr.p_proxy = NONE;	
+				if(IT_IS_LOCAL(xpp)){
+					xpp->p_usr.p_rts_flags = 0;
+					READY_UP_RCODE(xpp, CMD_ACKNOWLEDGE, ret);
+				}else {
+				/*-----------------------------------
+				 * For ACKs (REMOTE descriptors) 
+				 * IGNORE
+				 *----------------------------------*/
+					xpp->p_usr.p_rts_flags = 0;
+					set_bit(BIT_REMOTE, &xpp->p_usr.p_rts_flags);
+				}
+				WUNLOCK_PROC(xpp);	
+				ERROR_RETURN(ret);
+			}
+
+			h_ptr = &xpp->p_rmtcmd;
+			ret = OK;
+
+			/*
+			* Verify MIGRATED destination PROCESS
+			* If command is SEND, SENDREC, NOTIFY, REPLY replay this commands for the local process
+			* Any ONCOPY command must be in queue because the migration checks the ONCOPY bit.
+			* Any ACK command must be in queue because the MIGRATING process is blocked on a SENDREC to its SYSTASK
+			*/
+			if( IT_IS_LOCAL(xpp) ) {
+				dst_ptr = ENDPOINT2PTR(vm_ptr, xpp->p_rmtcmd.c_dst);
+				WLOCK_ORDERED2(xpp, dst_ptr);							
+				if( h_ptr->c_dnode != dst_ptr->p_usr.p_nodeid ){ /* It means that the dest process has migrated */
+					WUNLOCK_PROC(dst_ptr);		
+					/*
+					* Wakes up the local sender proc with an EMOLMIGRATE error to REPLAY the IPC.
+					*/
+					xpp->p_usr.p_sendto 	= NONE;
+					xpp->p_usr.p_proxy 	= NONE;	
+					xpp->p_usr.p_rts_flags = 0;
+					READY_UP_RCODE(xpp, CMD_ACKNOWLEDGE, EMOLMIGRATE)
+					WUNLOCK_PROC(xpp);
+					WLOCK_PROC(sproxy_ptr); /* the proxy must be locked for the next loop 	*/
+					continue;		/* next loop of list_for_each_entry_safe 	*/	
+				}else{
+					WUNLOCK_PROC(dst_ptr);	
+				}
+			} 
+
+			xpp->p_rmtcmd.c_timestamp = current_kernel_time();
+			t_ptr = &xpp->p_rmtcmd.c_timestamp;
+			MOLDEBUG(INTERNAL,TIME_FORMAT, TIME_FIELDS(t_ptr));
+
+			if(IT_IS_REMOTE(xpp)){ 	/* REMOTE process descriptor used for ACKNOWLEDGES 	*/
+				MOLDEBUG(DBGPROC,"REMOTE " PROC_USR_FORMAT,PROC_USR_FIELDS(p_ptr));
+				switch(xpp->p_rmtcmd.c_cmd) {
+					case CMD_SEND_ACK:	/* The local receiver process send a SEND ACK to the remote sender process */
+						MOLDEBUG(GENERIC,"CMD_SEND_ACK\n");
+						break;
+					case CMD_COPYIN_ACK:	
+						MOLDEBUG(GENERIC,"CMD_COPYIN_ACK\n");
+						MOLDEBUG(DBGVCOPY,CMD_FORMAT,CMD_FIELDS(h_ptr));
+						MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+						vm_ptr 	= &vm[xpp->p_usr.p_vmid];
+						src_ptr = ENDPOINT2PTR(vm_ptr, xpp->p_rmtcmd.c_vcopy.v_dst);
+						/* Other  process could be in the same slot  */
+						/*!! the source of the ACK was the destination of the COPY !!*/
+						WLOCK_ORDERED2(xpp, src_ptr);							
+						if(src_ptr->p_usr.p_endpoint == xpp->p_rmtcmd.c_src) {
+							clear_bit(BIT_ONCOPY, &src_ptr->p_usr.p_rts_flags);
+						}else{
+							ret = EMOLBADPROC;
+						}
+						WUNLOCK_PROC(src_ptr);
+						break;
+					case CMD_COPYOUT_DATA:	/* the remote process has requested to send local data */
+						MOLDEBUG(GENERIC,"CMD_COPYOUT_DATA\n");
+						MOLDEBUG(DBGVCOPY,CMD_FORMAT,CMD_FIELDS(h_ptr));
+						MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+						/*  Copy the payload from source's user space to proxy's user space */
+						vm_ptr 	= &vm[xpp->p_usr.p_vmid];
+						src_ptr = ENDPOINT2PTR(vm_ptr, xpp->p_rmtcmd.c_vcopy.v_src);
+						WLOCK_ORDERED2(xpp, src_ptr);
+						/* Other  process could be in the same slot  */
+						/*!! the source of the DATA is the source of the COPY !!*/
+						if(src_ptr->p_usr.p_endpoint == xpp->p_rmtcmd.c_src) {
+							if( xpp->p_rmtcmd.c_rcode == OK){	
+								COPY_USR2USR_PROC(ret, NONE, src_ptr, xpp->p_rmtcmd.c_vcopy.v_saddr, 
+									sproxy_ptr, (char*) usr_pay_ptr, xpp->p_rmtcmd.c_vcopy.v_bytes);
+							}	
+							clear_bit(BIT_ONCOPY, &src_ptr->p_usr.p_rts_flags);
+						}else{
+							ret = EMOLBADPROC;
+						}
+						WUNLOCK_PROC(src_ptr);
+						break;
+					case CMD_COPYIN_RQST:
+						MOLDEBUG(GENERIC,"CMD_COPYIN_RQST\n");
+						MOLDEBUG(DBGVCOPY,CMD_FORMAT,CMD_FIELDS(h_ptr));
+						MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+						/*  Copy the payload from source's user space to proxy's user space */
+						vm_ptr 	= &vm[xpp->p_usr.p_vmid];
+						src_ptr = ENDPOINT2PTR(vm_ptr, xpp->p_rmtcmd.c_vcopy.v_src);
+						WLOCK_ORDERED2(xpp, src_ptr);	
+						/* Other  process could be in the same slot  */
+						/*!! the source of the RQST is the source of the COPY !!*/
+						if(src_ptr->p_usr.p_endpoint == xpp->p_rmtcmd.c_src) {
+							COPY_USR2USR_PROC(ret, NONE, src_ptr, xpp->p_rmtcmd.c_vcopy.v_saddr, 
+										sproxy_ptr, (char*) usr_pay_ptr, xpp->p_rmtcmd.c_vcopy.v_bytes);
+							clear_bit(BIT_ONCOPY, &src_ptr->p_usr.p_rts_flags);
+							clear_bit(BIT_ONCOPY, &xpp->p_usr.p_rts_flags);
+						}else{
+							ret = EMOLBADPROC;
+						}
+						WUNLOCK_PROC(src_ptr);
+						break;
+					case CMD_COPYLCL_ACK:	
+						MOLDEBUG(GENERIC,"CMD_COPYLCL_ACK\n");
+						MOLDEBUG(DBGVCOPY,CMD_FORMAT,CMD_FIELDS(h_ptr));
+						MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+						vm_ptr 	= &vm[xpp->p_usr.p_vmid];
+						src_ptr = ENDPOINT2PTR(vm_ptr, xpp->p_rmtcmd.c_vcopy.v_src);				
+						WLOCK_ORDERED2(xpp, src_ptr);						
+						/* Other  process could be in the same slot  */
+						/* !!! The source of the ACK was the source of the copy  !!!*/
+						if( src_ptr->p_usr.p_endpoint == xpp->p_rmtcmd.c_src) {
+							clear_bit(BIT_ONCOPY, &src_ptr->p_usr.p_rts_flags);
+							clear_bit(BIT_ONCOPY, &xpp->p_usr.p_rts_flags);
+						}else{
+							ret = EMOLBADPROC;
+						}
+						WUNLOCK_PROC(src_ptr);
+						break;
+					case CMD_COPYRMT_ACK:	
+						MOLDEBUG(GENERIC,"CMD_COPYRMT_ACK\n");
+						MOLDEBUG(DBGVCOPY,CMD_FORMAT,CMD_FIELDS(h_ptr));
+						MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+						vm_ptr 	= &vm[xpp->p_usr.p_vmid];
+						src_ptr = ENDPOINT2PTR(vm_ptr, xpp->p_rmtcmd.c_vcopy.v_src);				
+						dst_ptr = ENDPOINT2PTR(vm_ptr, xpp->p_rmtcmd.c_vcopy.v_dst);
+						WUNLOCK_PROC(xpp);
+						WLOCK_PROC3(xpp, src_ptr, dst_ptr);	
+						/* Other  process could be in the same slot  */
+						/*!!! the source of the ACK was the destination of the copy !!!*/
+						if( (dst_ptr->p_usr.p_endpoint == xpp->p_rmtcmd.c_src) 
+						 && (xpp->p_usr.p_endpoint == xpp->p_rmtcmd.c_vcopy.v_rqtr)){		
+							clear_bit(BIT_ONCOPY, &src_ptr->p_usr.p_rts_flags);
+							clear_bit(BIT_ONCOPY, &dst_ptr->p_usr.p_rts_flags);
+							clear_bit(BIT_ONCOPY, &xpp->p_usr.p_rts_flags);
+						}else{
+							ret = EMOLBADPROC;
+						}			
+						WUNLOCK_PROC2(src_ptr, dst_ptr);
+						break;			
+					default:
+						ret = EMOLINVAL;
+						break;
+				}
+				if(ret) {
+					xpp->p_usr.p_rts_flags = 0;
+					set_bit(BIT_REMOTE, &xpp->p_usr.p_rts_flags);
+					WUNLOCK_PROC(xpp);
+
+					WLOCK_PROC(sproxy_ptr);
+					sproxy_ptr->p_usr.p_vmid = (-1);
+					WUNLOCK_PROC(sproxy_ptr);
+
+					VM_DECREF(vm_ptr);
+					ERROR_RETURN(ret);
+				}
+				clear_bit(BIT_SENDING, &xpp->p_usr.p_rts_flags);
+				clear_bit(BIT_RMTOPER, &xpp->p_usr.p_rts_flags);
+				xpp->p_usr.p_sendto	= NONE;
+			}else { 	/* the LOCAL process need to send a MINIX message to remote  */
+				MOLDEBUG(DBGPROC,"LOCAL " PROC_USR_FORMAT,PROC_USR_FIELDS(p_ptr));
+				clear_bit(BIT_RMTOPER, &xpp->p_usr.p_rts_flags);
+				switch(xpp->p_rmtcmd.c_cmd) {
+					case CMD_COPYIN_DATA:
+						MOLDEBUG(GENERIC,"CMD_COPYIN_DATA\n");
+						MOLDEBUG(DBGVCOPY,CMD_FORMAT,CMD_FIELDS(h_ptr));
+						MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+						/*  Copy the payload from source's user space to proxy's user space */
+						vm_ptr 	= &vm[xpp->p_usr.p_vmid];
+						src_ptr = ENDPOINT2PTR(vm_ptr, xpp->p_rmtcmd.c_vcopy.v_src);
+						/*!! the source of the REQUEST is the source of the COPY !!*/				
+						if(src_ptr != xpp) { 
+							WLOCK_ORDERED2(xpp, src_ptr);
+							COPY_USR2USR_PROC(ret, NONE, src_ptr, h_ptr->c_vcopy.v_saddr, 
+								sproxy_ptr, (char*) usr_pay_ptr, h_ptr->c_vcopy.v_bytes);
+							WUNLOCK_PROC(src_ptr);
+						} else {
+							COPY_USR2USR_PROC(ret, NONE, src_ptr, h_ptr->c_vcopy.v_saddr, 
+								sproxy_ptr, (char*) usr_pay_ptr, h_ptr->c_vcopy.v_bytes);		
+						}
+						break;
+					case CMD_COPYOUT_RQST:
+						MOLDEBUG(GENERIC,"CMD_COPYOUT_RQST\n");
+						MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+						break;		
+					case CMD_COPYLCL_RQST:
+						MOLDEBUG(GENERIC,"CMD_COPYLCL_RQST\n");
+						MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+						break;
+					case CMD_COPYRMT_RQST:
+						MOLDEBUG(GENERIC,"CMD_COPYRMT_RQST\n");
+						MOLDEBUG(DBGVCOPY,VCOPY_FORMAT,VCOPY_FIELDS(h_ptr));
+						break;
+					case CMD_SNDREC_MSG:
+						MOLDEBUG(GENERIC,"CMD_SNDREC_MSG\n");
+						xpp->p_usr.p_sendto = NONE;
+						clear_bit(BIT_SENDING, &xpp->p_usr.p_rts_flags);
+					case CMD_SEND_MSG:
+						MOLDEBUG(GENERIC,"CMD_SEND_MSG\n");
+//						COPY_TO_USER_PROC(ret, &xpp->p_message, usr_pay_ptr, sizeof(message));
+						COPY_USR2USR_PROC(ret, xpp->p_usr.p_endpoint, xpp, (char *)xpp->p_umsg, 
+								sproxy_ptr, (char*) usr_pay_ptr,  sizeof(message));
+						break;
+					case CMD_REPLY_MSG:
+						MOLDEBUG(GENERIC,"CMD_REPLY_MSG\n");
+//						COPY_TO_USER_PROC(ret, &xpp->p_message, usr_pay_ptr, sizeof(message));
+						COPY_USR2USR_PROC(ret, xpp->p_usr.p_endpoint, xpp, (char *)xpp->p_umsg, 
+								sproxy_ptr, (char*) usr_pay_ptr,  sizeof(message));
+						break;
+					case CMD_NTFY_MSG:
+						MOLDEBUG(GENERIC,"CMD_NTFY_MSG\n");
+						xpp->p_usr.p_sendto 	= NONE;
+						clear_bit(BIT_SENDING, &xpp->p_usr.p_rts_flags);
+						if(xpp->p_usr.p_rts_flags == 0) 			
+							LOCAL_PROC_UP(xpp, ret);
+						break;
+					default:
+						ret = EMOLINVAL;
+						break;
+				}
+				xpp->p_usr.p_proxy = NONE;
+				if(ret) {
+					xpp->p_usr.p_rts_flags = 0;
+					READY_UP_RCODE(xpp, CMD_ACKNOWLEDGE, ret);
+					WUNLOCK_PROC(xpp);
+					VM_DECREF(vm_ptr);
+
+					WLOCK_PROC(sproxy_ptr);
+					sproxy_ptr->p_usr.p_vmid = (-1);
+					WUNLOCK_PROC(sproxy_ptr);
+
+					ERROR_RETURN(ret);
+				}
+
+			}
+
+			MOLDEBUG(DBGCMD,HDR_FORMAT,HDR_FIELDS(h_ptr));
+
+			/*  Copy the header to user space proxy */
+			COPY_TO_USER_PROC(ret, h_ptr, usr_hdr_ptr, sizeof(proxy_hdr_t));
+			xpp->p_rmtcmd.c_cmd 	= CMD_NONE;
+			xpp->p_usr.p_proxy 	= NONE;
+			WUNLOCK_PROC(xpp);
+
+			WLOCK_PROC(sproxy_ptr);
+			sproxy_ptr->p_usr.p_getfrom = NONE;
+			node_ptr->n_usr.n_stimestamp = current_kernel_time();
+			sproxy_ptr->p_usr.p_rmtsent++;
+			sproxy_ptr->p_usr.p_vmid = (-1);
+			WUNLOCK_PROC(sproxy_ptr);
+
+			VM_DECREF(vm_ptr);
+			return(OK);
+		}
+		
+		sproxy_ptr->p_usr.p_getfrom = ANY;
+		set_bit(BIT_RECEIVING, &sproxy_ptr->p_usr.p_rts_flags);
+		MOLDEBUG(GENERIC,"Any message was not found.\n");
+		ret = sleep_proc(sproxy_ptr, HELLO_PERIOD); 			/* SLEEP THE PROXY 	*/
+		MOLDEBUG(GENERIC,"Someone wakes up the sender proxy\n");
+		if(ret != OK) {
+			WUNLOCK_PROC(sproxy_ptr);
+			ERROR_RETURN(ret);
+		}
+	}
+}	
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/mol_syscall_table_32.S /usr/src/linux/kernel/mol_syscall_table_32.S
--- /home/jara/linux-2.6.32/kernel/mol_syscall_table_32.S	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol_syscall_table_32.S	2013-09-29 18:49:46.000000000 -0300
@@ -0,0 +1,27 @@
+ENTRY(mol_sys_call_table)
+	.long mol_vm_init			/* 0 */
+/* Standard MINIX IPC functions that match MINIX IPC numbers */
+	.long mol_mini_send		/* 1 */
+	.long mol_mini_receive		/* 2 */
+	.long mol_mini_sendrec		/* 3 */ 
+	.long mol_mini_notify		/* 4 */ 
+/* void functions, funct# < 8 that can be used in the future */
+	.long mol_void			/* 5 */
+	.long mol_void			/* 6 */
+	.long mol_void			/* 7 */
+/* VMM system calls, funct# >= 8 to use a mask */
+	.long mol_vm_end			/* 8 */
+	.long mol_bind			/* 9 */
+	.long mol_unbind			/* 10 */
+	.long mol_vm_dump			/* 11 */
+	.long mol_proc_dump		/* 12 */
+	.long mol_getep			/* 13 get endpoint */
+	.long mol_setpriv		/* 14 seg priviledges */
+	.long mol_vcopy			/* 15 copy data between user-user or user-kernel */
+	.long mol_getvmtab		/* 16 */
+	.long mol_getproctab		/* 17 */
+	.long mol_void			/* 18- used for mol_rmtbind */
+	.long mol_mini_relay			/* 19 */
+
+
+
diff -Naur /home/jara/linux-2.6.32/kernel/mol-utils.c /usr/src/linux/kernel/mol-utils.c
--- /home/jara/linux-2.6.32/kernel/mol-utils.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/kernel/mol-utils.c	2014-06-30 20:28:24.000000000 -0300
@@ -0,0 +1,904 @@
+/****************************************************************/
+/*			MOL UTILITIES				*/
+/****************************************************************/
+
+#include "mol.h"
+#include "mol-proto.h"
+#include "mol-glo.h"
+#include "mol-macros.h"
+
+
+asmlinkage int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,
+		pmd_t *dst_pmd, pmd_t *src_pmd, struct vm_area_struct *vma,
+		unsigned long addr, unsigned long end);
+
+		
+proc_t *get_sproxy(int nodeid) 
+{
+
+	cluster_node_t *n_ptr;
+	proxies_t *px_ptr;
+	proc_t *sproxy_ptr;
+
+	n_ptr = &node[nodeid];
+	RLOCK_NODE(n_ptr);
+	px_ptr = &proxies[n_ptr->n_usr.n_proxies];
+	RUNLOCK_NODE(n_ptr);
+
+	RLOCK_PROXY(px_ptr);
+	sproxy_ptr = &px_ptr->px_sproxy;
+	RUNLOCK_PROXY(px_ptr);
+	
+	return(sproxy_ptr);
+} 
+		
+proc_t *get_rproxy(int nodeid) 
+{
+
+	cluster_node_t *n_ptr;
+	proxies_t *px_ptr;
+	proc_t *rproxy_ptr;
+
+	n_ptr = &node[nodeid];
+	RLOCK_NODE(n_ptr);
+	px_ptr = &proxies[n_ptr->n_usr.n_proxies];
+	RUNLOCK_NODE(n_ptr);
+
+	RLOCK_PROXY(px_ptr);
+	rproxy_ptr = &px_ptr->px_rproxy;
+	RUNLOCK_PROXY(px_ptr);
+	
+	return(rproxy_ptr);
+} 
+
+/*--------------------------------------------------------------*/
+/*			check_lock_caller			*/
+/* Checks if the caller is a thread. Checks if it is		*/
+/* binded or its main thread is binded				*/
+/* ON OUTPUT: 							*/
+/*   if ret==OK; caller_ptr is WRITE LOCKED			*/			
+/*	*c_ptr = caller_ptr;					*/
+/*	*t_ptr = task_ptr;					*/
+/*	*c_pid = caller_pid;					*/
+/*--------------------------------------------------------------*/
+
+int check_lock_caller(struct task_struct **t_ptr, struct proc **c_ptr, int *c_pid)
+{
+	int ret;
+	struct task_struct *task_ptr;
+	struct proc *caller_ptr;
+	int  caller_pid, caller_tgid;
+	proc_usr_t *s_ptr;
+
+	task_ptr = current;
+	caller_pid  = current->pid;
+	caller_tgid = current->tgid;
+	MOLDEBUG(DBGPARAMS,"caller_pid=%d caller_tgid=%d\n", 
+		caller_pid, caller_tgid);
+	ret = OK;
+	do {
+//		if(caller_pid == caller_tgid) {	/* task_ptr it is a MAIN thread 	*/
+		if( thread_group_leader(task_ptr)){ /* Caller is the Group Leader */
+			caller_ptr = (struct proc *) task_ptr->proc_ptr;
+			if( caller_ptr == NULL){		/* The main thread is not binded 	*/
+				task_ptr = current;			
+				ret = EMOLNOTBIND;
+				break;
+			}
+		}else {					/* Caller is NOT the Group Leader */	
+			caller_ptr = (struct proc *)current->proc_ptr;
+			if( caller_ptr == NULL){			/* The child thread is not binded */
+				task_ptr= task_ptr->group_leader;
+				if( task_ptr == NULL) {			/* the Group Leader has dead */
+					task_ptr = current;
+					ret = EMOLBADPROC;	
+					break;
+				}	
+				caller_ptr = (struct proc *) task_ptr->proc_ptr;
+				if(caller_ptr == NULL){			/* The main thread is not binded */
+					ret = EMOLNOTBIND;
+					break;
+				}else{
+					caller_pid = task_ptr->tgid;	/* Use the main thread binding	*/	
+				}
+			}
+		}
+	}while(0);
+
+	/* The VM administrator has set the need to migrate for this process */
+	if( ret)  ERROR_RETURN(ret);
+
+	WLOCK_PROC(caller_ptr);
+	
+	if( test_bit(MIS_BIT_NEEDMIGR, &caller_ptr->p_usr.p_misc_flags)){
+		s_ptr = &caller_ptr->p_usr;
+		MOLDEBUG(INTERNAL,PROC_USR_FORMAT,PROC_USR_FIELDS(s_ptr));
+		clear_bit(MIS_BIT_NEEDMIGR, &caller_ptr->p_usr.p_misc_flags);
+		set_bit(BIT_MIGRATE, &caller_ptr->p_usr.p_rts_flags);
+	}
+	
+	if (test_bit(BIT_MIGRATE, &caller_ptr->p_usr.p_rts_flags)) {
+		sleep_proc(caller_ptr, TIMEOUT_FOREVER);
+		ret = caller_ptr->p_rcode;
+		if(ret) {
+			WUNLOCK_PROC(caller_ptr);
+			ERROR_RETURN(ret);
+		}
+	}
+
+	*c_ptr = caller_ptr;
+	*t_ptr = task_ptr;
+	*c_pid = caller_pid;
+	MOLDEBUG(DBGPARAMS,"caller_pid=%d \n", caller_pid);
+
+	return(OK);
+}
+
+
+
+/*----------------------------------------------------------------*/
+/*			init_proc_desc				*/
+/* !!! On input and output the VM mutex must be locked !!!	*/
+/*----------------------------------------------------------------*/
+void init_proc_desc(struct proc *proc_ptr, int vmid, int index)
+{
+	int j;
+	VM_desc_t *vm_ptr;
+
+	MOLDEBUG(INTERNAL,"p_name=%s vmid=%d\n",proc_ptr->p_usr.p_name, vmid);
+
+	/*Suppose that the vmid has been checked before */
+	if( vmid == PROXY_NO_VM) {
+		proc_ptr->p_usr.p_nr 	= index;		/* proxies struct index */
+	}else{
+		vm_ptr = &vm[vmid];
+		proc_ptr->p_usr.p_nr 	= (index-(vm_ptr->vm_usr.vm_nr_tasks));
+		for (j=0; j< BITMAP_CHUNKS(drvs.d_nr_sysprocs); j++) {
+	      		proc_ptr->p_priv.s_notify_pending.chunk[j] = 0;	
+	      		proc_ptr->p_priv.s_usr.s_ipc_from.chunk[j] = 0;	
+	      		proc_ptr->p_priv.s_usr.s_ipc_to.chunk[j] = 0;	
+		}
+	}
+
+	proc_ptr->p_priv.s_usr.s_id	   		= 0;
+	proc_ptr->p_priv.s_usr.s_warn	   	= NONE;
+	proc_ptr->p_priv.s_usr.s_level     	= USER_PRIV;
+	proc_ptr->p_priv.s_usr.s_trap_mask 	= 0;
+	proc_ptr->p_priv.s_usr.s_call_mask 	= 0;
+
+	proc_ptr->p_priv.s_int_pending		= 0;
+	proc_ptr->p_priv.s_sig_pending		= 0;
+
+	proc_ptr->p_usr.p_vmid 				= vmid;
+	proc_ptr->p_usr.p_lpid 				= PROC_NO_PID;
+	proc_ptr->p_usr.p_rts_flags 		= SLOT_FREE;
+	proc_ptr->p_usr.p_misc_flags 		= GENERIC_PROC;
+	proc_ptr->p_usr.p_nodeid 			= (-1);			/* OLD: atomic_read(&local_nodeid); */
+	proc_ptr->p_usr.p_nodemap 			= 0;
+
+	proc_ptr->p_rcode 					= OK;	
+		
+	memset(&proc_ptr->p_message,0,sizeof(message));
+	proc_ptr->p_umsg	= NULL;
+
+	proc_ptr->p_usr.p_getfrom			= NONE;
+	proc_ptr->p_usr.p_sendto			= NONE;
+	proc_ptr->p_usr.p_waitmigr			= NONE;
+	proc_ptr->p_usr.p_proxy				= NONE;
+
+	/* Sets the process CPU affinity */
+	cpumask_setall(&proc_ptr->p_usr.p_cpumask);
+	
+	init_waitqueue_head(&proc_ptr->p_wqhead);		/* Initialize the wait queue 		*/
+	proc_ptr->p_pseudosem 				= 0;				/* pseudo semaphore			*/
+
+	
+	INIT_LIST_HEAD(&proc_ptr->p_list);
+	INIT_LIST_HEAD(&proc_ptr->p_link);
+
+	INIT_LIST_HEAD(&proc_ptr->p_mlist);
+	INIT_LIST_HEAD(&proc_ptr->p_mlink);
+	
+	proc_ptr->p_rmtcmd.c_cmd	= CMD_NONE;
+	proc_ptr->p_rmtcmd.c_vmid	= vmid;
+	proc_ptr->p_rmtcmd.c_src 	= NONE;	
+	proc_ptr->p_rmtcmd.c_dst 	= NONE;
+	proc_ptr->p_rmtcmd.c_snode 	= LOCALNODE;	
+	proc_ptr->p_rmtcmd.c_dnode	= LOCALNODE;
+	proc_ptr->p_rmtcmd.c_len	= 0;
+	proc_ptr->p_rmtcmd.c_rcode	= OK;
+
+	proc_ptr->p_rmtcmd.c_vcopy.v_src	= NONE;
+	proc_ptr->p_rmtcmd.c_vcopy.v_dst	= NONE;
+	proc_ptr->p_rmtcmd.c_vcopy.v_rqtr	= NONE;
+	proc_ptr->p_rmtcmd.c_vcopy.v_saddr	= NULL;
+	proc_ptr->p_rmtcmd.c_vcopy.v_daddr	= NULL;
+	proc_ptr->p_rmtcmd.c_vcopy.v_bytes	= 0;
+
+
+	proc_ptr->p_usr.p_lclsent		= 0;			/* counter of LOCAL sent messages	*/
+	proc_ptr->p_usr.p_rmtsent		= 0;			/* counter of REMOTE sent messages	*/
+
+	proc_ptr->p_name_ptr 		= NULL;				
+	strcpy(proc_ptr->p_usr.p_name, "$noname");
+
+//	init_timer(&proc_ptr->p_timer);
+
+	proc_ptr->p_task = NULL; 
+
+#if MOLPROFILING != 0
+	for( j = 0; j < MAX_PROF; j++)
+		proc_ptr->p_profiling[j] = 0;
+#endif
+
+}
+/*------------------------------------------------------*/
+/*			inherit_cpu				*/
+/*------------------------------------------------------*/
+void inherit_cpu(struct proc *proc_ptr)
+{
+	int cpuid, ret;
+	cpumask_t tmp_cpumask;
+	proc_usr_t *pu_ptr;	
+	
+	cpuid = get_cpu();
+	MOLDEBUG(INTERNAL, "cpuid=%d\n", cpuid );
+	cpumask_clear(&tmp_cpumask);
+	cpumask_set_cpu(cpuid, &tmp_cpumask);
+	if ( (ret = sched_setaffinity(proc_ptr->p_usr.p_lpid, &tmp_cpumask)))
+			ERROR_PRINT(ret);	
+	put_cpu();
+
+	pu_ptr = &proc_ptr->p_usr;
+	MOLDEBUG(INTERNAL, PROC_CPU_FORMAT, PROC_CPU_FIELDS(pu_ptr));
+
+}
+
+/****************************************************************
+ *  Copy a block of data from Userspace to Userspace	
+*****************************************************************/
+
+long copy_usr2usr(int source, struct proc *src_proc, char *src_addr, struct proc *dst_proc, char *dst_addr, int bytes)
+{
+	struct page *src_pg;
+	struct page *dst_pg;
+	void *saddr = NULL;
+	void *daddr = NULL;
+	unsigned long src_off;
+	unsigned long dst_off;
+	int 	src_npag, dst_npag;	/* number of pages the  copy implies*/
+	int ret = OK;
+	int len, slen, dlen;
+	message *m_ptr;
+
+MOLDEBUG(DBGPARAMS,"source=%d src_pid=%d dst_pid=%d bytes=%d\n", 
+		source, src_proc->p_usr.p_lpid, dst_proc->p_usr.p_lpid, bytes);
+ 
+	if( bytes < 0 || bytes  > MAXCOPYLEN) ERROR_RETURN(EMOLRANGE);
+
+	src_off  = (long int) src_addr & (~PAGE_MASK);
+	dst_off  = (long int) dst_addr & (~PAGE_MASK);
+MOLDEBUG(INTERNAL,"src_off=%ld dst_off=%ld\n",src_off, dst_off);
+
+/***************** SUPERFLOUS - CAN BE REMOVED ***********/
+	src_npag = (src_off+bytes+PAGE_SIZE-1)>>PAGE_SHIFT;
+	dst_npag = (dst_off+bytes+PAGE_SIZE-1)>>PAGE_SHIFT;
+MOLDEBUG(INTERNAL,"src_npag=%d dst_npag=%d\n",src_npag, dst_npag);
+
+	while( bytes > 0) {
+
+		down_read(&src_proc->p_task->mm->mmap_sem);
+		ret = get_user_pages(src_proc->p_task, src_proc->p_task->mm,
+         			(unsigned long)src_addr, 1, 1, 0, &src_pg, NULL);
+		up_read(&src_proc->p_task->mm->mmap_sem);
+		if (ret != 1) ERROR_RETURN(EMOLADDRNOTAVAIL);
+MOLDEBUG(INTERNAL,"get_user_pages SRC OK\n");
+ 
+		down_read(&dst_proc->p_task->mm->mmap_sem);
+		ret = get_user_pages(dst_proc->p_task, dst_proc->p_task->mm,
+     	         	(unsigned long)dst_addr, 1, 1, 0, &dst_pg, NULL);
+		up_read(&dst_proc->p_task->mm->mmap_sem);
+		if (ret != 1) ERROR_RETURN(EMOLADDRNOTAVAIL);
+MOLDEBUG(INTERNAL,"get_user_pages DST OK\n");
+
+		saddr = kmap_atomic(src_pg, KM_USER0);
+MOLDEBUG(INTERNAL,"kmap_atomic SRC OK\n");
+		daddr = kmap_atomic(dst_pg, KM_USER0);
+MOLDEBUG(INTERNAL,"kmap_atomic DST OK\n");
+
+		slen = PAGE_SIZE-src_off;
+		dlen = PAGE_SIZE-dst_off;
+		len = min(slen,dlen);
+		len = min(len,bytes);
+
+		if( len == PAGE_SIZE) {
+	    		copy_page(daddr , saddr);
+MOLDEBUG(INTERNAL,"copy_page %d bytes\n", len);
+
+		}else{
+	    		memcpy((daddr + dst_off), (saddr + src_off), len);
+MOLDEBUG(INTERNAL,"memcpy %d bytes\n", len);
+		}
+
+		/*fill the message sender field */
+		if( (source != NONE) && (bytes == sizeof(message))) {
+MOLDEBUG(INTERNAL,"source=%d bytes=%d\n", source, bytes);
+			m_ptr = (message *) (daddr + dst_off);
+			m_ptr->m_source = source;
+		}
+
+		kunmap_atomic(saddr, KM_USER0);
+MOLDEBUG(INTERNAL,"kunmap_atomic SRC OK\n");
+		kunmap_atomic(daddr, KM_USER0);
+MOLDEBUG(INTERNAL,"kunmap_atomic DST OK\n");
+		set_page_dirty_lock(dst_pg);
+MOLDEBUG(INTERNAL,"set_page_dirty_lock OK\n");
+     	put_page(dst_pg);
+MOLDEBUG(GENERIC,"put_page DST OK\n");
+     	put_page(src_pg);
+MOLDEBUG(GENERIC,"put_page SRC OK\n");
+
+		src_addr+=len;
+		dst_addr+=len;		
+		src_off  = (long int) src_addr & (~PAGE_MASK);
+		dst_off  = (long int) dst_addr & (~PAGE_MASK);
+MOLDEBUG(INTERNAL,"src_off=%ld dst_off=%ld\n",src_off, dst_off);
+		bytes=bytes-len;
+	}
+
+return(OK);
+}
+
+/****************************************************************
+ *  Sleep process proc waiting for an event 
+ *  On entry: process must be Write LOCKED
+ *  On exit: process is Write LOCKED
+ *  the result is in proc->p_rcode
+*****************************************************************/
+int sleep_proc(struct proc *proc, long timeout) 
+{
+	proc_usr_t *pu_ptr; 
+	int rcode = OK;
+	int ret = OK;
+
+	MOLDEBUG(INTERNAL,"timeout=%ld\n", timeout); 
+
+	if( timeout == TIMEOUT_NOWAIT) {
+		if( test_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags)){
+			clear_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags);
+			set_bit(BIT_MIGRATE, &proc->p_usr.p_rts_flags);
+		}
+		proc->p_rcode = EMOLAGAIN; 
+		return(EMOLAGAIN);
+	}
+	
+	MOLDEBUG(INTERNAL,"BEFORE DOWN lpid=%d p_sem=%d timeout=%ld\n",proc->p_usr.p_lpid,proc->p_pseudosem, timeout); 
+	proc->p_pseudosem = -1; 
+	WUNLOCK_PROC(proc); 	
+	MOLDEBUG(INTERNAL,"endpoint=%d flags=%lX\n",proc->p_usr.p_endpoint, proc->p_usr.p_rts_flags); 
+
+	if( timeout < 0) {
+		ret = wait_event_interruptible(proc->p_wqhead, (proc->p_pseudosem >= 0));
+	} else {
+		ret = wait_event_interruptible_timeout(proc->p_wqhead, 
+			(proc->p_pseudosem >= 0),msecs_to_jiffies(timeout));
+		if(ret > 0) ret = OK;
+		else if (ret == 0) ret = EMOLTIMEDOUT;
+		else ret = (-ERESTARTSYS);
+	}
+	MOLDEBUG(INTERNAL,"endpoint=%d flags=%lX cpuid=%d\n",proc->p_usr.p_endpoint, proc->p_usr.p_rts_flags, smp_processor_id());  
+	WLOCK_PROC(proc); 
+	
+	if( ret) {
+	MOLDEBUG(INTERNAL,"pid=%d ret=%d\n",current->pid, ret);  
+		if(proc->p_pseudosem < 0) proc->p_pseudosem++; 
+//		del_timer_sync(&proc->p_timer);
+		proc->p_rcode = ret; 
+		if( timeout < 0) {
+			while(test_bit(BIT_ONCOPY, &proc->p_usr.p_rts_flags)) {
+				WUNLOCK_PROC(proc);
+				schedule();
+				WLOCK_PROC(proc);
+			}	
+		}
+	}
+
+	if( test_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags)){
+		clear_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags);
+		set_bit(BIT_MIGRATE, &proc->p_usr.p_rts_flags);
+	}
+
+	/* reset the process CPU mask */
+	if ( (rcode = sched_setaffinity(proc->p_usr.p_lpid, &proc->p_usr.p_cpumask)))
+			ERROR_PRINT(rcode);	
+
+	pu_ptr = &proc->p_usr;
+	MOLDEBUG(INTERNAL, PROC_CPU_FORMAT, PROC_CPU_FIELDS(pu_ptr));
+	
+	MOLDEBUG(INTERNAL,"someone wakeups me: sem=%d p_rcode=%d\n",proc->p_pseudosem, proc->p_rcode);
+	return(ret);
+}
+
+/****************************************************************
+ *  Sleep process proc waiting for an event 
+ *  On entry: processes proc and other must be Write LOCKED
+ *  On exit: process is Write LOCKED
+ *  the result is in proc->p_rcode
+*****************************************************************/
+int sleep_proc2(struct proc *proc, struct proc *other , long timeout)  
+{
+	proc_usr_t *pu_ptr; 
+	int ret = OK;
+	int rcode = OK;
+
+	if( timeout == TIMEOUT_NOWAIT) {
+		if( test_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags)){
+			clear_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags);
+			set_bit(BIT_MIGRATE, &proc->p_usr.p_rts_flags);
+		}
+		proc->p_rcode = EMOLAGAIN; 
+		return(EMOLAGAIN);
+	}
+	
+MOLDEBUG(INTERNAL,"BEFORE DOWN lpid=%d p_sem=%d timeout=%ld\n",proc->p_usr.p_lpid, proc->p_pseudosem, timeout); 
+	proc->p_pseudosem = -1; 
+	WUNLOCK_PROC2(proc, other); 
+MOLDEBUG(INTERNAL,"endpoint=%d flags=%lX\n",proc->p_usr.p_endpoint, proc->p_usr.p_rts_flags); 
+
+	if( timeout < 0) {
+		ret = wait_event_interruptible(proc->p_wqhead, (proc->p_pseudosem >= 0));
+	} else {
+		ret = wait_event_interruptible_timeout(proc->p_wqhead, 
+			(proc->p_pseudosem >= 0),msecs_to_jiffies(timeout));
+		if(ret > 0) ret = OK;
+		else if (ret == 0) ret = EMOLTIMEDOUT;
+		else ret = (-ERESTARTSYS);
+	}
+
+	MOLDEBUG(INTERNAL,"endpoint=%d flags=%lX cpuid=%d\n",proc->p_usr.p_endpoint, proc->p_usr.p_rts_flags, smp_processor_id());  
+	WLOCK_PROC2(proc, other); 
+	
+	if( ret) {
+MOLDEBUG(INTERNAL,"pid=%d ret=%d\n",current->pid, ret);  
+		if(proc->p_pseudosem < 0) proc->p_pseudosem++; 
+//		del_timer_sync(&proc->p_timer);
+		proc->p_rcode = ret; 
+		if( timeout < 0) {
+			while(test_bit(BIT_ONCOPY, &proc->p_usr.p_rts_flags)) {
+				WUNLOCK_PROC2(proc, other);
+				schedule();
+				WLOCK_PROC2(proc, other);
+			}	
+		}
+	}
+
+	if( test_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags)){
+		clear_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags);
+		set_bit(BIT_MIGRATE, &proc->p_usr.p_rts_flags);
+	}
+	
+	/* reset the process CPU mask */
+	if ( (rcode = sched_setaffinity(proc->p_usr.p_lpid, &proc->p_usr.p_cpumask)))
+			ERROR_PRINT(rcode);	
+			
+	pu_ptr = &proc->p_usr;
+	MOLDEBUG(INTERNAL, PROC_CPU_FORMAT, PROC_CPU_FIELDS(pu_ptr));
+	
+MOLDEBUG(INTERNAL,"someone wakeups me: sem=%d p_rcode=%d\n",proc->p_pseudosem, proc->p_rcode);
+	return(ret);
+}
+
+/****************************************************************
+ *  Sleep process proc waiting for an event 
+ *  On entry: processes proc and other must be Write LOCKED
+ *  On exit: process is Write LOCKED
+ *  the result is in proc->p_rcode
+*****************************************************************/
+int sleep_proc3(struct proc *proc, struct proc *other1, struct proc *other2 , long timeout) 
+{
+	proc_usr_t *pu_ptr; 
+	int ret = OK;
+	int rcode = OK;
+
+	if( timeout == TIMEOUT_NOWAIT) {
+		if( test_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags)){
+			clear_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags);
+			set_bit(BIT_MIGRATE, &proc->p_usr.p_rts_flags);
+		}
+		proc->p_rcode = EMOLAGAIN; 
+		return(EMOLAGAIN);
+	}
+	
+	proc->p_rcode = OK; 
+MOLDEBUG(INTERNAL,"BEFORE DOWN lpid=%d p_sem=%d\n",proc->p_usr.p_lpid,proc->p_pseudosem); 
+	proc->p_pseudosem = -1; 
+	WUNLOCK_PROC3(proc, other1, other2); 
+MOLDEBUG(INTERNAL,"endpoint=%d flags=%lX\n",proc->p_usr.p_endpoint, proc->p_usr.p_rts_flags);  
+	if( timeout < 0) {
+		ret = wait_event_interruptible(proc->p_wqhead, (proc->p_pseudosem >= 0));
+	} else {
+		ret = wait_event_interruptible_timeout(proc->p_wqhead, 
+			(proc->p_pseudosem >= 0),msecs_to_jiffies(timeout));
+		if(ret > 0) ret = OK;
+		else if (ret == 0) ret = EMOLTIMEDOUT;
+		else ret = (-ERESTARTSYS);
+	}
+	MOLDEBUG(INTERNAL,"endpoint=%d flags=%lX cpuid=%d\n",proc->p_usr.p_endpoint, proc->p_usr.p_rts_flags, smp_processor_id());  
+	WLOCK_PROC3(proc, other1, other2); 
+	if( ret) {
+MOLDEBUG(INTERNAL,"pid=%d ret=%d\n",current->pid, ret);  
+		if(proc->p_pseudosem < 0) proc->p_pseudosem = 0; 
+//		del_timer_sync(&proc->p_timer);
+		proc->p_rcode = ret; 
+		while(test_bit(BIT_ONCOPY, &proc->p_usr.p_rts_flags)) {
+			WUNLOCK_PROC3(proc, other1, other2);
+			schedule();
+			WLOCK_PROC3(proc, other1, other2);
+		}
+	}
+
+	if( test_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags)){
+		clear_bit(MIS_BIT_NEEDMIGR, &proc->p_usr.p_misc_flags);
+		set_bit(BIT_MIGRATE, &proc->p_usr.p_rts_flags);
+	}
+	
+	/* reset the process CPU mask */
+	if ( (rcode = sched_setaffinity(proc->p_usr.p_lpid, &proc->p_usr.p_cpumask)))
+			ERROR_PRINT(rcode);	
+			
+	pu_ptr = &proc->p_usr;
+	MOLDEBUG(INTERNAL, PROC_CPU_FORMAT, PROC_CPU_FIELDS(pu_ptr));
+	
+	MOLDEBUG(INTERNAL,"someone wakeups me: sem=%d p_rcode=%d\n",proc->p_pseudosem, proc->p_rcode);
+	return(ret);
+}
+
+
+/*===========================================================================*
+ *				bm2ascii		 			   				     *
+ *===========================================================================*/
+void bm2ascii(char *buf, unsigned long int bitmap)
+{
+	int i;
+	unsigned long int mask;
+
+	mask = 0x80000000; 
+	for( i = 0; i < BITMAP_BITS ; i++) {
+		*buf++ = (bitmap & mask)?'X':'-';
+		mask =  (mask >> 1);		
+	}
+	*buf = '\0';
+}
+
+/*===========================================================================*
+ *				clear_node		 		     *
+ *===========================================================================*/
+void clear_node(cluster_node_t *n_ptr)
+{
+	strcpy(n_ptr->n_usr.n_name,"NONAME");
+	n_ptr->n_usr.n_flags 	= NODE_FREE;
+	n_ptr->n_usr.n_vms   	= 0;
+	n_ptr->n_usr.n_proxies 	= NO_PROXIES;
+	n_ptr->n_usr.n_stimestamp.tv_sec = 0;
+	n_ptr->n_usr.n_stimestamp.tv_nsec = 0;
+	n_ptr->n_usr.n_rtimestamp.tv_sec = 0;
+	n_ptr->n_usr.n_rtimestamp.tv_nsec = 0;
+}
+/*===========================================================================*
+ *				init_node		 		     *
+ *===========================================================================*/
+void init_node(int nodeid)
+{
+	cluster_node_t *n_ptr;
+
+	n_ptr = &node[nodeid];
+	n_ptr->n_usr.n_nodeid 	= nodeid;
+
+	clear_node(n_ptr);
+
+#if LOCK_NODE_TYPE == USE_NODE_RWLOCK
+	rwlock_init(&(n_ptr->n_rwlock));
+#else	/* USE_PROC_MUTEX*/
+	mutex_init(&(n_ptr->n_mutex));
+#endif
+
+}
+
+/*===========================================================================*
+ *				clear_proxies		 					     *
+ *===========================================================================*/
+void clear_proxies(proxies_t *px_ptr)
+{
+	struct proc *sproxy_ptr, *rproxy_ptr;
+
+	px_ptr->px_usr.px_flags = PROXIES_FREE;
+	sproxy_ptr = &px_ptr->px_sproxy;
+	rproxy_ptr = &px_ptr->px_rproxy;
+	init_proc_desc(sproxy_ptr, PROXY_NO_VM, px_ptr->px_usr.px_id);
+	init_proc_desc(rproxy_ptr, PROXY_NO_VM, px_ptr->px_usr.px_id);
+	sproxy_ptr->p_usr.p_rts_flags	= SLOT_FREE;
+	rproxy_ptr->p_usr.p_rts_flags	= SLOT_FREE;
+	strcpy(px_ptr->px_usr.px_name, "NONAME");
+
+}
+
+/*===========================================================================*
+ *				init_proxies		 		     *
+ *===========================================================================*/
+void init_proxies(int px_nr)
+{
+	proxies_t *px_ptr;
+	struct proc *sproxy_ptr, *rproxy_ptr;
+	
+	px_ptr = &proxies[px_nr];
+	px_ptr->px_usr.px_id = px_nr;
+	sproxy_ptr = &px_ptr->px_sproxy;
+	rproxy_ptr = &px_ptr->px_rproxy;
+	clear_proxies(px_ptr);
+
+	sproxy_ptr->p_pseudosem 	= 1;
+	rproxy_ptr->p_pseudosem 	= 1;
+
+#if LOCK_PROXY_TYPE == USE_PROXY_RWLOCK
+	rwlock_init(&(px_ptr->px_rwlock));
+#else	/* USE_PROC_MUTEX*/
+	mutex_init(&(px_ptr->px_mutex));
+#endif
+
+
+#if LOCK_PROC_TYPE == USE_PROC_RWLOCK
+	rwlock_init(&(sproxy_ptr->p_rwlock));
+	rwlock_init(&(rproxy_ptr->p_rwlock));
+#else	/* USE_PROC_MUTEX*/
+	mutex_init(&(sproxy_ptr->p_mutex));
+	mutex_init(&(rproxy_ptr->p_mutex));
+#endif
+
+}
+
+/*--------------------------------------------------------------*/
+/*			kill_unbind				*/
+/* src_proc->p_task is locked 					*/
+/* VM is unlocked						*/
+/* src_proc & dst_proc are unlocked 				*/
+/*--------------------------------------------------------------*/
+long kill_unbind(struct proc *dst_ptr, struct proc *src_ptr)
+{
+	int dst_ep, src_ep, ret = OK;
+	message m, *m_ptr;
+
+	m_ptr = &m;
+	m_ptr->m_type   = MOLEXIT;
+	dst_ep = dst_ptr->p_usr.p_endpoint;
+	src_ep = src_ptr->p_usr.p_endpoint;
+MOLDEBUG(INTERNAL,"dst_ep=%d src_ep=%d\n",dst_ep, src_ep);
+//	ret = kernel_sendrec(dst_ep, m_ptr);	
+
+	if(ret) ERROR_RETURN(ret);
+	return(ret);
+}
+
+/*--------------------------------------------------------------*/
+/*			flush_sending_procs			*/
+/* The proxy has finished or the remote node is NOT CONNECTED 	*/
+/* wakeup with error all process trying to send a CMD to REMOTE */
+/* sproxy_ptr must be LOCKED	 				*/
+/*--------------------------------------------------------------*/
+long flush_sending_procs(int nodeid,  struct proc *sproxy_ptr)
+{
+	struct proc *src_ptr, *tmp_ptr;
+
+MOLDEBUG(INTERNAL,"SPROXY wakeup with error all process trying to send a CMD to node=%d\n",  sproxy_ptr->p_usr.p_nodeid);
+
+	list_for_each_entry_safe(src_ptr, tmp_ptr, &sproxy_ptr->p_list, p_link) {
+		/* RULE TO LOCK: 1st: sender, 2nd: sender proxy */
+		WUNLOCK_PROC(sproxy_ptr);
+		WLOCK_PROC(src_ptr); 
+		if( src_ptr->p_rmtcmd.c_dnode != nodeid) {
+			WUNLOCK_PROC(src_ptr);
+		 	continue;
+		}
+		WLOCK_PROC(sproxy_ptr);
+
+		list_del(&src_ptr->p_link); /* remove from queue */
+		src_ptr->p_usr.p_proxy = NONE;
+		clear_bit(BIT_RMTOPER, &src_ptr->p_usr.p_rts_flags);
+
+MOLDEBUG(INTERNAL,"Find process %d trying to send a CMD\n",src_ptr->p_usr.p_endpoint);
+		if( IT_IS_REMOTE(src_ptr)) {	/* Acknowledges to remote process */		
+			src_ptr->p_usr.p_rts_flags = REMOTE; 
+			src_ptr->p_usr.p_getfrom = NONE;
+			src_ptr->p_usr.p_sendto = NONE;
+		} else {
+MOLDEBUG(INTERNAL,"Wakeup SENDER with error ep=%d  pid=%d\n",src_ptr->p_usr.p_endpoint, src_ptr->p_usr.p_lpid);	
+			switch(src_ptr->p_rmtcmd.c_cmd) {
+				case CMD_SNDREC_MSG:
+					clear_bit(BIT_RECEIVING, &src_ptr->p_usr.p_rts_flags);
+					src_ptr->p_usr.p_getfrom = NONE;
+				case CMD_SEND_MSG:
+				case CMD_NTFY_MSG:
+				case CMD_REPLY_MSG:
+					clear_bit(BIT_SENDING, &src_ptr->p_usr.p_rts_flags);
+					src_ptr->p_usr.p_sendto = NONE;
+					break;
+				case CMD_COPYIN_DATA:
+				case CMD_COPYIN_RQST:
+				case CMD_COPYLCL_RQST:
+				case CMD_COPYRMT_RQST:
+					if(test_bit(BIT_ONCOPY, &src_ptr->p_usr.p_rts_flags)){
+						/* Only the requester of a VCOPY CMD must be waked up */
+						if( src_ptr->p_usr.p_endpoint == src_ptr->p_rmtcmd.c_vcopy.v_rqtr) 
+							clear_bit(BIT_ONCOPY, &src_ptr->p_usr.p_rts_flags);
+					}
+					break;
+				default:
+					WUNLOCK_PROC(src_ptr); 
+					ERROR_RETURN(EMOLBADREQUEST);			
+					break;
+				}
+			if(src_ptr->p_usr.p_rts_flags == 0) 
+				LOCAL_PROC_UP(src_ptr, EMOLNOTCONN);
+		}
+		WUNLOCK_PROC(src_ptr); 
+	}
+	return(OK);
+}
+
+/*--------------------------------------------------------------*/
+/*			flush_receiving_procs			*/
+/* A remote node is disconnected: wake up with error all 	*/
+/* processes waiting some operation from processes in that node	*/
+/* rproxy_ptr must be LOCKED	 				*/
+/*--------------------------------------------------------------*/
+long flush_receiving_procs(int nodeid, struct proc *rproxy_ptr)
+{	
+	int v, i;
+	VM_desc_t *vm_ptr;
+	struct proc *src_ptr, *dst_ptr, *tmp_ptr;
+	proc_usr_t *pu_ptr;
+
+MOLDEBUG(INTERNAL,"RPROXY search for process of all VMs waiting an action from a remote process with the node dead\n");
+	for( v = 0; v < drvs.d_nr_vms; v++) {
+		vm_ptr 	= &vm[v];
+
+		WLOCK_VM(vm_ptr);
+		if( vm_ptr->vm_usr.vm_flags != 0) {
+			WUNLOCK_VM(vm_ptr);
+			continue;
+		}
+
+		WUNLOCK_PROC(rproxy_ptr);
+		LOCK_ALL_PROCS(vm_ptr, tmp_ptr, i);
+		WLOCK_PROC(rproxy_ptr);
+
+		FOR_EACH_PROC(vm_ptr, i) {
+			tmp_ptr = VM_PROC(vm_ptr,i);
+
+			if( tmp_ptr->p_usr.p_rts_flags == SLOT_FREE) 	continue;
+			if( IT_IS_REMOTE(tmp_ptr))				continue;
+			tmp_ptr->p_rcode = EMOLNOTCONN;
+				
+			/*A local process is trying to receive a message from a remote process with the node dead */
+			do {
+				if( test_bit(BIT_RECEIVING, &tmp_ptr->p_usr.p_rts_flags)) {
+					if( (tmp_ptr->p_usr.p_getfrom != ANY) 
+						&&(tmp_ptr->p_usr.p_getfrom != NONE)){
+						src_ptr = ENDPOINT2PTR(vm_ptr, tmp_ptr->p_usr.p_getfrom);
+						if( nodeid == src_ptr->p_usr.p_nodeid) {
+							pu_ptr = &tmp_ptr->p_usr;
+							MOLDEBUG(DBGPROC,"Clean receiving " PROC_USR_FORMAT, PROC_USR_FIELDS(pu_ptr));
+							clear_bit(BIT_RECEIVING, &tmp_ptr->p_usr.p_rts_flags);
+							if( tmp_ptr->p_usr.p_rts_flags == PROC_RUNNING)
+								LOCAL_PROC_UP(tmp_ptr, EMOLNOTCONN);
+						}
+					}	
+				}
+			}while(0);
+				
+			/* A local process has sent a message to a remote process and waiting for the acknowledge but the node dead  */
+			do {
+				if( test_bit(BIT_SENDING, &tmp_ptr->p_usr.p_rts_flags)) {
+					if( (tmp_ptr->p_usr.p_sendto != ANY) 
+						&&(tmp_ptr->p_usr.p_sendto != NONE)){
+						dst_ptr = ENDPOINT2PTR(vm_ptr, tmp_ptr->p_usr.p_sendto);
+						if( nodeid == dst_ptr->p_usr.p_nodeid) {
+							pu_ptr = &tmp_ptr->p_usr;
+							MOLDEBUG(DBGPROC,"Clean sending " PROC_USR_FORMAT, PROC_USR_FIELDS(pu_ptr));
+							clear_bit(BIT_SENDING, &tmp_ptr->p_usr.p_rts_flags);
+							if( tmp_ptr->p_usr.p_rts_flags == PROC_RUNNING)
+								LOCAL_PROC_UP(tmp_ptr, EMOLNOTCONN);	
+						}
+					}	
+				}
+			}while(0);
+				
+			/* A local process has sent a COPY CMD to a remote process and waiting for the acknowledge but the node dead */
+			do {
+				if( test_bit(BIT_ONCOPY, &tmp_ptr->p_usr.p_rts_flags)) {
+					if(tmp_ptr->p_usr.p_endpoint == tmp_ptr->p_rmtcmd.c_vcopy.v_rqtr) {
+						if( nodeid == tmp_ptr->p_rmtcmd.c_dnode) {
+							pu_ptr = &tmp_ptr->p_usr;
+							MOLDEBUG(DBGPROC,"Clean oncopy " PROC_USR_FORMAT, PROC_USR_FIELDS(pu_ptr));
+							clear_bit(BIT_ONCOPY, &tmp_ptr->p_usr.p_rts_flags);
+							if( tmp_ptr->p_usr.p_rts_flags == PROC_RUNNING) 
+								LOCAL_PROC_UP(tmp_ptr, EMOLNOTCONN);
+						}	
+					}	
+				}
+			}while(0);			
+		}
+
+		WUNLOCK_PROC(rproxy_ptr);
+		UNLOCK_ALL_PROCS(vm_ptr, tmp_ptr, i);
+		WUNLOCK_VM(vm_ptr);
+		WLOCK_PROC(rproxy_ptr);
+	}
+	return(OK);
+}
+
+#ifdef MOLAUTOFORK
+/*--------------------------------------------------------------*/
+/*			fork_bind				*/
+/* the parent of a process send a MOLGETPROCNR message to PM	*/
+/* the PM returns the child_nr 					*/
+/* the parent bind the child to the kernel			*/
+/* the parent of a process send a MOLFORK message to PM		*/
+/* On return, PM and SYSTASK have registered the child 		*/
+/*--------------------------------------------------------------*/
+struct proc* fork_bind(struct proc *proc_ptr, int child_lpid)
+{
+	struct proc *warn_ptr, *child_ptr;
+	int src_ep, ret, vmid, warn_ep, child_ep, child_nr, child_pid;
+	message m, *m_ptr;
+	VM_desc_t *vm_ptr;
+
+MOLDEBUG(DBGLVL1,"parent_ep=%d child_lpid=%d \n",proc_ptr->p_usr.p_endpoint, child_lpid);
+
+	vmid = proc_ptr->p_usr.p_vmid;
+MOLDEBUG(DBGLVL1,"vmid=%d\n", vmid);
+	if( vmid < 0 || vmid >= drvs.d_nr_vms) 	return(NULL);
+	vm_ptr 	= &vm[vmid];
+	if( vm_ptr->vm_usr.vm_flags)  		return(NULL);
+
+	/* Gets the endpoint of the binder   (i.e. PM) */
+	warn_ep = proc_ptr->p_priv.s_usr.s_warn;
+	if( warn_ep == NONE || warn_ep == ANY || warn_ep == SELF) 
+						return(NULL); 
+	warn_ptr = ENDPOINT2PTR(vm_ptr,warn_ep);
+	src_ep = proc_ptr->p_usr.p_endpoint;
+MOLDEBUG(DBGLVL1,"src_ep=%d warn_ep=%d \n",src_ep, warn_ep);
+
+	/* Request to PM the next proc number */
+	m_ptr = &m;
+	m_ptr->m_type  = MOLFREEPROC;
+	ret = kernel_sendrec(warn_ep, m_ptr);	
+	if(ret) 				return(NULL);
+	child_nr = m_ptr->PR_SLOT;
+MOLDEBUG(DBGLVL1,"child_nr=%d\n",child_nr);
+	if( child_nr < 0 || child_nr > vm_ptr->vm_usr.vm_nr_procs)
+						return(NULL);
+
+	child_ep = kernel_lclbind(vmid, child_lpid, child_nr);
+	if(child_ep < 0) 			return(NULL);
+MOLDEBUG(DBGLVL1,"child_ep=%d\n",child_ep);
+
+	/* BIND the child into PM */
+	m_ptr->m_type   = MOLFORK;
+	m_ptr->PR_PID   = child_lpid;	/* LINUX PID */
+	m_ptr->PR_SLOT  = child_nr;		/* PREVIOUS assigned  child_nr */		
+	m_ptr->PR_ENDPT = NONE;
+	ret = kernel_sendrec(warn_ep, m_ptr);	
+	if(ret) 				return(NULL);
+	if( m_ptr->PR_ENDPT == NONE)		return(NULL);
+	child_pid = m_ptr->PR_PID;		/* MINIX PID */
+	child_ep  = m_ptr->PR_ENDPT;
+
+	child_ptr = ENDPOINT2PTR(vm_ptr,child_ep);
+
+MOLDEBUG(DBGLVL1,"child_pid(minix)=%d child_ep=%d \n",child_pid, child_ep);
+
+	return(child_ptr);	
+}
+
+#endif /*MOLAUTOFORK */
+
diff -Naur /home/jara/linux-2.6.32/Module.symvers /usr/src/linux/Module.symvers
--- /home/jara/linux-2.6.32/Module.symvers	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/Module.symvers	2014-03-01 13:47:50.000000000 -0300
@@ -0,0 +1,5716 @@
+0x00000000	tipc_get_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_rx_assoc	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_reset_card	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_pmp_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_splice_write	vmlinux	EXPORT_SYMBOL
+0x00000000	set_anon_super	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__cond_resched_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_wake_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_put_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_class_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_sense_key_string	vmlinux	EXPORT_SYMBOL
+0x00000000	request_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	unblock_all_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_block_bearer	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	hwmon_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_end_rq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	csum_partial	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_queue_stopped	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwscan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwscan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmap_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_register	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_end_command	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_execute	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	raw_seq_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_install_notify_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_hash_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_add_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_uts_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__inet6_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_release	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_store	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_bus_start	vmlinux	EXPORT_SYMBOL
+0x00000000	ioread32be	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_map_sector_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_update_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_initialize_rcv_mss	vmlinux	EXPORT_SYMBOL
+0x00000000	net_enable_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	sockfd_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_tf_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_load_table	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_validate_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	__unregister_chrdev	vmlinux	EXPORT_SYMBOL
+0x00000000	directly_mappable_cdev_bdi	vmlinux	EXPORT_SYMBOL
+0x00000000	_read_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tipc_register_media	vmlinux	EXPORT_SYMBOL
+0x00000000	g_token_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_get_command	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_eh_device_reset_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_quiesce	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_next_hole	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_videomode_to_var	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_to_user	vmlinux	EXPORT_SYMBOL
+0x00000000	default_wake_function	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_sdp_port_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_attr_link_power_management_policy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_clean	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_free_page_array	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_read_config_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	iget_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_get_timestampns	vmlinux	EXPORT_SYMBOL
+0x00000000	class_interface_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iowrite8_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	key_type_keyring	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_modify_configuration	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_release_transport	vmlinux	EXPORT_SYMBOL
+0x00000000	class_interface_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_encode_netobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_decode_word	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_md5_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_power_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	reset_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_bus_list_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_last	vmlinux	EXPORT_SYMBOL
+0x00000000	memmove	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_string	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_declare_coherent_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_alloc_space	vmlinux	EXPORT_SYMBOL
+0x00000000	laptop_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	end_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_direct_write	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_agp_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	fiemap_check_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_readonly_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ipv6_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_autopm_get_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_get_mem_page	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_map_mem_page	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_pci_find_root	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_map_rom	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_shash_final	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_final	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_copychunks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwfreq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwfreq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_setting_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_table_header	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_insert_page	vmlinux	EXPORT_SYMBOL
+0x00000000	register_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_tcp4	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_socketpair	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_dq_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_del	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_start_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_tso_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_copy_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	__krealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_free_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	task_nice	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic64_inc_and_test	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	kset_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mm_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	set_irq_chip_data	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_ms_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_proto_fini	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_scr_write_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_miter_start	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_may_read	vmlinux	EXPORT_SYMBOL
+0x00000000	iomap_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idle_nomwait	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_card_free	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_mode_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_stop_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_class	vmlinux	EXPORT_SYMBOL
+0x00000000	load_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_set_hw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_year_days	vmlinux	EXPORT_SYMBOL
+0x00000000	input_unregister_polled_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ehci_cf_port_reset_rwsem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_link_offline	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_host_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_connector_detach_encoder	vmlinux	EXPORT_SYMBOL
+0x00000000	add_timer_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_unregister_socket	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_pci_check_simplex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_slots_kset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitrev16	vmlinux	EXPORT_SYMBOL
+0x00000000	free_dma	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_init_decode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_mon_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_is_sas_rphy	vmlinux	EXPORT_SYMBOL
+0x00000000	device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aead_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iw_handler_set_thrspy	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_add	vmlinux	EXPORT_SYMBOL
+0x00000000	cn_del_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_l3proto_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsicam_bios_param	vmlinux	EXPORT_SYMBOL
+0x00000000	single_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_quota_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	I_BDEV	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_unregister_irq_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_dma_map	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_undecoded_slave	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_tty_get	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_tty_set	vmlinux	EXPORT_SYMBOL
+0x00000000	security_tun_dev_create	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_stop_interrupts	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_path_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	find_or_create_page	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_hrtimeout_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_sg_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_sg_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_buffer_unmap_sg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_phy_add	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_reset_provider	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_range_reserved	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qtree_release_dquot	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_twsk_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_extd_sense_format	vmlinux	EXPORT_SYMBOL
+0x00000000	num_registered_fb	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_uevent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_buf_from_iov	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pccard_get_first_tuple	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_write_config_dword	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_wait_peripheral	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_hung_up_p	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_child	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_cleanup_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_setlease	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_to_ieee80211_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_is_keyboard_id	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_list_add_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_walk_resources	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_enable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_set_periodic_freq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_driver_release_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_timing_merge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mpage_writepages	vmlinux	EXPORT_SYMBOL
+0x00000000	write_one_page	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_add_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_activate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	n_tty_ioctl_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_event_status	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsvc_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_blockdev	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_set_states	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_rfree	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	__root_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_next_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_part_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	freeze_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_processor_ffh_cstate_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_xfrm_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_kill_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	kfree_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_release	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_long	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_takedown	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_set_num_threads	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_parse_nat_setup_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfree_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_autoload_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_parent_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	efi_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_defrag	vmlinux	EXPORT_SYMBOL
+0x00000000	register_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_show_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idr_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_aio_read	vmlinux	EXPORT_SYMBOL
+0x00000000	_spin_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_wait_for_buffer_space	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_next_object	vmlinux	EXPORT_SYMBOL
+0x00000000	free_percpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	per_cpu__irq_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_mech_get_by_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_setup_caps	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_get	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateIncomp	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sigprocmask	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_send_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_ieee1284_ecp_write_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_ieee1284_epp_write_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ec_burst_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	do_mmap_pgoff	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_rmem	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_master_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_replace_cis	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_stop_tx_ba_cb_irqsafe	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_flush_all	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_device_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_acpi_gtm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_acpi_stm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_tgt_it_nexus_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	key_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_reserve_xprt_cong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlmsg_multicast_allns	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_rescan_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_tty_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	backlight_force_update	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_unicast_add	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_scsi_slave_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_bool	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_kernel_cred	vmlinux	EXPORT_SYMBOL
+0x00000000	mktime	vmlinux	EXPORT_SYMBOL
+0x00000000	system_state	vmlinux	EXPORT_SYMBOL
+0x00000000	llc_add_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	pcibios_align_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	corgibl_limit_intensity	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_next	vmlinux	EXPORT_SYMBOL
+0x00000000	del_timer_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	con_set_default_unimap	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_is_video_device	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_addr_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_core_get_reg_ofs	vmlinux	EXPORT_SYMBOL
+0x00000000	match_strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	ioctl_by_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	init_net	vmlinux	EXPORT_SYMBOL
+0x00000000	__next_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	keyring_search	vmlinux	EXPORT_SYMBOL
+0x00000000	key_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_delete_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_mapping_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__secpath_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_i2c_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_bit_function	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_route_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_get_rtab	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_set_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_dev_classify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_release_private	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_unregister_km	vmlinux	EXPORT_SYMBOL
+0x00000000	in_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ei_netdev_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_agp_unbind	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_next	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_map_user	vmlinux	EXPORT_SYMBOL
+0x00000000	unshare_fs_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tasklet_hi_schedule_first	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwrts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwrts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_conntrack_confirm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_scan	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_read_bcount_and_ireason	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_alloc_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_carrier_raised	vmlinux	EXPORT_SYMBOL
+0x00000000	__brelse	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_init_rtt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_get_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_ctx_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_interruptible_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_connect2port	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_probe_algs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_route_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sock_destruct	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_reinject	vmlinux	EXPORT_SYMBOL
+0x00000000	print_mac	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_chars_in_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_unregister_region	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_send_buf2name	vmlinux	EXPORT_SYMBOL
+0x00000000	__serio_register_port	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcds_loaded	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_irq_clear	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_pull_rcsum	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_unregister_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_claim	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__cpu_core_map	vmlinux	EXPORT_SYMBOL
+0x00000000	netpoll_trap	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_error_ret	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_remove_bridge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_gang_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	register_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_on	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_send	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_prepare_thread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_parse_options	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_unlink_expect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_write_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_gss_principal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_unlink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_in_grace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inotify_inode_is_dead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	module_refcount	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ctl_sock_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_addr_add_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	pccard_read_tuple	vmlinux	EXPORT_SYMBOL
+0x00000000	firmware_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_put_interface_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_lock_device_for_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_mc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	___pskb_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_global_new	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_std_prereset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_timing_compute	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_driver_flush_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_match_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_setup_cardbus	vmlinux	EXPORT_SYMBOL
+0x00000000	strcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	strsep	vmlinux	EXPORT_SYMBOL
+0x00000000	iomem_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_4	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_4	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_queue_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_add	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_frequency_get_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_scr_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_kfree	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fb_helper_pan_display	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_unpin	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_create	vmlinux	EXPORT_SYMBOL
+0x00000000	sb_min_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_phy_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	register_module_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_disable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serial8250_resume_port	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_input_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_request_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	pcix_set_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x00000000	del_gendisk	vmlinux	EXPORT_SYMBOL
+0x00000000	block_write_full_page	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_register_type	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_invert_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_unsigned	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_get	vmlinux	EXPORT_SYMBOL
+0x00000000	lockd_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_sync_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_mnt_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	____pagevec_lru_add	vmlinux	EXPORT_SYMBOL
+0x00000000	kunmap_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	__blockdev_direct_IO	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_end	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_route_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_addr_unsync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_zone_device_update	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_rphy_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	km_new_mapping	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_proto_range_to_nlattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lro_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_device_new	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_attach_direct	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_check_resource_conflict	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_block_bmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__symbol_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_write_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_ref_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_list	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_memcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	d_materialise_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmem_cache_free	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_name	vmlinux	EXPORT_SYMBOL
+0x00000000	file_remove_suid	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_data_from_8023	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_restore_msi_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bin2bcd	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_to_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	__request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_find_mem_region	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_detach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_memory_reserved	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_is_root_bridge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_ec_add_query_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic64_add_return	vmlinux	EXPORT_SYMBOL
+0x00000000	bdev_read_only	vmlinux	EXPORT_SYMBOL
+0x00000000	put_pages_list	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wfree	vmlinux	EXPORT_SYMBOL
+0x00000000	test_set_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	abort_exclusive_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	per_cpu__gdt_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_remap	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_inode_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_timer_bug_msg	vmlinux	EXPORT_SYMBOL
+0x00000000	input_flush_device	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	num_physpages	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_hash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strpbrk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_lseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_frag_match	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_get_str	vmlinux	EXPORT_SYMBOL
+0x00000000	cdrom_get_last_written	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_enable_interrupts	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_crtc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_find_free_region	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	leds_list_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_request_configuration	vmlinux	EXPORT_SYMBOL
+0x00000000	set_disk_ro	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_request_window	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_lock_take	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_handle_create	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_unprep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	relay_switch_subbuf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_aalg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_create_openreq_child	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_common_release	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tipc_createport	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_head	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_prepare_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_reset_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_helper_mode_fill_fb_struct	vmlinux	EXPORT_SYMBOL
+0x00000000	_read_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_pci_free	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_alloc_bioset	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_hdrlen_from_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_driver_set_configuration	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mii_ethtool_gset	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_ethtool_sset	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_cancel_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_processor_power_init_bm_check	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_l3proto_module_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_first_dynamic_bus_num	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_i2c_encoder_init	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_backend_acquire	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_msbits	vmlinux	EXPORT_SYMBOL
+0x00000000	unmap_underlying_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	krealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_irq_data	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_create	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	__invalidate_device	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_low_latency	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_midi_event_reset_encode	vmlinux	EXPORT_SYMBOL
+0x00000000	led_classdev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_qc_issue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_max_low_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_free_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_sync_file	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_read_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_idlelock_release	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_flip_buffer_push	vmlinux	EXPORT_SYMBOL
+0x00000000	pp_msgs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_get_divisor	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_init_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ktime_add_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msleep	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_async_notification	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_net_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bforget	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_reserve_space	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_add_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_unhash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_register_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unpoison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x00000000	get_random_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_off	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_exts_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_mode_option	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_peek_request	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	input_free_polled_device	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_connector_attach_encoder	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_prep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vlan_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_size	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_detachmode_crtc	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_shorten	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_scan_target	vmlinux	EXPORT_SYMBOL
+0x00000000	register_quota_format	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_arg_zero	vmlinux	EXPORT_SYMBOL
+0x00000000	remap_pfn_range	vmlinux	EXPORT_SYMBOL
+0x00000000	getnstimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_register_fixup	vmlinux	EXPORT_SYMBOL
+0x00000000	device_bind_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nvram_check_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_vpd_truncate	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	file_update_time	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_setup_blk_pc_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_uevent_env	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_entry_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	relay_file_operations	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_timer_key	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_cmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_free_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_kernel_client_dispatch	vmlinux	EXPORT_SYMBOL
+0x00000000	sound_class	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_wake_from_d3	vmlinux	EXPORT_SYMBOL
+0x00000000	filp_close	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	svcauth_gss_flavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svcauth_gss_register_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_std_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	ether_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_deregister_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__break_lease	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic64_add	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_inode_pages_range	vmlinux	EXPORT_SYMBOL
+0x00000000	force_sig	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_ieee1284_read_nibble	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_dma_max_seg_size	vmlinux	EXPORT_SYMBOL
+0x00000000	percpu_counter_batch	vmlinux	EXPORT_SYMBOL
+0x00000000	d_path	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_notifier_call_chain	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fstatat	vmlinux	EXPORT_SYMBOL
+0x00000000	sdev_evt_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_pci_setup_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	igrab	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__softnet_data	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_open_substream	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_back_from_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_check_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	warn_slowpath_null	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_l3protos	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	linkwatch_fire_event	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_device_free	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_queue_pc_tail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_install_fixed_event_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	ndisc_build_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_init_io	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_queue_upcall	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hiddev_hid_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_period_elapsed	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_x8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_write_wakeup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_read_config_word	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_append	vmlinux	EXPORT_SYMBOL
+0x00000000	pciserial_suspend_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_delayed_work_on	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wireless_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_stream_error	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_CB_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_video_get_capabilities	vmlinux	EXPORT_SYMBOL
+0x00000000	ec_write	vmlinux	EXPORT_SYMBOL
+0x00000000	memset	vmlinux	EXPORT_SYMBOL
+0x00000000	sget	vmlinux	EXPORT_SYMBOL
+0x00000000	set_irq_chip	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_dst_blackhole	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdrom_media_changed	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_hw_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	free_pages_exact	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tipc_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_mounts_for_expiry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_cpu_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_input_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic64_dec_return	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__cpu_sibling_map	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aalg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_tcf_proto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_drain	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_cdrom	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_attach_transport	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_table	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_agp_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	agp3_generic_tlbflush	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_get_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_get_status	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_get_new_above	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_get_new_above	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_am_i_supplied	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_configure_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_put	vmlinux	EXPORT_SYMBOL
+0x00000000	revalidate_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	register_shrinker	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sound_dsp	vmlinux	EXPORT_SYMBOL
+0x00000000	hwrng_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	misc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	block_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x00000000	may_umount_tree	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_portunreturnable	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_get_port	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_wait_ready	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_attr_unload_heads	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_retry_pc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_ldisc_ref	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_ioport_map	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_end_grace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mtrr_add	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_dma_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	loop_unregister_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	class_dev_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_remove_gpe_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	iget_failed	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_decode_netobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_set_tso	vmlinux	EXPORT_SYMBOL
+0x00000000	pcibios_get_irq_routing_table	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_polled_device	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_set_spd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_restore_state	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawait_range	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_trim	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_sub_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_set_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_unreg_xprt_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x00000000	mdiobus_register	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_it_nexus_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_prep_sense	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_release_selected_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	_read_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	qword_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__inet6_lookup_established	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	__nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_ecn	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_tx_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_stop_tx_ba_session	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_trdev	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_mii_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_command_size_tbl	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_sched_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_memory_wc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_wb	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_wake_pending_tasks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_unregister_action	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_bulk_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sb_parse_opts_str	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_free	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__cpu_info	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_delete_tunnel	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add_resources	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	leave_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ieee80211_get_radio_led_name	vmlinux	EXPORT_SYMBOL
+0x00000000	in6_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_header	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_expander_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_rescan_device	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_unlock_ac_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_framebuffer	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_prev	vmlinux	EXPORT_SYMBOL
+0x00000000	user_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_key_async_with_auxdata	vmlinux	EXPORT_SYMBOL
+0x00000000	down_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_parse_md5sig_option	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_queue_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	leds_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_evaluate_object	vmlinux	EXPORT_SYMBOL
+0x00000000	__const_udelay	vmlinux	EXPORT_SYMBOL
+0x00000000	__ide_pci_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	handle_sysrq	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_port_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	timespec_trunc	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_queue_work	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sockets_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_queue_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_release_global_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_quiesce	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_in_drive_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_gpe_status	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_param_first	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_select_bars	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_power_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_create_pooled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6t_unregister_table	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_new	vmlinux	EXPORT_SYMBOL
+0x00000000	__ata_ehi_push_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_unregister_ha	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_read_port_mode_page	vmlinux	EXPORT_SYMBOL
+0x00000000	con_copy_unimap	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_ref_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic64_add_negative	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u64	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qtree_write_dquot	vmlinux	EXPORT_SYMBOL
+0x00000000	block_commit_write	vmlinux	EXPORT_SYMBOL
+0x00000000	__netdev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_lock_ac_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	bcd2bin	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_get_undo_access	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_invert_tuplepr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_set_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	dput	vmlinux	EXPORT_SYMBOL
+0x00000000	is_container_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_set_sw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_createport_raw	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_proc_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_delay	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_remember_stamp	vmlinux	EXPORT_SYMBOL
+0x00000000	fill_inquiry_response	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_match_one_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_deb_timing_long	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	screen_glyph	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_free	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_sdev_device	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_pre_modeset	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_stop_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_hdrlen	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_set_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_max_busnr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_init	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sleep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_link_online	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	parport_read	vmlinux	EXPORT_SYMBOL
+0x00000000	key_type_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_match_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_idlelock_take	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic64_dec	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_segment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_add_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_host_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__copy_from_user_ll	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	get_sb_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	do_posix_clock_nosettime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_init_congestion_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_push	vmlinux	EXPORT_SYMBOL
+0x00000000	device_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_rmdir	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_file	vmlinux	EXPORT_SYMBOL
+0x00000000	free_task	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_del_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_valid_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_block_requests	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tipc_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sound_special	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_port_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_end_device_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_dir_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__getblk	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_unlink_urb_from_ep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_current_resources	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_quota_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	get_phy_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_cable_sata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_exit_thread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pagevec_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	current_kernel_time	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_cong_avoid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	print_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_set_nonroot	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_reset_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sas_queuecmd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	netpoll_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_start_copy_compat	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_alarm_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcim_iounmap_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_del_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_input_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	udplite_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_create_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_eject_card	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_restore_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_remove_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_class_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__suspend_report_result	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_tryget	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gtf_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_evaluate_reference	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_open	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_set_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	unload_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open_private	vmlinux	EXPORT_SYMBOL
+0x00000000	__supported_pte_mask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sunrpc_cache_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_gso_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_register_card_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_shift_left	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_free_space	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_mech_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	napi_skb_finish	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_run_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6t_do_table	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_std_postreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_release_transport	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_table_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	ht_destroy_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	bdevname	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_init	vmlinux	EXPORT_SYMBOL
+0x00000000	init_file	vmlinux	EXPORT_SYMBOL
+0x00000000	request_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_unregister_oss_device	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_generic_insert_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_fault_in_readable	vmlinux	EXPORT_SYMBOL
+0x00000000	module_mutex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_resume_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_config_init	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enable_subsystem	vmlinux	EXPORT_SYMBOL
+0x00000000	__cap_empty_set	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_start_tx_ba_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_register_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_process_call	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_resource	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_pcie_error_reporting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shoot_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iput	vmlinux	EXPORT_SYMBOL
+0x00000000	sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_complete_rqst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snmp_mib_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_upload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	create_proc_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_unmap_ram	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_doulongvec_ms_jiffies_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_map_lsapic	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	to_msgs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_dma_sff_timer_expiry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_pci_init_one	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_device_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_bitremap	vmlinux	EXPORT_SYMBOL
+0x00000000	register_blkdev	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_set_mnt	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_alter_reply	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_event_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_data_xfer_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_firmware_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	aer_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	key_negate_and_link	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_kill_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_firmware_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_load_tables	vmlinux	EXPORT_SYMBOL
+0x00000000	kref_get	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_unlink_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	init_dummy_netdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__netdev_alloc_page	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_inode_queue_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_msi	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_rom	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_errno	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_wake_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_write_space	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ndisc_send_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_queue_handlers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_mode_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_mode_is_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_check_available_features	vmlinux	EXPORT_SYMBOL
+0x00000000	_spin_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_waitqueue_head	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwgenie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm4_tunnel_register	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_get_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_insert_cloned_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sb_set_mnt_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_update_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_timer_deferrable_key	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_datagram_from_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	single_release	vmlinux	EXPORT_SYMBOL
+0x00000000	get_user_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_optmem_max	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_reject_msg	vmlinux	EXPORT_SYMBOL
+0x00000000	in4_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	in6_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_mode_select	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfb_copyarea	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_xor	vmlinux	EXPORT_SYMBOL
+0x00000000	__clear_user	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_want_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_softreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_acl_to_xattr	vmlinux	EXPORT_SYMBOL
+0x00000000	suspend_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	auth_unix_forget_old	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_hash_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pernet_gen_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_raw_taskfile	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_config_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_has_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iget5_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_channel_to_frequency	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_check_media	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_register_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	user_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_dir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dcache_dir_lseek	vmlinux	EXPORT_SYMBOL
+0x00000000	time_to_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	test_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_zone_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_remove_address_space_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_bus_parented	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_bh_lrus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_check_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ei_open	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_lid_notifier_register	vmlinux	EXPORT_SYMBOL
+0x00000000	register_acpi_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_aes_expand_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_splice_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_llseek_unlocked	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_read	vmlinux	EXPORT_SYMBOL
+0x00000000	mem_map	vmlinux	EXPORT_SYMBOL
+0x00000000	console_suspend_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_reg_xprt_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_l3proto_try_module_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_fix_features	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sound_midi	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inotify_find_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_mkpipe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_get_encoder_name	vmlinux	EXPORT_SYMBOL
+0x00000000	cad_pid	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_put_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_hash_frag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_component_add	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_probing_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_dev_classify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_update_format	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_setcleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	recalc_sigpending	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_proto_unique_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_mangle_udp_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_dev_find	vmlinux	EXPORT_SYMBOL
+0x00000000	edac_op_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_acpi_gtm_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_restart_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	anon_transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_part_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	recalibrate_cpu_khz	vmlinux	EXPORT_SYMBOL
+0x00000000	bad_dma_address	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_init_credcache	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	raw_seq_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_watchdog_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_iprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_create_memless	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_agp_bind_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_shift_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_bit_add_numbered_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_request_card_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap_regions_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_open	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_read_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_checksum_help	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_remove_list	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_dma_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_init	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_setup_info	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_set_default	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpuidle_pause_and_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_hsm_move	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_link_debounce	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	stop_machine	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_is_primary_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_do_set_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_unregister_matches	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_xfer_mode2mask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_inode_setattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fiemap_fill_next_extent	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_init	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_watchdog_cancel	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_shash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_authenticate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmpv6msg_statistics	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_set_sk_err	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_pci_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_add_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	downgrade_write	vmlinux	EXPORT_SYMBOL
+0x00000000	complete	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_port_freeze	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iov_iter_single_seg_count	vmlinux	EXPORT_SYMBOL
+0x00000000	__ieee80211_get_tx_led_name	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_new_stream	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_link_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_test_unit_ready	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_index	vmlinux	EXPORT_SYMBOL
+0x00000000	high_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	smp_call_function_many	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_install_table_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enter_sleep_state_prep	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_check_mem_region	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_link	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_find_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_frequency_table_put_attr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_remove_target	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_result	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_blocks_per_page	vmlinux	EXPORT_SYMBOL
+0x00000000	page_cache_async_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_cvt_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	kblockd_schedule_work	vmlinux	EXPORT_SYMBOL
+0x00000000	send_sig_info	vmlinux	EXPORT_SYMBOL
+0x00000000	iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_release_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__neigh_event_send	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_close	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_store_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	read_cache_page_async	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout_uninterruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	allow_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_global_register	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_remove_host	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_anon_super	vmlinux	EXPORT_SYMBOL
+0x00000000	clflush_cache_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm6_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_delete_from_lists	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_pio_cycle_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_pcie_error_reporting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_buf_subsegment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	each_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_put_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dgram_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fb_helper_single_fb_probe	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_exit_net	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_get	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_put	vmlinux	EXPORT_SYMBOL
+0x00000000	relay_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_copystring	vmlinux	EXPORT_SYMBOL
+0x00000000	__send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_scuttle_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	div64_u64	vmlinux	EXPORT_SYMBOL
+0x00000000	relay_close	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_reset_configuration	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dq_data_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	d_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	down_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_family	vmlinux	EXPORT_SYMBOL
+0x00000000	fib_rules_cleanup_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_rwsem	vmlinux	EXPORT_SYMBOL
+0x00000000	page_zero_new_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	fasync_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_mandatory_area	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_deschedule	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_table_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_exts_dump_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_ufo	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_alloc_send_pskb	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_port_add	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_shift_right	vmlinux	EXPORT_SYMBOL
+0x00000000	__request_module	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_register_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_inherit_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_cd_expiry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	srandom32	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netpoll_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_sgbuf_ops_page	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	qtree_read_dquot	vmlinux	EXPORT_SYMBOL
+0x00000000	set_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	km_policy_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	__first_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_find	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_proc_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_do_test_unit_ready	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_class_hash_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_dma_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	dlci_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_kernel_client_write_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__rpc_wait_for_completion_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_set_tx_ipv6_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_report_device_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sound_mixer	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwretry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwretry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_submit_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_link_abort	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_pci_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_symlink_inode_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	vunmap	vmlinux	EXPORT_SYMBOL
+0x00000000	write_cache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	refrigerator	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_tcp6	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_seq_device_new	vmlinux	EXPORT_SYMBOL
+0x00000000	do_blank_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_ext_add	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_init	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_create_kernel_client	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic64_xchg	vmlinux	EXPORT_SYMBOL
+0x00000000	task_current_syscall	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	single_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_page_dirty_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_conn_request	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_frequency_table_cpuinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_descriptor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sas_port_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_port_abort	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_wmem_min	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_syn_recv_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_find_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	__sg_free_table	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	icmp_err_convert	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_check_link	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_alloc_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_bus_get_power	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_set_power	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_add_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_hashinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_report_raw_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_aead_setauthsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nlmclnt_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fd_install	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_used_tuple	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_packet	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_internal_device_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	parport_release	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fsync_range	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_evntsel_nmi	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_midi_event_decode	vmlinux	EXPORT_SYMBOL
+0x00000000	cdrom_get_media_event	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_get_device_klist	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_put	vmlinux	EXPORT_SYMBOL
+0x00000000	apply_to_page_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	out_of_line_wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_irq_uninstall	vmlinux	EXPORT_SYMBOL
+0x00000000	__iowrite64_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_partition	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_get_dqblk	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_set_dqblk	vmlinux	EXPORT_SYMBOL
+0x00000000	kick_process	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_release_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_print_msg	vmlinux	EXPORT_SYMBOL
+0x00000000	pciserial_remove_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pciserial_resume_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_miter_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	security_sock_graft	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_proto_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vmalloc_32_user	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_pmp_qc_defer_cmd_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_scsi_change_queue_depth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_subsys	vmlinux	EXPORT_SYMBOL
+0x00000000	do_brk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_adv_win_scale	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_check_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_device_free	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_test_config_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_stdinpipe	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_next_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_init	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i8253_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	secpath_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_step	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_framebuffer_init	vmlinux	EXPORT_SYMBOL
+0x00000000	set_user_nice	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_pseudoflavor_to_service	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	splice_direct_to_actor	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_get_res	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l3proto_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l4proto_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_class_hash_grow	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close_start	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_release	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_add_before	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfulnl_log_packet	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_put_rtab	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_queuecommand	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_put	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_attr_alg2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__per_cpu_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	proto_register	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_irq_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_crtc_helper_set_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_wakeup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_pci_disabled	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_no_data_taskfile	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	check_disk_size_change	vmlinux	EXPORT_SYMBOL
+0x00000000	down_read	vmlinux	EXPORT_SYMBOL
+0x00000000	km_report	vmlinux	EXPORT_SYMBOL
+0x00000000	__napi_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_expand	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_time_to_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_phy_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_free_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_setup_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_find_logo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_softirq_done	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	d_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unregister_mc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_get_socket	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_put_socket	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_flush_done_q	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_iomap	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_morph	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_quick_get	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_port	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	percpu_counter_set	vmlinux	EXPORT_SYMBOL
+0x00000000	ioremap_nocache	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_set_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_physical_width	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_host	vmlinux	EXPORT_SYMBOL
+0x00000000	video_output_register	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_selected_regions_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	ei_start_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_host_device	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioremap_nocache	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_ssthresh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_remove_bus_device	vmlinux	EXPORT_SYMBOL
+0x00000000	iter_div_u64_rem	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_supported	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_seq_adjust_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i8042_lock_chip	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_alloc_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_search_free	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_init_once	vmlinux	EXPORT_SYMBOL
+0x00000000	__srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ip6_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_suspend_card	vmlinux	EXPORT_SYMBOL
+0x00000000	device_move	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_seq_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_clear_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_qc_prep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_core_ioremapfree	vmlinux	EXPORT_SYMBOL
+0x00000000	ns_to_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_pci_set_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_framebuffer_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_device_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_video_backlight_support	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fifo_create_dflt	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_table_init	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_effect_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	attribute_container_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_segment_boundary	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_stop_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_insert_request	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcipher_walk_virt_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	task_active_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_set_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_proto_nlattr_to_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_terminate	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_add_dynid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clock_t_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	qword_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_set_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_preallocate_pages_for_all	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ht_remove_item	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_get	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic64_dec_and_test	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap_table	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_release	vmlinux	EXPORT_SYMBOL
+0x00000000	insert_inode_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	__ipv6_isatap_ifid	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	parport_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	qtree_entry_unused	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_std_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_resume_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_num_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_put_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_latter_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nr_free_buffer_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_read_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_ro	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_memory_rw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_khz	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_physical_device	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	up_write	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_all_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	auth_domain_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_hash_release	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_cpu_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_cpu_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_prep_state_check	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_target_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_put_block	vmlinux	EXPORT_SYMBOL
+0x00000000	free_buffer_head	vmlinux	EXPORT_SYMBOL
+0x00000000	fget	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_boolean_mono_info	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_sanitize_settings	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_frequency_table_get_attr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_proc_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	match_token	vmlinux	EXPORT_SYMBOL
+0x00000000	vmtruncate	vmlinux	EXPORT_SYMBOL
+0x00000000	down_write	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_frequency_to_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_output_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsilun_to_int	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_test_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_block_super	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_remove_expectations	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_lookup_nodev	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sock_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pccard_register_pcmcia	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	kallsyms_on_each_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	work_on_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwencodeext	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_unicast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_mixer_oss_ioctl_card	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_put_request	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_full_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdrom_mode_select	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_create_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_in	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_queue_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_preallocate_free_for_all	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_port_schedule_eh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_io_min	vmlinux	EXPORT_SYMBOL
+0x00000000	mapping_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_setbufsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbhid_set_leds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serio_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	color_table	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_check_region	vmlinux	EXPORT_SYMBOL
+0x00000000	put_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	add_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	auth_unix_add_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_allocate_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	argv_split	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_add_modes_noedid	vmlinux	EXPORT_SYMBOL
+0x00000000	find_first_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_hw_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_enqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aes_set_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alg_test	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	console_conditional_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ei_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_target_state	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_symlink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_detach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	xattr_getsecurity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smp_call_function_single	vmlinux	EXPORT_SYMBOL
+0x00000000	native_read_tsc	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_free_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_duplicate	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_erase	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_busy_sleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_find_local_phy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nvram_check_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	strcasecmp	vmlinux	EXPORT_SYMBOL
+0x00000000	save_mount_options	vmlinux	EXPORT_SYMBOL
+0x00000000	clockevents_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_check	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_set_hashsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ifla_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unthrottle	vmlinux	EXPORT_SYMBOL
+0x00000000	security_socket_getpeersec_dgram	vmlinux	EXPORT_SYMBOL
+0x00000000	set_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	block_page_mkwrite	vmlinux	EXPORT_SYMBOL
+0x00000000	efi	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_spawn_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_inode_notifysecctx	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_error_remove_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_chk_prefix	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_unhash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_nat_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmi_check_system	vmlinux	EXPORT_SYMBOL
+0x00000000	mdio_bus_type	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_execute_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwtxpower	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwtxpower	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_call_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_exts_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_dev_select	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_noop_qc_prep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_object_info	vmlinux	EXPORT_SYMBOL
+0x00000000	vsscanf	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_vfs_cache_pressure	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic	vmlinux	EXPORT_SYMBOL
+0x00000000	ioremap_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	reserve_perfctr_nmi	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_set_dma_seg_boundary	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_init_one	vmlinux	EXPORT_SYMBOL
+0x00000000	__kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_irq_nested_thread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sas_port_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_irq_routing_table	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_init_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_wake_up_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ip_select_ident	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_gro_receive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sg_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_next_ht_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_ht_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_load	vmlinux	EXPORT_SYMBOL
+0x00000000	flock_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	iw_handler_get_spy	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_find_match	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_warn_lro_forwarding	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_var_to_videomode	vmlinux	EXPORT_SYMBOL
+0x00000000	memcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_for_each	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_init_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_add_pc_page	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_set_id	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_reconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_fb_helper_fill_fix	vmlinux	EXPORT_SYMBOL
+0x00000000	d_alloc_name	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_frags_finish	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_encoder_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioport_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	cont_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readdir	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_mode_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflate	vmlinux	EXPORT_SYMBOL
+0x00000000	vscnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_recount_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_quota_on	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_statfs	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_long	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_put_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_policy_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_tunnel_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_join_group	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_timing_find_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_unexpect_related	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_generic_free_gatt_table	vmlinux	EXPORT_SYMBOL
+0x00000000	ioread8_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lease_modify	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap_atomic_to_page	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_dst_ifdown	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_seq_start	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_sysdev_class	vmlinux	EXPORT_SYMBOL
+0x00000000	ioread32_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_put_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_header_cache_update	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_ratdens	vmlinux	EXPORT_SYMBOL
+0x00000000	release_and_free_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_copy_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	strncpy	vmlinux	EXPORT_SYMBOL
+0x00000000	strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	get_max_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_disabled	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_em_tree_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	fddi_type_trans	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_get_socket_by_nr	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_release_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_invert_cmaps	vmlinux	EXPORT_SYMBOL
+0x00000000	__cap_init_eff_set	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_set_portunreturnable	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_net_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_init_sg_cmd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kern_mount_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_queue_sense_rq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_dealloc_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_requeue_request	vmlinux	EXPORT_SYMBOL
+0x00000000	insert_inode_locked4	vmlinux	EXPORT_SYMBOL
+0x00000000	strndup_user	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_wb	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_update_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	pccard_nonstatic_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_bind_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pagevec_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_find_acq	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_mac_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_usual_check_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_scan_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_setup_fs_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	k8_flush_garts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tipc_isconnected	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwfrag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwfrag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_received	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_tm_to_time	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_slave_link_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_compat_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_sman_set_manager	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	allocate_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	block_prepare_write	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_netdev_mq	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_feed	vmlinux	EXPORT_SYMBOL
+0x00000000	__round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_fold	vmlinux	EXPORT_SYMBOL
+0x00000000	security_sb_clone_mnt_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_rmdir	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_shutdown_super	vmlinux	EXPORT_SYMBOL
+0x00000000	get_jiffies_64	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_port_delete_phy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_track_queue_full	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_evaluate_integer	vmlinux	EXPORT_SYMBOL
+0x00000000	init_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_readv	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sman_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ht_just_insert_please	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_link	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	ll_msgs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_buffer_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_driver_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	isa_dma_bridge_buggy	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get_real	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic_notifier_list	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	d_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	find_get_pages_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_host_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_os_write_port	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	nfsd_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ct_sip_parse_numerical_param	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	amd_unregister_ecc_decoder	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_sman_owner_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_resource_start	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_hangup	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_read	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	add_page_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_read	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_copy_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__irq_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_ntop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_pton	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	des_ekey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_irq_install	vmlinux	EXPORT_SYMBOL
+0x00000000	con_is_bound	vmlinux	EXPORT_SYMBOL
+0x00000000	key_link	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_page	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__cpu_number	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_change_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	__strncpy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_drop	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk	vmlinux	EXPORT_SYMBOL
+0x00000000	dmi_name_in_vendors	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_scan_fixups	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_warning	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_socket_list_rwsem	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_set_medium_removal	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_can_wakeup	vmlinux	EXPORT_SYMBOL
+0x00000000	keyring_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	__kill_fasync	vmlinux	EXPORT_SYMBOL
+0x00000000	profile_pc	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_service_to_auth_domain_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_resolution	vmlinux	EXPORT_SYMBOL
+0x00000000	async_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioremap_wc	vmlinux	EXPORT_SYMBOL
+0x00000000	__ps2_command	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_socket_dev_early_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_set_var	vmlinux	EXPORT_SYMBOL
+0x00000000	__nla_put	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_unplug_device	vmlinux	EXPORT_SYMBOL
+0x00000000	arch_unregister_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_sock_names	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_adjust_io_region	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_sff_prepare_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_port_mark_backlink	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_pci_rootbridge_handle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_hw_rule_add	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_show_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_find_nearest_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	async_schedule_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_file_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	dmi_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_init_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_phy_id	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_free_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_getsecctx	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get_ts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__get_user_2	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_2	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_interval_ratnum	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_deb_timing_hotplug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_get	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_put	vmlinux	EXPORT_SYMBOL
+0x00000000	map_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_shrinker	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_dev_get_saddr	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	rrrr_msgs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_setkeys	vmlinux	EXPORT_SYMBOL
+0x00000000	__check_region	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_protocol_register	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	key_task_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rate_control_register	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_protocol_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_malloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_domain_attach_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vgacon_text_force	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_get_part	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_kernel_release	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_hwdep_new	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_set_mmss	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_register_region	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_carrier_off	vmlinux	EXPORT_SYMBOL
+0x00000000	sdev_evt_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_quota_off	vmlinux	EXPORT_SYMBOL
+0x00000000	lease_get_mtime	vmlinux	EXPORT_SYMBOL
+0x00000000	sb_set_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_sk_dst_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_boolean_stereo_info	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_ieee1284_epp_read_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_to_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ieee80211_get_assoc_led_name	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_ctstoself_duration	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_write	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_tcf_proto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	register_dock_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lock_super	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_fpu	vmlinux	EXPORT_SYMBOL
+0x00000000	__class_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_os_wait_events_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	filp_open	vmlinux	EXPORT_SYMBOL
+0x00000000	get_empty_filp	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_prepare_output	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_calg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm4_prepare_output	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_link_rwlock	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_allocate_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_read_vpd	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	__free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_watchdog_init	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	parport_get_port	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_put_port	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_child_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__register_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	thaw_process	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_init_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_assign_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_spawn2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_user_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_napi_add	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_split	vmlinux	EXPORT_SYMBOL
+0x00000000	input_grab_device	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_block_til_ready	vmlinux	EXPORT_SYMBOL
+0x00000000	ioread8	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_count_auth_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_broadcast	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_board_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_error_func	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_get_hp_params	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_full_page_endio	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_file_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in_group_p	vmlinux	EXPORT_SYMBOL
+0x00000000	apic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_md5_hash_key	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_former_request	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_kill_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_intf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_lost_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dh_handler_exist	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_helper_encoder_in_use	vmlinux	EXPORT_SYMBOL
+0x00000000	set_security_override_from_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_process_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_wait_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_wait_after_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nvram_read_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_replace_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	edac_handlers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_lock_battery_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	__percpu_counter_init	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_tsc_unstable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	e820_any_mapped	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_hashinfo_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_midi_event_encode_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_bulk_transfer_sg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_task_abort	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_check_atapi_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_ioremap_bar	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	end_buffer_read_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer_pinned	vmlinux	EXPORT_SYMBOL
+0x00000000	set_cpus_allowed_ptr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_em_tree_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_for_each	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_month_days	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_calc_bus_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_register_ha	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_miter_next	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_shash_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_init_ahash_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_sock_update_bufs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_pull	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_find_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	font_vga_8x16	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_add_new_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	snmp_mib_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_start_interrupts	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_vpd_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_initialize_objects	vmlinux	EXPORT_SYMBOL
+0x00000000	scatterwalk_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_check_expire	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_boot_setup_check	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_i_uid	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_i_ino	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_global_kobject	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_register_port	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_unmount_inodes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_bitmap	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_stop_tx_ba_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_build_and_send_pkt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_gifconf	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_validate_clocks	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_rmmap_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_rng_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alg_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_rcu_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_classify8021d	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_do_dev_read_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_device_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_resource_to_address64	vmlinux	EXPORT_SYMBOL
+0x00000000	secure_ipv4_port_ephemeral	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pccard_static_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	kmalloc_caches	vmlinux	EXPORT_SYMBOL
+0x00000000	daemonize	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_malloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmpv6_send	vmlinux	EXPORT_SYMBOL
+0x00000000	put_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	put_page	vmlinux	EXPORT_SYMBOL
+0x00000000	_spin_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	timecounter_read	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_lookup_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_classdev_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_ldisc_deref	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_inode_setsecctx	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_scan_active	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_getattr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_del_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_update	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_dummy_port_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_io_min	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_claim_by_disk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nobh_truncate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	k8_nb_ids	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_generic_frame_duration	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_port_nla_policy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_set_tx_hw_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	up	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmp_send	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_hp_remove_module_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_get	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_copy_from_user_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	__virt_addr_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_update	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_deregister_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_grab_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpuset_mem_spread_node	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_APIC_eilvt_ibs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_udp_rmem_min	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_open	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_cards	vmlinux	EXPORT_SYMBOL
+0x00000000	cn_add_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_video_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite16_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite32_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup	vmlinux	EXPORT_SYMBOL
+0x00000000	free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	dmi_get_system_info	vmlinux	EXPORT_SYMBOL
+0x00000000	mdiobus_free	vmlinux	EXPORT_SYMBOL
+0x00000000	security_unix_stream_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_new_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__f_setown	vmlinux	EXPORT_SYMBOL
+0x00000000	execute_in_process_context	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_mangle_tcp_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_find_table_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	kset_register	vmlinux	EXPORT_SYMBOL
+0x00000000	fput	vmlinux	EXPORT_SYMBOL
+0x00000000	vector_used_by_percpu_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_get_window	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_phy_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_os_map_memory	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_timer_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_frag_init	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_set_features	vmlinux	EXPORT_SYMBOL
+0x00000000	__fsnotify_parent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_ep0_reinit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_phy_free	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ht_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	add_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	_read_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	usbhid_lookup_quirk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_deleteport	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_unregister_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_remove_one_port	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_handle_vblank	vmlinux	EXPORT_SYMBOL
+0x00000000	video_output_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	strnicmp	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_to_page	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_calculate_pkt_len	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_signed	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ht_find_item	vmlinux	EXPORT_SYMBOL
+0x00000000	fbcon_set_bitops	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sock_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_start_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_array2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_release	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_giveback_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	user_instantiate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_wait_queue_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_icmp_reply_translation	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ct_sip_get_sdp_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_debugfs_create_files	vmlinux	EXPORT_SYMBOL
+0x00000000	print_hex_dump_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmclnt_proc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_add_ci	vmlinux	EXPORT_SYMBOL
+0x00000000	register_posix_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	net_ipv6_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	net_ipv4_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_set_master	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_checksum_complete_head	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dh_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dh_detach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__percpu_counter_add	vmlinux	EXPORT_SYMBOL
+0x00000000	__percpu_counter_sum	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_init	vmlinux	EXPORT_SYMBOL
+0x00000000	mpage_readpage	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_raise_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_io_opt	vmlinux	EXPORT_SYMBOL
+0x00000000	ct_sip_parse_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_irq_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_issue_pc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_object_free	vmlinux	EXPORT_SYMBOL
+0x00000000	find_first_zero_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_adjust_queue_depth	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_find_first	vmlinux	EXPORT_SYMBOL
+0x00000000	x86_dma_fallback_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_mech_get_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_unregister_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sas_task_abort	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_generic_alloc_page	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_add	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_split	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	ucode_cpu_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_bit_add_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	class_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_pme_active	vmlinux	EXPORT_SYMBOL
+0x00000000	__locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_inline_decode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_check_req	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_unicast	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_sysctl_register	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_timing_merge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aes_decrypt_x86	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_start	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_attachmode_crtc	vmlinux	EXPORT_SYMBOL
+0x00000000	sys_close	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pgrp	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pernet_gen_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	global_cache_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_pci_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_build_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	is_bad_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_int	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_new_index	vmlinux	EXPORT_SYMBOL
+0x00000000	start_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_get_color_depth	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	user_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_get_tuplepr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_free_datagram_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sock_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_unregister_card_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	notify_change	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_up	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_short	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_start_tx_ba_cb_irqsafe	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_bind_pf	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sman_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	__ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	edid_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serio_unregister_child_port	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_hp_change_slot_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_cfg_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_sip_expect_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sk_mem_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hid_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pci_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_tag_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_merge_bvec	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_lock_updates	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_want_write_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_ct_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sk_classify_flow	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_decode_string_inplace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_seq_show	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_md5_hash_header	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_free_host_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_free_key	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_device_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	rwsem_down_write_failed	vmlinux	EXPORT_SYMBOL
+0x00000000	should_remove_suid	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_id_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_unlock_battery_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	find_lock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_register	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_get_irq_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	file_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_wait_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_array_set	vmlinux	EXPORT_SYMBOL
+0x00000000	param_array_get	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_sdp_addr_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	napi_get_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_write_space	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_notify_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_dup_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_register_fixup_for_id	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_buffer_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_resume_card	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_pci_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fasync	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_remove_gpe_block	vmlinux	EXPORT_SYMBOL
+0x00000000	zap_vma_ptes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_memory_uc	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_bysel_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_word_data	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_complete_async_scans	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_add	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_del	vmlinux	EXPORT_SYMBOL
+0x00000000	init_user_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_map_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	__sk_mem_reclaim	vmlinux	EXPORT_SYMBOL
+0x00000000	release_cis_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_pin_device	vmlinux	EXPORT_SYMBOL
+0x00000000	d_prune_aliases	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_check	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	__pagevec_release	vmlinux	EXPORT_SYMBOL
+0x00000000	warn_slowpath_fmt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_put_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_port_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcie_set_readrq	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup5	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_family_with_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	net_assign_generic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_dma_reserve_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_block_user_cfg_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_scnlistprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_release_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__kstat	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_rfkill_set_hw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_cache_pipe_upcall	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_enter_sleep_state	vmlinux	EXPORT_SYMBOL
+0x00000000	movable_zone	vmlinux	EXPORT_SYMBOL
+0x00000000	kbd_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_fill_super	vmlinux	EXPORT_SYMBOL
+0x00000000	have_submounts	vmlinux	EXPORT_SYMBOL
+0x00000000	printk_timed_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcb_getport_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lro_vlan_hwaccel_receive_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_add_device_sysfs_file	vmlinux	EXPORT_SYMBOL
+0x00000000	key_create_or_update	vmlinux	EXPORT_SYMBOL
+0x00000000	__tasklet_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_adjust_cwnd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_load	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u16	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_add_page	vmlinux	EXPORT_SYMBOL
+0x00000000	init_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_thread	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_unregister_table	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unlink_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_device_command	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateEnd	vmlinux	EXPORT_SYMBOL
+0x00000000	open_by_devnum	vmlinux	EXPORT_SYMBOL
+0x00000000	contig_page_data	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__softirq_work_list	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_evictor	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_target	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_show	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_dma_off	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_helper_initial_config	vmlinux	EXPORT_SYMBOL
+0x00000000	console_blanked	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_start_tx_ba_session	vmlinux	EXPORT_SYMBOL
+0x00000000	__iowrite32_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_enter_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ct_sip_parse_address_param	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_rules_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netpoll_set_trap	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_do_eh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitrev32	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_read	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free_slab	vmlinux	EXPORT_SYMBOL
+0x00000000	ec_transaction	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_getxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_setxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_connect_result	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_mech_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mpage_readpages	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_disable_event	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_delayed_work_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_create	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pack_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_dev_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_x32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_litter_super	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_proto_csum_replace4	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_expand_var_event	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_free_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_generic_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_prepare_flip_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_prepare_flip_string_flags	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_check_limits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__lock_page_killable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_rules_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	cdrom_number_of_slots	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_generic_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_make_synack	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_check_gmii_support	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_ehi_clear_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_get_page	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_forward	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bit_waitqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	amd_decode_nb_mce	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_wait_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_inodes	vmlinux	EXPORT_SYMBOL
+0x00000000	drop_file_write_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_mc_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_estimator_active	vmlinux	EXPORT_SYMBOL
+0x00000000	get_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	request_dma	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_roamed	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_inc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_orphan_count	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_data_xfer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_key_with_auxdata	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kick_iocb	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_exts_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_dump_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	get_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_destroy_credcache	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_dma_program	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_scsi_simulate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_tgt_tsk_mgmt_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_kzalloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_attr_u32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bread	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_beacon_get	vmlinux	EXPORT_SYMBOL
+0x00000000	syncookie_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_toiovec	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_alloc_page_array	vmlinux	EXPORT_SYMBOL
+0x00000000	agp3_generic_configure	vmlinux	EXPORT_SYMBOL
+0x00000000	in_aton	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_resolve_output	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_register	vmlinux	EXPORT_SYMBOL
+0x00000000	ec_read	vmlinux	EXPORT_SYMBOL
+0x00000000	cfb_imageblit	vmlinux	EXPORT_SYMBOL
+0x00000000	wrmsr_safe_on_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_init_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_unblock_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__mnt_is_readonly	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_close	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_sip_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_irc_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_ftp_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scm_send	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dma_map	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_cred	vmlinux	EXPORT_SYMBOL
+0x00000000	register_framebuffer	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_free_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	edac_handler_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_sman_takedown	vmlinux	EXPORT_SYMBOL
+0x00000000	add_input_randomness	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_acpi_bus_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iov_iter_advance	vmlinux	EXPORT_SYMBOL
+0x00000000	register_cdrom	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_unblock_requests	vmlinux	EXPORT_SYMBOL
+0x00000000	device_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_free_xmit_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_pci_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_claim	vmlinux	EXPORT_SYMBOL
+0x00000000	touch_nmi_watchdog	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hidraw_report_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_dbg_layer	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hwrng_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_nivaead_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_writeout_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm6_rcv_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_exts_change	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_release_substream	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_release_from_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_remove_port	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_install_gpe_block	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_posix_clock_nonanosleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies_to_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	pskb_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_master_send	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_slave_configure	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_qc_complete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_tgt_free_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_reprobe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_next_zero_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	timeval_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_free	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_kfree_skb_any	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_new1	vmlinux	EXPORT_SYMBOL
+0x00000000	security_task_getsecid	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_abort	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_drop_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_uaddr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_type	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_bridges	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_readpage	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_cong_avoid_ai	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpuidle_resume_and_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_altnum_to_altsetting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_access_configuration_register	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_create_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_secid_to_secctx	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_down	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_write_and_wait_range	vmlinux	EXPORT_SYMBOL
+0x00000000	__generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	probe_irq_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	genphy_read_status	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_xfer_mask2mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_create_dithering_property	vmlinux	EXPORT_SYMBOL
+0x00000000	redraw_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_reenable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	get_write_access	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_mapping_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_rom	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_complement	vmlinux	EXPORT_SYMBOL
+0x00000000	memdup_user	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_cooling_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_get_required_mask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	del_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_unbind_pf	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_current_frame_number	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generate_resume_trace	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tipc_forward_buf2name	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_send_check	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_close	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	__mark_inode_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_alloc_send_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_get_device	vmlinux	EXPORT_SYMBOL
+0x00000000	strnlen	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_filesystem	vmlinux	EXPORT_SYMBOL
+0x00000000	adjust_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_peeraddr2str	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_find_revision	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_netlink_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	__destroy_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_is_cwnd_limited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l3proto_generic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_mon_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_add_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_unmap_user	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_plug_device	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_mod_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_spin_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_port_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acquire_console_sem	vmlinux	EXPORT_SYMBOL
+0x00000000	pgprot_writecombine	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_encode_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_read_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_hangman	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_free_agp	vmlinux	EXPORT_SYMBOL
+0x00000000	register_hotplug_dock_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic64_sub_return	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf8_to_utf32	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_peer	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_prep_return	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_quota_on_path	vmlinux	EXPORT_SYMBOL
+0x00000000	override_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	secure_tcpv6_sequence_number	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_device_hid	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_get_create_access	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_level_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_resume_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_radiotap_iterator_init	vmlinux	EXPORT_SYMBOL
+0x00000000	scatterwalk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_key	vmlinux	EXPORT_SYMBOL
+0x00000000	timecompare_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_control_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_i_have_hw_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_append	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	random32	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_find_sta	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_tx_status_irqsafe	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_drvdata	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_drvdata	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_do_scan_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_chain_cond_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_state_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_md5_hash_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	bfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unpoison_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_write_devctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fb_helper_panic	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_init	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_from_user_ll_nocache	vmlinux	EXPORT_SYMBOL
+0x00000000	complete_request_key	vmlinux	EXPORT_SYMBOL
+0x00000000	mtrr_del	vmlinux	EXPORT_SYMBOL
+0x00000000	net_msg_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_recv_timestamp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_resume_root_hub	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_configure_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_ibss_joined	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_hash_walk_first	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_allmulti	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_remove_id	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_add_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_intersects	vmlinux	EXPORT_SYMBOL
+0x00000000	sha_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	ksize	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_kill_links	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_stop_bus_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_set_name	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_full	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_remove_notify_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_gpe_device	vmlinux	EXPORT_SYMBOL
+0x00000000	set_device_ro	vmlinux	EXPORT_SYMBOL
+0x00000000	pcibios_set_irq_routing	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_anchor_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dead_socket	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_clear_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_attr_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic_blink	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_port_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmap_high	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_dirty_page	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_kill	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_use_client	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_dumb_qc_prep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_agp_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_try_set_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_endio	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_stop_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stop_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_rphy_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_free_table	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_remove_posix	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_port_service_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	__cap_full_set	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_slow_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp4_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_netfilter	vmlinux	EXPORT_SYMBOL
+0x00000000	__pneigh_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	on_each_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_set_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_set_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_find_number	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_object_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	agp3_generic_sizes	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_remove_watch_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bioset_create	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_put_cacheinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cpufreq_driver_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	names_cachep	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_inode_pages2_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qword_addhex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	xrlim_allow	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_create_card_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_qc_complete_multiple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_unmap_rom	vmlinux	EXPORT_SYMBOL
+0x00000000	key_instantiate_and_link	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_sock_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_sad_getinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_napi_del	vmlinux	EXPORT_SYMBOL
+0x00000000	input_event_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_for_device_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_add_videomode	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	single_open	vmlinux	EXPORT_SYMBOL
+0x00000000	page_follow_link_light	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_disassoc	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_sock_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm6_find_1stfragopt	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_lookup_oss_minor_data	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_request_card	vmlinux	EXPORT_SYMBOL
+0x00000000	genphy_config_advert	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_helper_disable_unused_functions	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_kernel_client_ctl	vmlinux	EXPORT_SYMBOL
+0x00000000	ii_msgs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_inode_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lockd_down	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_reserve_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_set_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_get_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_listen_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf32_to_utf8	vmlinux	EXPORT_SYMBOL
+0x00000000	groups_free	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	cleanup_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_cmos_write	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_destroy_chain	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_port_start32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_release_dma_engine	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_perform_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_pci_detect_ejectable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_request_region_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	wrmsr_on_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_ide_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_platform_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_remove_recursive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_register	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_deauth	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_parms_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_disabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic64_sub	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_clock_idle_sleep_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	interruptible_sleep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	__ip_route_output_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_set_silence	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_notify_transition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_usual_set_present	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_buffer_map_sg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_invalidate_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	io_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	arch_acpi_processor_cleanup_pdc	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_bmdma_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_pci_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfb_fillrect	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_part_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	pid_vnr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	math_state_restore	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_decode_session	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_net_ipv4_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_lower_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_rfkill_stop_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_set_err	vmlinux	EXPORT_SYMBOL
+0x00000000	tr_type_trans	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fb_helper_restore	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_ownidentity	vmlinux	EXPORT_SYMBOL
+0x00000000	wireless_spy_update	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	register_snap_client	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_purge	vmlinux	EXPORT_SYMBOL
+0x00000000	register_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_unmapped_area	vmlinux	EXPORT_SYMBOL
+0x00000000	add_to_page_cache_lru	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tipc_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fb_helper_check_var	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_generic_destroy_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_user	vmlinux	EXPORT_SYMBOL
+0x00000000	d_find_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	yield	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_check_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_destroy_modedb	vmlinux	EXPORT_SYMBOL
+0x00000000	fsstack_copy_attr_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_processor_ffh_cstate_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_ct_try_assign_helper	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_unregister_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_toiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_command_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_init_always	vmlinux	EXPORT_SYMBOL
+0x00000000	d_invalidate	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_32	vmlinux	EXPORT_SYMBOL
+0x00000000	pid_task	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_print_acct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	stp_proto_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_register_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sman_free_key	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_class_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_pool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_x	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv4_config	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_carrier_on	vmlinux	EXPORT_SYMBOL
+0x00000000	fib_rules_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_loop_config	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_unregister_device_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_full	vmlinux	EXPORT_SYMBOL
+0x00000000	print_hex_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rts_duration	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_route_output	vmlinux	EXPORT_SYMBOL
+0x00000000	__rta_fill	vmlinux	EXPORT_SYMBOL
+0x00000000	__dst_free	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_crtc_helper_set_config	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_newsize_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	_spin_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_stall_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	no_pci_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	strncmp	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_kfree_s	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_little_endian	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_access_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc32_le	vmlinux	EXPORT_SYMBOL
+0x00000000	scatterwalk_map_and_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__task_pid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_link	vmlinux	EXPORT_SYMBOL
+0x00000000	input_event_to_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_port_free	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	boot_option_idle_override	vmlinux	EXPORT_SYMBOL
+0x00000000	nlm_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_generic_getfrag	vmlinux	EXPORT_SYMBOL
+0x00000000	stp_proto_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mii_nway_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_port_alloc_num	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_dma_host_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_trace_device	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_enqueue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_add_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thaw_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_array_uc	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_run_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_rx_csum_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_data_xfer32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_release_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_sg_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_decode_array2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_push_nfrag_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_register_table	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_sysctl_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_width	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pio_need_iordy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_table	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_destroy_modelist	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_abort_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scm_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_mixer_oss_notify_callback	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_crtc_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	d_move	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_del_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	request_key_async	vmlinux	EXPORT_SYMBOL
+0x00000000	touch_atime	vmlinux	EXPORT_SYMBOL
+0x00000000	get_cpu_idle_time_us	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_unregister_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer_pending	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_processor_notify_smm	vmlinux	EXPORT_SYMBOL
+0x00000000	strchr	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_hlt	vmlinux	EXPORT_SYMBOL
+0x00000000	strstr	vmlinux	EXPORT_SYMBOL
+0x00000000	k8_northbridges	vmlinux	EXPORT_SYMBOL
+0x00000000	arch_register_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_buffered_bc	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_listen_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wait_anchor_empty_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_parse_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_release_card_device	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_lookup_byaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	pskb_expand_head	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bus_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_release_client	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_display_xfer_agreement	vmlinux	EXPORT_SYMBOL
+0x00000000	take_over_console	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	napi_reuse_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_mark_declared_memory_occupied	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_may_write	vmlinux	EXPORT_SYMBOL
+0x00000000	bh_submit_read	vmlinux	EXPORT_SYMBOL
+0x00000000	nmi_watchdog	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_buf_read_netobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_header_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_change_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	ext_msgs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_acpi_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	machine_check_poll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_hash_insert	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_wake_async	vmlinux	EXPORT_SYMBOL
+0x00000000	getrawmonotonic	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_free_clusters	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__set_page_dirty_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_prot_inuse_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_platform_shutdown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	per_cpu__vm_event_states	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_register_action	vmlinux	EXPORT_SYMBOL
+0x00000000	amd_register_ecc_decoder	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_ordered	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_seq_kernel_client_enqueue_blocking	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	copy_strings_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_register_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_debug	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_clear_gpe	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_get_remaining	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_enter_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_add_rx_frag	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unregister_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_root_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	wrmsr_on_cpus	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_kernel_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iomap_create_wc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_create	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_schedule_dv_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_cd_get_xferlen	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_alloc_xmit_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_attach_data	vmlinux	EXPORT_SYMBOL
+0x00000000	no_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_timed_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_irq_set_freq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_declare_coherent_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_videomode_to_modelist	vmlinux	EXPORT_SYMBOL
+0x00000000	rwsem_down_read_failed	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_array_uc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_array_wb	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_receive_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_port_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_pci_check_ejectable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_show_options	vmlinux	EXPORT_SYMBOL
+0x00000000	pagecache_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysctl_paths	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_pause	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	capable	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_debug_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_set_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_cmd_aborted	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_tv_properties	vmlinux	EXPORT_SYMBOL
+0x00000000	autoremove_wake_function	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_port_tuple_to_nlattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	give_up_console	vmlinux	EXPORT_SYMBOL
+0x00000000	getname	vmlinux	EXPORT_SYMBOL
+0x00000000	pcpu_base_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_helper_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_seq_root	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_find_io_region	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_attr_alg_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_calg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_sgbuf_get_chunk_size	vmlinux	EXPORT_SYMBOL
+0x00000000	uhci_check_and_reset_hc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hc_died	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_forward_buf2port	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_response_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	deactivate_locked_super	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawait	vmlinux	EXPORT_SYMBOL
+0x00000000	add_efi_memmap	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_class_create_file	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_big_endian	vmlinux	EXPORT_SYMBOL
+0x00000000	in_lock_functions	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netpoll_parse_options	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_datagram_const_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getpeername	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_port_add_phy	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_driver_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	is_dock_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_chmod_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mce_notify_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_event	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_pin_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_user	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_cpu_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	tc_classify	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	get_current_tty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_scnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_create_data	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_cache_register_pipefs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getsockname	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_midi_event_no_status	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ecards_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_and	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_send_buf2port	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_alloc_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_disable_interrupts	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_err_bytes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_blkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_givcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_log_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_tree_decrease_qlen	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_autopm_set_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_eh_freeze_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkcipher_walk_virt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_lock_file	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	set_page_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_sockaddr2uaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fb_helper_init_crtc_count	vmlinux	EXPORT_SYMBOL
+0x00000000	totalram_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_udp4	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_mc_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_socket_dev_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_prereset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_get_kset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ati_pcigart_init	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_show_logo	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_pan_display	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_get_write_access	vmlinux	EXPORT_SYMBOL
+0x00000000	__register_chrdev	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_opaque	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_class_close	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_max_payload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_pci_problems	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	free_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_format_mac	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_send_sigurg	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_eh_thaw_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_is_active	vmlinux	EXPORT_SYMBOL
+0x00000000	drop_super	vmlinux	EXPORT_SYMBOL
+0x00000000	printk	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_get_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_std_hardreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_property_add_enum	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_helper_resume_force_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_inode_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	try_to_release_page	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_srcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpcauth_lookup_credcache	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_dv_device	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_msix	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_add	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	parport_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_fb_helper_setcolreg	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_generic_alloc_user	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_get_ejd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	native_io_delay	vmlinux	EXPORT_SYMBOL
+0x00000000	start_thread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_get_led_trigger_name	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_set_led_trigger_name	vmlinux	EXPORT_SYMBOL
+0x00000000	iw_handler_get_thrspy	vmlinux	EXPORT_SYMBOL
+0x00000000	br_should_route_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_copy_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_flush_chipset	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_single_device	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_dir_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_forward2name	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_generic_remove_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic64_set	vmlinux	EXPORT_SYMBOL
+0x00000000	dqput	vmlinux	EXPORT_SYMBOL
+0x00000000	dqget	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_fini	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_register_oss_device	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_pointer	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_get_line	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_dispatch_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_add_request	vmlinux	EXPORT_SYMBOL
+0x00000000	security_tun_dev_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_start_head	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_device_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_device_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	device_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_pci_osc_control_set	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	relay_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_calc_rto	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	ei_set_multicast_list	vmlinux	EXPORT_SYMBOL
+0x00000000	serial8250_suspend_port	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_width	vmlinux	EXPORT_SYMBOL
+0x00000000	fg_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_find	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_read	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_read	vmlinux	EXPORT_SYMBOL
+0x00000000	__devm_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_hash_nolisten	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy_fromiovec	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_pci_init_two	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	parport_write	vmlinux	EXPORT_SYMBOL
+0x00000000	__nvram_write_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_find_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_prep_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_socket_dev_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_base_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_unlock_updates	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_cache_unregister_pipefs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_map_sg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ati_pcigart_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_collect_device_status	vmlinux	EXPORT_SYMBOL
+0x00000000	__div64_32	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_remove_all	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	mntput_no_expire	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	disallow_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_ip_nonlocal_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	__tcp_get_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0x00000000	pciserial_init_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf8s_to_utf16s	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_fops_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_resize_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_reserve_space	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv4_specific	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_l3proto_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proto_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_new_dummy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	parport_ieee1284_write_compat	vmlinux	EXPORT_SYMBOL
+0x00000000	__fsnotify_inode_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_helper_hotplug_stage_two	vmlinux	EXPORT_SYMBOL
+0x00000000	__any_online_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_instantiate_filp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tipc_enable_bearer	vmlinux	EXPORT_SYMBOL
+0x00000000	kunmap_high	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_scr_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_vendor_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	match_strdup	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	__crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_seq_next	vmlinux	EXPORT_SYMBOL
+0x00000000	bsg_register_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_ro_fops	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_get_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kthread_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_disconnect_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_unregister_region	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_property_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_frag_find	vmlinux	EXPORT_SYMBOL
+0x00000000	inetdev_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_poison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	fifo_set_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	ei_tx_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_host_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_fdatawrite	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_base_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_i2c_encoder_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	console_blank_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_request_find_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	file_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	get_sb_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_unmap_aliases	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_finish_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	dmi_find_device	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_device_flags_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_fetch_request	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	block_all_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_pci_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_name	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_get_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	destroy_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_pipe	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twsk_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_default_rule_add	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_ehi_push_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_set_pio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_SAK	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_save_state	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_get_dotdot_entry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	check_disk_change	vmlinux	EXPORT_SYMBOL
+0x00000000	default_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	writeback_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_rphy_add	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_put_link	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_sleep_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_id_c_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_state_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_list_del	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_property_create	vmlinux	EXPORT_SYMBOL
+0x00000000	get_option	vmlinux	EXPORT_SYMBOL
+0x00000000	register_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_select_initial_window	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hidraw_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unbind_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_format_exception	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_consistent_dma_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	up_read	vmlinux	EXPORT_SYMBOL
+0x00000000	_cond_resched	vmlinux	EXPORT_SYMBOL
+0x00000000	empty_zero_page	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnetlink_subsys_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pskb_pull_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_frequency_table_verify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_wait_until_sent	vmlinux	EXPORT_SYMBOL
+0x00000000	bioset_free	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fstat	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_lstat	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_spin_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	orderly_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_storage_usb_ids	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	vesa_modes	vmlinux	EXPORT_SYMBOL
+0x00000000	__netif_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_try_unsupported_boot	vmlinux	EXPORT_SYMBOL
+0x00000000	ioread16	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_fh_to_parent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_fillattr	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_alloc_slab	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_init_disk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_alloc_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	d_instantiate_unique	vmlinux	EXPORT_SYMBOL
+0x00000000	request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_drop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_bmdma32_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_scr_valid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_do_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_port_unregister_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	try_acquire_console_sem	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_get_mesh	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_policy_rwsem_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_get_keycode	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_best_display	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_find_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_task_ioprio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_arg_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_send_buf_fast	vmlinux	EXPORT_SYMBOL
+0x00000000	snmp_fold_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_event_port_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_ethtool_sset	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_ethtool_gset	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_dma_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_encoder_init	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_fdget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_zone_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_alloc_pinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_lock_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_uncopy_user	vmlinux	EXPORT_SYMBOL
+0x00000000	make_bad_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__mmdrop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_check_keys_pressed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_qc_fill_rtf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sff_dma_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_release_private	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_remove_one	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_console_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_error	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_removexattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__mutex_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_set_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcix_get_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_irq_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tipc_get_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	auth_domain_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmpv6_err_convert	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_register_device_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_input_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serial8250_register_port	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_get_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_write	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readv	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_debugfs_remove_files	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_shash_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	search_binary_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_trylock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	amd_get_nb_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_freq_attr_scaling_available_freqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_remove_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ahash_attr_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dquot_claim_space	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_clock_idle_wakeup_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tsc_khz	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_8	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	put_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_info_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_pair_release	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_expedited_torture_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_start	vmlinux	EXPORT_SYMBOL
+0x00000000	register_filesystem	vmlinux	EXPORT_SYMBOL
+0x00000000	loops_per_jiffy	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_validate_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_is_system_supplied	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_remove_children	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_getsarea	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_bridges	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_name	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic64_sub_and_test	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_copy_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x00000000	hidraw_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_debug_root	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_crtc_set_gamma_size	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_addbufs_agp	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_addbufs_pci	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_delayed_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_send_check	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_insert_card	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_attr_sw_activity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mangle_path	vmlinux	EXPORT_SYMBOL
+0x00000000	anon_inode_getfd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_core_get_map_ofs	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_vm_close	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_remove_table_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	cmos_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_scan_completed	vmlinux	EXPORT_SYMBOL
+0x00000000	unix_domain_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pernet_gen_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_read_i2c_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	strnlen_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kunmap	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_free_table_info	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cn_netlink_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mnt_pin	vmlinux	EXPORT_SYMBOL
+0x00000000	set_create_files_as	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_alloc_pages_fallback	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_set_battery_charged	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rdmsr_safe_on_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	__page_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	install_exec_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_setscheduler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_sound_midi	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ht_insert_item	vmlinux	EXPORT_SYMBOL
+0x00000000	strict_strtol	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_skb_read_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_mc_rejoin_group	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_register_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_sk_rebuild_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_quota_format	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	avenrun	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_extend_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_page_accessed	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_count_enc_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_report_bus_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	__ht_create_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_get_reserved_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_output_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_dq_drop	vmlinux	EXPORT_SYMBOL
+0x00000000	block_sync_page	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_add	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_batches_completed_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_update_rtt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_input	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_add	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_new	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_update_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_attr_em_message_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_install_method	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_blank	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_update_dma_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	open_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_find_next	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_unicast_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_xfer_mode2shift	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_activate_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_next_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unlock_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_forget	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	queue_delayed_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_open_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_msix	vmlinux	EXPORT_SYMBOL
+0x00000000	div_s64_rem	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_dq_quota_on_remount	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_page_dirty_nobuffers	vmlinux	EXPORT_SYMBOL
+0x00000000	put_online_cpus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_copy_addrs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_ct_kill_acct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_parse_tuple	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_create_node	vmlinux	EXPORT_SYMBOL
+0x00000000	find_get_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_promiscuity	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_transparent_scsi_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_bios_ptable	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_pad_transfer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_order	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_write_vpd	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_connected_output	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_continue	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_recv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_flush_pending_frames	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_kernel_create	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_parse_user	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	apm_info	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsg_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_connector_name	vmlinux	EXPORT_SYMBOL
+0x00000000	mmput	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_task	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	build_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_twsk_hashdance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_table_init_no_netlink	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_copy_app	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_verify_client	vmlinux	EXPORT_SYMBOL
+0x00000000	input_allocate_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_pcie_reset_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_parselist	vmlinux	EXPORT_SYMBOL
+0x00000000	__insert_inode_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	revert_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_overflowgid	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_get_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_midi_event_reset_decode	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dh_set_params	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_generic_type_to_mask_type	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_mem_start	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_send2name	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_walk	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_proc_new	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_map	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_checksum_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_device_do_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_blkdev	vmlinux	EXPORT_SYMBOL
+0x00000000	key_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	write_inode_now	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	destroy_cis_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_read_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_suspend_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_store_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_hw_change	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_search_long	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_path	vmlinux	EXPORT_SYMBOL
+0x00000000	msleep_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	smp_num_siblings	vmlinux	EXPORT_SYMBOL
+0x00000000	g_verify_token_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_valid_name	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_add	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_create_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	hweight8	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_init_table	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	fsnotify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_open	vmlinux	EXPORT_SYMBOL
+0x00000000	default_unplug_io_fn	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_update_link	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_freeze	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_cont_expand_simple	vmlinux	EXPORT_SYMBOL
+0x00000000	d_instantiate	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sound_special_device	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_generic_create_gatt_table	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_rq_timed_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_alloc_table_info	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc32_be	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_register_ioapic	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_register_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_restart_call	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_output_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_find_text	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_helper_crtc_in_use	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_clear_master	vmlinux	EXPORT_SYMBOL
+0x00000000	_spin_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	current_fs_time	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_set_portunreliable	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_create	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_lookup_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_test_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_hash_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_buffer_dirty_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbhid_submit_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_thaw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_execute_req	vmlinux	EXPORT_SYMBOL
+0x00000000	backlight_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	oops_in_progress	vmlinux	EXPORT_SYMBOL
+0x00000000	release_console_sem	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_tx_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_ldisc	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_throttle	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_check_change	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_get_backing_dev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_init	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_fasync	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_disable_lro	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_validate_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_classdev_to_container	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_put_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_vm_open	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_fb_helper_setcmap	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_core_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	close_bdev_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	vma_kernel_pagesize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_publish	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_dump_start	vmlinux	EXPORT_SYMBOL
+0x00000000	call_netevent_notifiers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_add_host	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_check_ireason	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_base	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aio_put_req	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_ext_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6t_ext_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_device_do_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serial8250_unregister_port	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x00000000	replace_mount_options	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_policy_check	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_rename_id	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_sff_init_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_info	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_evaluate_object_typed	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_sync_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pskb_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_schedule_eh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_capacity_proc_fops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strict_strtoul	vmlinux	EXPORT_SYMBOL
+0x00000000	strict_strtoll	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_alloc_new_dir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	used_vectors	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_postreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smp_call_function	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_header_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_byte_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_command	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_handle_response	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_set_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_dock_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic64_cmpxchg	vmlinux	EXPORT_SYMBOL
+0x00000000	int_sqrt	vmlinux	EXPORT_SYMBOL
+0x00000000	dec_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_max	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	llc_mac_hdr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_dirty_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_init_node	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_set_media_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_helper_probe_connector_modes	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_update_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_request	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	stop_machine_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	use_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_try_to_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_register_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	input_unregister_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_replace	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_sched	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_continue	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_io_opt	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmi_get_date	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_andnot	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_get	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_from_xattr	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_int	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_inline_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_card_file_add	vmlinux	EXPORT_SYMBOL
+0x00000000	nvram_write_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_drop_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_midi_event_new	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_mmap_iomem	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_cable_80wire	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_timing_find_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_short	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sman_owner_clean	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_write	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_create_module_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_update_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_disable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ei_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_xfer_verbose	vmlinux	EXPORT_SYMBOL
+0x00000000	vfree	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_on_page_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_acpi_cbl_80wire	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_get_host_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_create_request_sense_cmd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rdmsr_on_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rq_merge_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_do_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	get_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioread16be	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_dump_rq_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	g_make_token_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_release_rqst_cong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	consume_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_match_id	vmlinux	EXPORT_SYMBOL
+0x00000000	stop_machine_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_alloc_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_action_dump_1	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_tso	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_add_numbered_adapter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_allocate_polled_device	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unanchor_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	root_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec_ms_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_kill	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_port_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_phys_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_getattr	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_em_tree_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	llc_sap_open	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_tx_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_Bulk_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	attribute_container_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_vblank_put	vmlinux	EXPORT_SYMBOL
+0x00000000	bdget_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_init_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_rcv_state_process	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_tx_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_to_sgvec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_phy_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_alloc_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	sscanf	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsvc_unlock_all_by_sb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nlmsvc_unlock_all_by_ip	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__breadahead	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_bind_new_program	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmpv6_statistics	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_integer	vmlinux	EXPORT_SYMBOL
+0x00000000	led_classdev_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_lid_open	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_add_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_for_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_to_xdr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_md5_do_del	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_byte_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_add_bridge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hweight32	vmlinux	EXPORT_SYMBOL
+0x00000000	hweight16	vmlinux	EXPORT_SYMBOL
+0x00000000	hweight64	vmlinux	EXPORT_SYMBOL
+0x00000000	__create_workqueue_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_dma_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_kmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpcauth_init_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_rpccred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_twcal_tick	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_create_lite	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_std_qc_defer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	per_cpu__x86_bios_cpu_apicid	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_event_port_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_unregister_governor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdrom_release	vmlinux	EXPORT_SYMBOL
+0x00000000	d_obtain_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	vdso_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip4_datagram_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_timewait_state_process	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_sff_init_one	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_start_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_init_security	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_hrtimeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_wait_event	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_unbind_agp	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_resource_len	vmlinux	EXPORT_SYMBOL
+0x00000000	native_rdmsr_safe_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	native_wrmsr_safe_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_page_dirty_for_io	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_init_notifier_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies_to_timeval	vmlinux	EXPORT_SYMBOL
+0x00000000	arch_acpi_processor_init_pdc	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_unmap_lsapic	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_disable_bearer	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_min_cwnd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_schedule_flip	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_start_grace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_follow_link	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_create_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_socket_list	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	intelfb_probe	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_devnum	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_rm_wd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_read_cis_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	kstat_irqs_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	llc_sap_find	vmlinux	EXPORT_SYMBOL
+0x00000000	input_free_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_mode_filter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_host_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_set_retrans_timeout_rtt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_queue_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_mkdir	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_put	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_get	vmlinux	EXPORT_SYMBOL
+0x00000000	get_online_cpus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idle_halt	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_free_noncoherent	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_find_base	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	__napi_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_set_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_or	vmlinux	EXPORT_SYMBOL
+0x00000000	security_req_classify_flow	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	amd_report_gart_errors	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_agp_chipset_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite8	vmlinux	EXPORT_SYMBOL
+0x00000000	strlen	vmlinux	EXPORT_SYMBOL
+0x00000000	strspn	vmlinux	EXPORT_SYMBOL
+0x00000000	_spin_trylock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_allocate_command	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_strcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	strict_strtoull	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_ahash_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_announce_port	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_read_bit_register	vmlinux	EXPORT_SYMBOL
+0x00000000	boot_cpu_data	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_proc_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_init	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__xt_info_locks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_seq_delete_kernel_client	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_changed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_irq_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_int	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_set	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shash_free_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_string	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_generic_bind_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_cow_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_kernel_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_dev_select	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_perfctr_nmi	vmlinux	EXPORT_SYMBOL
+0x00000000	bridge_tunnel_header	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_free_when_closed	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_get_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_host_intr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_options	vmlinux	EXPORT_SYMBOL
+0x00000000	setup_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_partial_copy_from_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_unregister_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_generic_alloc_by_type	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_pci_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bh_uptodate_or_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_read_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_remove_behind_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	string_get_size	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_fill_super	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dquot_initialize	vmlinux	EXPORT_SYMBOL
+0x00000000	register_exec_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	fl6_sock_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fddi_change_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pci_quirk_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_write_config_word	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_cookie_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_free_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_dev_present	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_to_user_ll	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_release	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_start	vmlinux	EXPORT_SYMBOL
+0x00000000	_write_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aead_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_state_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_port_nlattr_to_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_set_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_enable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_list_concat	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_get_block_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	completion_done	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_put_stab	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_best_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_printf	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_validate_size	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtol	vmlinux	EXPORT_SYMBOL
+0x00000000	rwsem_downgrade_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup5_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	local_apic_timer_c2_ok	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_kill_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_init	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_install_gpe_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	fbcon_set_tileops	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_power_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rdmsr_on_cpus	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_alignment_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_super	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_sense_info_fld	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_set_current_resources	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_size_bridges	vmlinux	EXPORT_SYMBOL
+0x00000000	__bio_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_flush_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_lib_malloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cap_netlink_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	nr_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_kunmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_block_when_processing_errors	vmlinux	EXPORT_SYMBOL
+0x00000000	agp3_generic_fetch_size	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_key_construction	vmlinux	EXPORT_SYMBOL
+0x00000000	open_bdev_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	f_setown	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_clear_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_leave_sleep_state	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	submit_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_clone_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_mkclean	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_seconds	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_8022_client	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_anchor_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kvasprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_insert_color	vmlinux	EXPORT_SYMBOL
+0x00000000	svcauth_unix_set_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_dump_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_dma_pause	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_tf_to_fis	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_helper_probe_single_connector_modes	vmlinux	EXPORT_SYMBOL
+0x00000000	symbol_put_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__module_text_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_start_range_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_possible_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_search	vmlinux	EXPORT_SYMBOL
+0x00000000	llc_set_station_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_word_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_buffer_request_room	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__alloc_pages_nodemask	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_abort_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_extend	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_object_handle_free	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_execute_rq_nowait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_inode_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_proc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_choose_state	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	__FIXADDR_TOP	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_assoc_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_user	vmlinux	EXPORT_SYMBOL
+0x00000000	__alloc_percpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_eh_qc_retry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clear_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwessid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwessid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_close_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_parms_release	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_link_urb_to_ep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_release_declared_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	device_release_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_lookup_devt	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_grab_skcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_write_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_from_user_toio	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_bulk_srb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_register_interface	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_setlease	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_read_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_intf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_dma_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	set_current_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_input_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_conntrack_helper_find_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_probe1	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_probe2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	update_region	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_processor_unregister_performance	vmlinux	EXPORT_SYMBOL
+0x00000000	sprint_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_em_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_fp_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_vhangup	vmlinux	EXPORT_SYMBOL
+0x00000000	kref_set	vmlinux	EXPORT_SYMBOL
+0x00000000	kcrypto_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shrink_dcache_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_send2port	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twdr_twkill_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_net	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_for_each_drv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_quota_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_recv_msg	vmlinux	EXPORT_SYMBOL
+0x00000000	pneigh_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_negotiate	vmlinux	EXPORT_SYMBOL
+0x00000000	__udelay	vmlinux	EXPORT_SYMBOL
+0x00000000	__ndelay	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_close	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_scaling_mode_property	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_find_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	in_egroup_p	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_alloc_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_append_datato_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	release_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite16	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite32	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_msecs	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_usecs	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_child_process	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_socket_class	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_detect_hdmi_monitor	vmlinux	EXPORT_SYMBOL
+0x00000000	crc_t10dif	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	mdiobus_write	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_wait_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	bsg_unregister_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	prepare_binprm	vmlinux	EXPORT_SYMBOL
+0x00000000	iomap_atomic_prot_pfn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_last	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_rm_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	can_do_mlock	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__print_symbol	vmlinux	EXPORT_SYMBOL
+0x00000000	ndisc_mc_map	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_dump_status	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_walk_namespace	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_msi_block	vmlinux	EXPORT_SYMBOL
+0x00000000	sprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_listxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	net_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_eh_bus_reset_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_power_names	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shash_ahash_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_acl_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_inode_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_autopm_get_interface_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_register	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_shash_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_dirty_data	vmlinux	EXPORT_SYMBOL
+0x00000000	find_vma	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_print_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_extend_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_request_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_exception	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_dentry_parent_queue_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_stream_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_video_display_switch_support	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	screen_info	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_warn_nonwc	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_eh_qc_complete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_release_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	boot_tvec_bases	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_class_remove_file	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_port_scan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_physical_block_size	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmclnt_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	relay_subbufs_consumed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_write_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	timecounter_cyc2time	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_wake_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	ht_create_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_ack_err	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_down	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	edac_err_assert	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_close_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_end_request	vmlinux	EXPORT_SYMBOL
+0x00000000	_read_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_rcv_established	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_targets	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_prep_fn	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_property_set_value	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_property_get_value	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_ec_remove_query_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_strtoul	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_afinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_addmap	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	get_sb_pseudo	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_trace	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dbgp_reset_prep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_pci_pm_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	parport_ieee1284_ecp_write_data	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_ieee1284_epp_write_data	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x00000000	remap_vmalloc_range	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	enable_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	enable_hlt	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_register_socket	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_unbind_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	__ieee80211_get_rx_led_name	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create	vmlinux	EXPORT_SYMBOL
+0x00000000	memchr	vmlinux	EXPORT_SYMBOL
+0x00000000	_spin_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_release	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_hsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_destroy_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_machine_check	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_read_altstatus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_current_gpe_count	vmlinux	EXPORT_SYMBOL
+0x00000000	submit_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_page_buffers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	handle_nested_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_post_internal_cmd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_host_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_mtup_init	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_streq	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_buffer_head	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_setattr	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_write_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp4_gro_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_input	vmlinux	EXPORT_SYMBOL
+0x00000000	device_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_skip_exthdr	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_md5_hash_skb_data	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_alloc_hashtable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aio_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pid	vmlinux	EXPORT_SYMBOL
+0x00000000	rt6_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_init_net	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	congestion_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_intvec	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_del_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_dma_drain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_remove_plug	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_release	vmlinux	EXPORT_SYMBOL
+0x00000000	__atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_beacon_loss	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_slave_configure	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hex_dump_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	file_ra_state_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_larval_kill	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_register_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_get_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_clients_command	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_change_queue_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_get_ufo	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_rtc_timer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_auth_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flow_cache_genid	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_new_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	input_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_backend_release	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_master	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_mod_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__devm_request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_set_device_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_finish_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	intelfb_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	vc_cons	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_common_sdev_attrs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_add_edid_modes	vmlinux	EXPORT_SYMBOL
+0x00000000	strncat	vmlinux	EXPORT_SYMBOL
+0x00000000	strlcat	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_discard_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_chmod_masq	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_should_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnetlink_set_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_pci_device_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_map_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_mapping_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__tcp_put_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	__nvram_read_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_scan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_change_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	datagram_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_end_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	__tcf_em_tree_match	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_midi_event_free	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_Bulk_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_tf_load	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_tf_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_object_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_get_bus_and_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	security_release_secctx	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_old_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	_write_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	timecounter_init	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	llc_sap_close	vmlinux	EXPORT_SYMBOL
+0x00000000	mdiobus_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_link_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sman_set_range	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_inform_bss_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_proc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_udp6	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	stop_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_sb_nodev	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_create	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_type	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	iounmap_atomic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_ifdown	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_ratnums	vmlinux	EXPORT_SYMBOL
+0x00000000	strcspn	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_zone_unbind_cooling_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_cable_ignore	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	do_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l3proto_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l4proto_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_parse_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkdev_aio_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_bitmap_list	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_pages_exact	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rx	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rx_irqsafe	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_sdp_media_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_timing_compute	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ut_debug_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_drawable_info	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_rmmap	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_svc_to_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_find_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_process	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_force_rebind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_sound_special	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	__nla_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	inc_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_killall_tasks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_find	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_iterate_cleanup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_getbyhwaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_pme_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	finish_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_after	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_etherdev_mq	vmlinux	EXPORT_SYMBOL
+0x00000000	llc_sap_list	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_start_aneg	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_result	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_weight	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoull	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_ptr_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	clockevent_delta2ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_defrag_ipv4_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pccard_validate_cis	vmlinux	EXPORT_SYMBOL
+0x00000000	default_red	vmlinux	EXPORT_SYMBOL
+0x00000000	generate_random_uuid	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_edid_to_monspecs	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_free_hashtable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_net_ns_by_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_dma_sff_read_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_write_bit_register	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_statfs	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_iterate_active_interfaces_atomic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	br_handle_frame_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_new_probed_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_agp_free	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_complete_power_transition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnetlink_put_metrics	vmlinux	EXPORT_SYMBOL
+0x00000000	int_to_scsilun	vmlinux	EXPORT_SYMBOL
+0x00000000	may_umount	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_dma_off_quietly	vmlinux	EXPORT_SYMBOL
+0x00000000	pcix_get_max_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	block_read_full_page	vmlinux	EXPORT_SYMBOL
+0x00000000	console_drivers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	per_cpu__injectm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	save_processor_state	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_sort_breadthfirst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sync_mss	vmlinux	EXPORT_SYMBOL
+0x00000000	ct_sip_get_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_port_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	emergency_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	local_bh_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_death_row	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serio_rescan	vmlinux	EXPORT_SYMBOL
+0x00000000	framebuffer_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_get_nr_vecs	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_multicast	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwencode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwencode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_byid	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_driver_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_prepare_to_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	ahash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	load_nls_default	vmlinux	EXPORT_SYMBOL
+0x00000000	nonseekable_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_create	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_get_local_port_range	vmlinux	EXPORT_SYMBOL
+0x00000000	strstrip	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_escape	vmlinux	EXPORT_SYMBOL
+0x00000000	__seq_open_private	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_aes_encrypt_x86	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_ealg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_get_by_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc_root	vmlinux	EXPORT_SYMBOL
+0x00000000	page_address	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_over_panic	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_store_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_cache_sync_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_free	vmlinux	EXPORT_SYMBOL
+0x00000000	is_hpet_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	ei_close	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcipher_walk_phys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_change_rating	vmlinux	EXPORT_SYMBOL
+0x00000000	__ieee80211_get_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_post_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__usb_get_extra_descriptor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_assign_resources	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_hp_create_module_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fsnotify_get_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_netdevice	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_init	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_finish_command	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_queue_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	user_describe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkdev_get	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_put	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pid_info_as_uid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_get_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_tf_load	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mutex_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_64	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_lookup_machine_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_slave_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_cleanup_aer_uncorrect_error_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	half_md4_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_prev_hole	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_readdir	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_add_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	abort_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_alloc_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_vlan_hwaccel_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_alloc_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0x00000000	llc_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_rand_reach_time	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	restore_processor_state	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_pc_probe_port	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_dvi_i_properties	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ht_create	vmlinux	EXPORT_SYMBOL
+0x00000000	wrmsr_safe_regs_on_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflate_blob	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_find	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_mknod	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_disconnected	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_rx_auth	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_dequeue	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_gbl_FADT	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_write_and_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_irq_nosync	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_freeinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	find_font	vmlinux	EXPORT_SYMBOL
+0x00000000	add_uevent_var	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_features_change	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_resource_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_online_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_nx	vmlinux	EXPORT_SYMBOL
+0x00000000	smp_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_port_nlattr_tuple_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_start	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_probed_add	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dostring	vmlinux	EXPORT_SYMBOL
+0x00000000	usecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_write_config_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_schedule_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	raw_hash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_control_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_acpi_bus_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_force_commit_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	udplite_table	vmlinux	EXPORT_SYMBOL
+0x00000000	tc_classify_compat	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_usual_clear_present	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_max_segment_size	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_tail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_kfree_skb_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	dmi_first_match	vmlinux	EXPORT_SYMBOL
+0x00000000	do_unblank_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_ext_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	log_wait_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	__symbol_put	vmlinux	EXPORT_SYMBOL
+0x00000000	netpoll_send_udp	vmlinux	EXPORT_SYMBOL
+0x00000000	genphy_restart_aneg	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enter_sleep_state_s4bios	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_claim_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	get_zeroed_page	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_read	vmlinux	EXPORT_SYMBOL
+0x00000000	input_close_device	vmlinux	EXPORT_SYMBOL
+0x00000000	key_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_create_link	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_silence_64	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_connect_direct	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_std_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_connector_update_edid_property	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_insert_flip_string_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_from_user_ll_nocache_nozero	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_unplug	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_to_wait_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dev_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_action_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_height	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_size_t	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	remove_proc_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_opt_accepted	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_spd_getinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_release_from_disk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_is_partially_uptodate	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap_atomic_pfn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_load_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_snd_pcm_hw_param_setempty	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_resume_port	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_add_to_lists	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_handle_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_ieee1284_ecp_read_data	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_ieee1284_epp_read_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ahash_free_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dquot_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_register_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_std_bios_param	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_agp_release	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_clflush_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_hotplug_dock_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pagecache_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_clone_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_resolv_usage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_unregister_client	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_inner_extract_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_l4proto_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	probe_kernel_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmap_atomic_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	do_rw_taskfile	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_set_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_prune_invalid	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	timecompare_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	complete_and_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_default_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_file_from_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_read_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unregister_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_rx_ni	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_xfer	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_begin_command	vmlinux	EXPORT_SYMBOL
+0x00000000	device_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_user_iov	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_commit_info	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_putc	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_puts	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_remove_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hpet_mask_rtc_irq_bit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_seq_autoload_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_param_last	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_dev_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_update_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	part_round_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_add_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_genocide	vmlinux	EXPORT_SYMBOL
+0x00000000	__module_put_and_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_populate_width_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmi_walk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_dispatch_add_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	end_buffer_write_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	d_rehash	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_poison_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_build_dmatable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_class	vmlinux	EXPORT_SYMBOL
+0x00000000	__bdevname	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_write	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_nx	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_rx	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_refine	vmlinux	EXPORT_SYMBOL
+0x00000000	iw_handler_set_spy	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_stateonly_find	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_create_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_type	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_init_encode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_bonding_change	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_request_io	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_check_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_generic_walker	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_clear_event	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_release_declared_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_off	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_scan_done	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_xmit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_eh_analyze_ncq_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	registered_fb	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	find_vpid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_populate_sync_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_host_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unmap_mapping_range	vmlinux	EXPORT_SYMBOL
+0x00000000	overflowuid	vmlinux	EXPORT_SYMBOL
+0x00000000	overflowgid	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_select_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_present_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	wireless_send_event	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_release_xprt_cong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_allocate_dma_engine	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dcache_dir_close	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_get_page_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up_queued_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_snap_client	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_irq_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_driver_register	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dma_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_set_legacy_decoding	vmlinux	EXPORT_SYMBOL
+0x00000000	relay_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_put_port	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_print_status	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_remove_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_mark_dquot_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_acquire_global_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inotify_get_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	num_k8_northbridges	vmlinux	EXPORT_SYMBOL
+0x00000000	need_conntrack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_subset	vmlinux	EXPORT_SYMBOL
+0x00000000	set_normalized_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_type_trans	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_debug_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	ei_get_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_blob	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_entry_get	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_insert_mixed	vmlinux	EXPORT_SYMBOL
+0x00000000	send_sig	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_to_user_fromio	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_set_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_nonblockable_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_count	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_lid_notifier_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	down_write_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_init_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_md5_do_add	vmlinux	EXPORT_SYMBOL
+0x00000000	net_disable_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_ctrl_transfer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdrom_open	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_get_lba_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_scsi_slave_config	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_pci_device_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_partsize	vmlinux	EXPORT_SYMBOL
+0x00000000	ioremap_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_port_pbar_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_pci_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	groups_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_release_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	down	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sysfs_connector_add	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_unicast_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_put	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_put	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_proto_in_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnl_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_domain_release_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x00000000	add_wait_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_add_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hub_clear_tt_buffer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_helper_connector_dpms	vmlinux	EXPORT_SYMBOL
+0x00000000	strrchr	vmlinux	EXPORT_SYMBOL
+0x00000000	strnchr	vmlinux	EXPORT_SYMBOL
+0x00000000	balance_dirty_pages_ratelimited_nr	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_device_load_drivers	vmlinux	EXPORT_SYMBOL
+0x00000000	vsnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_replace_node	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_get_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_put_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_mod_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_clear_err	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_tcp_reordering	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_pow2	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_keycode	vmlinux	EXPORT_SYMBOL
+0x00000000	__ide_dma_bad_drive	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_pci_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_preload	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_quota_on_mount	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_board_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	parport_irq_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_register_irq_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_tstamp_tx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_set_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_copy_le	vmlinux	EXPORT_SYMBOL
+0x00000000	memscan	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_buffer_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	get_super	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_scheduled_work	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	block_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	ll_rw_block	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_set_alarm_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_sendbyte	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_unpack_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_rphy_free	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inet_conn_request	vmlinux	EXPORT_SYMBOL
+0x00000000	resume_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_detach_data	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_get_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_unregister_ioapic	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_proc_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_get_sense	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_intx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kref_init	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_spawn_tfm2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_mac_address	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_open	vmlinux	EXPORT_SYMBOL
+0x00000000	pccard_get_tuple_data	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_generic_free_by_type	vmlinux	EXPORT_SYMBOL
+0x00000000	kd_mksound	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_os_unmap_memory	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_segment_checks	vmlinux	EXPORT_SYMBOL
+0x00000000	net_namespace_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_register	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_close	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_link_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	loop_register_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	nmi_active	vmlinux	EXPORT_SYMBOL
+0x00000000	avail_to_resrv_perfctr_nmi_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_portimportance	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_withdraw	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_register_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnl_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_register_fixup_for_uid	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_add_list	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_pio_need_iordy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	end_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x00000000	rfc1042_header	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_nat_decode_session	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_under_panic	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_midi_event_encode	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_writev	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_proto_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_lookup_established	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_put_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_rebind_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_print_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_unhash	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_bus_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	cpumask_next_and	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_hook_slow	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_open	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflate_workspacesize	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_limit_hw_rates	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_bus_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_client_register	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_sff_activate_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_scsi_queuecmd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_timing_cycle2mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec_userhz_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	console_start	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_simple_retransmit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_register_match	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	anon_inode_getfile	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_dir_inode_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	genphy_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	__find_get_block	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_dir_open	vmlinux	EXPORT_SYMBOL
+0x00000000	put_unused_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_64_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__this_cpu_off	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_first	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_module_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_dummy_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_change_queue_depth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_disable_gpe	vmlinux	EXPORT_SYMBOL
+0x00000000	zero_fill_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_hda_parse_generic_codec	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_root_buses	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_ready_devs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_pad_unaligned_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_buffered_write	vmlinux	EXPORT_SYMBOL
+0x00000000	set_irq_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	system_entering_hibernation	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_register_device_for_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_cooling_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	input_open_device	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_policy_len	vmlinux	EXPORT_SYMBOL
+0x00000000	fsync_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	_read_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_giwrange	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_set_retrans_timeout_def	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_dst_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_new_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_for_each_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_set_name	vmlinux	EXPORT_SYMBOL
+0x00000000	timespec_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_uc	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_free_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_processor_set_thermal_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enable_gpe	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_key_type	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_rtc_dropped_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_shutdown_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_dp_aux_add_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	_ctype	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_set_size	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_get_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_write_cis_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_dma_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_xprt_names	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_sk_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	input_inject_event	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_read_config_dword	vmlinux	EXPORT_SYMBOL
+0x00000000	memparse	vmlinux	EXPORT_SYMBOL
+0x00000000	block_truncate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_checks	vmlinux	EXPORT_SYMBOL
+0x00000000	do_gettimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	do_settimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_increment_features	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_match_port	vmlinux	EXPORT_SYMBOL
+0x00000000	flow_cache_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_tty_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_port_service_register	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_selected_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	__splice_from_pipe	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__current_task	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_ct_ext_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_register_governor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_id_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_is_sas_phy	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_write_room	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_processor_register_performance	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_add_file_to_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dquot_release_reserved_space	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_trans_start	vmlinux	EXPORT_SYMBOL
+0x00000000	default_blu	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_power_manageable	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_register_region	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_put	vmlinux	EXPORT_SYMBOL
+0x00000000	_write_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	task_tgid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rts_get	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_unicast_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_target_device	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_force_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_msi_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_needs_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	grab_cache_page_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_sync_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_internal_device_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_video_register	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_overflowuid	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_up_process	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_get_port	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_refresh_acct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_dequeue_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_kernel_client_enqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_erase	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_cdrom_command	vmlinux	EXPORT_SYMBOL
+0x00000000	atapi_cmd_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_is_sas_port	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_target_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	__module_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arch_debugfs_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_stream_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_get_device	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_complete_request	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_tested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_unmap_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_drain_fifo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_inotify_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ns_to_timeval	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_acknowledge	vmlinux	EXPORT_SYMBOL
+0x00000000	__delay	vmlinux	EXPORT_SYMBOL
+0x00000000	get_sb_single	vmlinux	EXPORT_SYMBOL
+0x00000000	add_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_power_off	vmlinux	EXPORT_SYMBOL
+0x00000000	__neigh_for_each_release	vmlinux	EXPORT_SYMBOL
+0x00000000	dpm_suspend_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_initialize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_init_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	user_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dquot_alloc_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	bdget	vmlinux	EXPORT_SYMBOL
+0x00000000	bdput	vmlinux	EXPORT_SYMBOL
+0x00000000	fsstack_copy_inode_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_untracked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_usual_ignore_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_output_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_broken_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_em_register	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_cmd_to_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fs_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdrom_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_init_pc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_debug_printmodeline	vmlinux	EXPORT_SYMBOL
+0x00000000	strncpy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_ablkcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_init	vmlinux	EXPORT_SYMBOL
+0x00000000	all_vm_events	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_max_payload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_rate_est	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_partial_csum_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	create_empty_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	init_special_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_make_writable	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_chk_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_major	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_to_file	vmlinux	EXPORT_SYMBOL
+0x00000000	__mod_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	__inc_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	__dec_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	release_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	brioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	device_schedule_callback_owner	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vm_insert_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	out_of_line_wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	register_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_pause_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_is_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_remove_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	freq_reg_info	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_route_forward	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_exec_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfsacl_encode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfsacl_decode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_replace_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_target_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_null	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_abort_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_logical_block_size	vmlinux	EXPORT_SYMBOL
+0x00000000	init_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	reserve_evntsel_nmi	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_cache_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_tbl	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_ieee1284_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enable_event	vmlinux	EXPORT_SYMBOL
+0x00000000	nr_cpu_ids	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_opaque_fixed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_match	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_os_execute	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_agp_acquire	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sysrq_key	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_set	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_get	vmlinux	EXPORT_SYMBOL
+0x00000000	find_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_node_attached	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_conntrack_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lock_sock_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_free_command	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_add_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	k_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_icv_walk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_dump_table	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_interval_refine	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mpage_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	set_security_override	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_stack	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_subsys_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_read_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_dev_pair	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dh_activate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_core_reclaim_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_fb_helper_free	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_set_gpe_type	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_del	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_exit_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_find_numid	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_reset_endpoint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_last_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_initwait	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_ext_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_unregister_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_reset_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	rate_control_send_low	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_radiotap_iterator_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_reqsk_queue_prune	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_state_change	vmlinux	EXPORT_SYMBOL
+0x00000000	sort	vmlinux	EXPORT_SYMBOL
+0x00000000	security_unix_may_send	vmlinux	EXPORT_SYMBOL
+0x00000000	clockevents_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_sg_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_tun_dev_post_create	vmlinux	EXPORT_SYMBOL
+0x00000000	kern_path	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_queue_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	netpoll_print_options	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_alloc_from_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	__sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x00000000	shrink_dcache_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_hp_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkdev_issue_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	default_backing_dev_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_k8_northbridges	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cookie_check_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_drop_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_inode_number	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_init_sw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcb_getport_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_agp_version	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	dbgp_external_startup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sys_tz	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_processor_preregister_performance	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_id	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_fb_info	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sysfs_hotplug_event	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_auth_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_type	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ip_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_register	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_regions_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_init_sleeper	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	printk_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_compat_output	vmlinux	EXPORT_SYMBOL
+0x00000000	_snd_pcm_hw_params_any	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_from_user_ll_nozero	vmlinux	EXPORT_SYMBOL
+0x00000000	user_path_at	vmlinux	EXPORT_SYMBOL
+0x00000000	module_put	vmlinux	EXPORT_SYMBOL
+0x00000000	console_set_on_cmdline	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_from_anchor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_link_hardreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_install_address_space_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_get_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_helper_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_driver_string	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_get_readrq	vmlinux	EXPORT_SYMBOL
+0x00000000	security_d_instantiate	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_mkdir	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_available_nodes	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_driver_claim_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_print_status	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sysfs_connector_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_fileget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	max_mapnr	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_unregister_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_fget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_new	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_mmap_data	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_dump_input	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic64_inc_return	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_create	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_find_update_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iunique	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_walk_done	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dgram_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	input_release_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_dev_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	get_unused_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_doulongvec_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_bss_get_ie	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	hwmon_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_store_new_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdev_evt_send_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_connector_attach_property	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_post_modeset	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_fb_helper_blank	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_renumber_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_attr_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_root_hub_lost_power	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_pci_bmdma_clear_simplex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_ssp_task_response	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_batches_completed_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	local_bh_enable_ip	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_rcv_encap	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	tt_msgs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_host_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_hp_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_acl_from_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrndup	vmlinux	EXPORT_SYMBOL
+0x00000000	console_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_tuple_taken	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_pmp_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_encode_word	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	auth_domain_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_deb_timing_normal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	new_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_restart_call_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_find_id	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_build_sense_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_get_new	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_get_new	vmlinux	EXPORT_SYMBOL
+0x00000000	argv_free	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unregister_family	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kset_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_net_sysctl_rotable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	llc_build_and_send_ui_pkt	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pio_queue_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_populate_ppr_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_detach_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_reset_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	__alloc_ei_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_pci_clk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sb_copy_data	vmlinux	EXPORT_SYMBOL
+0x00000000	user_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	__tasklet_hi_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	read_bytes_from_xdr_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_send	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_matches	vmlinux	EXPORT_SYMBOL
+0x00000000	edac_atomic_assert_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_sff_hardreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflateReset	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_onto	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_del	vmlinux	EXPORT_SYMBOL
+0x00000000	pneigh_enqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_alloc_name	vmlinux	EXPORT_SYMBOL
+0x00000000	soft_cursor	vmlinux	EXPORT_SYMBOL
+0x00000000	rwsem_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	pcmcia_release_window	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_get	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_fh_to_dentry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	try_to_del_timer_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_addsock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_expect_related_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_bulk_transfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_init_termios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_device_io	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_bounce	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_device_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_port_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_dev_present	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_get	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_put	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_instance2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	read_dev_sector	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_ifnum_to_if	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_x16	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_create	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_destroy_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdrom_mode_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_device_create	vmlinux	EXPORT_SYMBOL
+0x00000000	strcat	vmlinux	EXPORT_SYMBOL
+0x00000000	qtree_delete_dquot	vmlinux	EXPORT_SYMBOL
+0x00000000	dqstats	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_release	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	pfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_listxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_get_pages_contig	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_tx_status	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk_done	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_create_dflt	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_set_queue_tempo	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_add_one_port	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_agp_info	vmlinux	EXPORT_SYMBOL
+0x00000000	key_put	vmlinux	EXPORT_SYMBOL
+0x00000000	get_inotify_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bmap	vmlinux	EXPORT_SYMBOL
+0x00000000	kmemdup	vmlinux	EXPORT_SYMBOL
+0x00000000	__blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_vrefresh	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_set_crtcinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_register_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_gro_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_sysrq_key	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_filesystem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_table_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_zone_bind_cooling_device	vmlinux	EXPORT_SYMBOL
+0x00000000	do_munmap	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aalg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_interval_list	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_fb_helper_fill_var	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_fixup_device	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_flush_inodes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_find_acq_byseq	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	i8042_check_port_owner	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_make_virtual_master	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_allocate_region	vmlinux	EXPORT_SYMBOL
+0x00000000	memory_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_get_acqseq	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_policy_rwsem_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_iterate_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic64_inc	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_reserve	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	netpoll_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_abort_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_port_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_sense_desc_find	vmlinux	EXPORT_SYMBOL
+0x00000000	default_grn	vmlinux	EXPORT_SYMBOL
+0x00000000	ioread16_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rate_control_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unicast	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_linear	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_disk_node	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_work	vmlinux	EXPORT_SYMBOL
+0x00000000	dequeue_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_gro_reset_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_generic_destroy_page	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_hp_hw_control_from_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_ablkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6t_register_table	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_bundle_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_tf_from_fis	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ec_burst_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_tfm_in_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	backlight_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_blocked	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_wmem	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_frags_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_change_net_namespace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_setup_pci_noise	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_rescan_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_rq_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_twsk_destructor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_detach_fds	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_pre_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_irq_type	vmlinux	EXPORT_SYMBOL
+0x00000000	put_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mce_chrdev_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_insert_flip_string	vmlinux	EXPORT_SYMBOL
+0x00000000	rdmsr_safe_regs_on_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_proto_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	llc_sap_list_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_pernet_gen_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fb_helper_add_connector	vmlinux	EXPORT_SYMBOL
+0x00000000	get_default_font	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_get_request	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_inform_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cpufreq_driver_getavg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_remove_fixed_event_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_ft_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_fl_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_it_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_il_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_tkip_key	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_update_rtt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_frequency_table_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_wait_after_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_suspend_all	vmlinux	EXPORT_SYMBOL
+0x00000000	misc_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_match_device_ids	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_one_len	vmlinux	EXPORT_SYMBOL
+0x00000000	relay_buf_full	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_write_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_x	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_rtc_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	register_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sound_mixer	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_geometry_proc_fops	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_intr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_parse_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_dec_and_mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_write	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	parport_pc_unregister_port	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_wipe	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_data_to_8023	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_sdp_session_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_parse_events	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_writepages	vmlinux	EXPORT_SYMBOL
+0x00000000	register_8022_client	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_private_data_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_set_default_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_equiv_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioread32	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_basic	vmlinux	EXPORT_SYMBOL
+0x00000000	percpu_counter_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	create_mnt_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_map_ram	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawrite_range	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_cmsg_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_report_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_set_dma_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alg_sem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_sector_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_fddidev	vmlinux	EXPORT_SYMBOL
+0x00000000	inverse_translate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_os_read_port	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_unblock_user_cfg_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hpet_set_rtc_irq_bit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_idle_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_exec_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_pad_aligned_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_exec_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_complete_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_generic_mask_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	interruptible_sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	IO_APIC_get_PCI_irq_vector	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_get_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_extract_package	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateInit2	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_plug_device_unlocked	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_free	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_oss_info_register	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_alloc_noncoherent	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lro_flush_pkt	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	vprintk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_syncookies	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	vsprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_splice_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_find_class_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_lock_free	vmlinux	EXPORT_SYMBOL
+0x00000000	register_key_type	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_create_masq	vmlinux	EXPORT_SYMBOL
+0x00000000	grab_cache_page_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__get_user_1	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_1	vmlinux	EXPORT_SYMBOL
+0x00000000	class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf16s_to_utf8s	vmlinux	EXPORT_SYMBOL
+0x00000000	__cond_resched_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_get_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_on_sync_kiocb	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_set_max_ratio	vmlinux	EXPORT_SYMBOL
+0x00000000	redirty_page_for_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_ctstoself_get	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_htable_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_stream_kill_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_port_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_get_dqinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_set_dqinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	need_ipv4_conntrack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_queue_reset_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_set_firmware_waking_vector	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_initialized	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__timecompare_update	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_preallocate_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_interrupt_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	byte_rev_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__elv_add_request	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_bh_page	vmlinux	EXPORT_SYMBOL
+0x00000000	free_user_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	strcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_destroy_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_sense_invalidCDB	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_fixstring	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_ieee1284_read_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	parport_claim_or_block	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_pair_get_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_pair_get_pty	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_get_buffer_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	key_payload_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blocking_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_insert_dying_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	get_cpu_sysdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_register_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	node_states	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_lookup_minor_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	auth_unix_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_delete_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_pci_shutdown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_cable_40wire	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_pci_dma_base	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fb_helper_set_par	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_set_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwmlme	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwmode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwmode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwrate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwrate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_send_auth_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	i8042_command	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_cable_unknown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmem_cache_size	vmlinux	EXPORT_SYMBOL
+0x00000000	regulatory_hint	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_rfkill_start_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_extd_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_generate_netlink_event	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_get_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_register	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_target	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_forward2port	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	device_create_vargs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_hangup	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_disable_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	framebuffer_release	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_xor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_bit_bitmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_free_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_destroy_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i8042_unlock_chip	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_apply_custom_regulatory	vmlinux	EXPORT_SYMBOL
+0x00000000	svcauth_unix_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_poll_rh_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_find_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_getattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_setattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_read_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_unhash	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_lookup_rqst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ct_sip_parse_header_uri	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	truncate_pagecache	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	NS8390_init	vmlinux	EXPORT_SYMBOL
+0x00000000	vc_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_generate_proc_event	vmlinux	EXPORT_SYMBOL
+0x00000000	__generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	_local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	try_wait_for_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_ispublished	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_do_start_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_active_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_rx_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_find_device_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_secctx_to_secid	vmlinux	EXPORT_SYMBOL
+0x00000000	mtrr_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_global_free	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_walk_init	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_writev	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_policy_rwsem_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_target_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_connector_list_update	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_dbg_level	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_purge_cached_objects	vmlinux	EXPORT_SYMBOL
+0x00000000	commit_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_expect_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_vlb_clk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_register_client	vmlinux	EXPORT_SYMBOL
+0x00000000	match_hex	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_unregister_sockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_realloc_headroom	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_attr_em_message	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_find_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	uhci_reset_hc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_close_end	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_personality	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_bios_param	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sas_attach_transport	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_core_ioremap_wc	vmlinux	EXPORT_SYMBOL
+0x00000000	register_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcipher_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwauth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwauth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_unregister_afinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcmcia_socket_dev_late_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_copy_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_verify_command	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrdup	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_policy_rwsem_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_bmdma_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_host_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_device_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_atomic_dec_and_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	key_update	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_register_km	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_dec_group	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_get_options	vmlinux	EXPORT_SYMBOL
+0x00000000	kasprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_setxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_getxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_init_data	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_free_one	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_dma_test_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ide_dma_lost_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp3_generic_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_unload_table_id	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_sleep_type_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_queue_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	class_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite16be	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite32be	vmlinux	EXPORT_SYMBOL
+0x00000000	scatterwalk_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_query	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_release	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_start_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_create	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_CB_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_connector_init	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	log_start_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_get_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	intelfb_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	__round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	check_tsc_unstable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_pool_stats_open	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__serio_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_put_char	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	__rt_mutex_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_sockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_rate_to_rate_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_target_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_sman_init	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_work_on	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_output_key	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_lost_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_fs_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_list_next	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_dma_unmap_sg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_pages_array_wb	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_chk_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_get_best_pio_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_suspend_port	vmlinux	EXPORT_SYMBOL
+0x00000000	__blkdev_driver_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_alloc_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_phys_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	totalhigh_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_find_tlv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_changeaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_recycle_check	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unregister_ldisc	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_inode_pages2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_michael_mic_failure	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_do_table	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_seq_dump_var_event	vmlinux	EXPORT_SYMBOL
+0x00000000	_snd_ctl_add_slave	vmlinux	EXPORT_SYMBOL
+0x00000000	led_classdev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_calculate_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_possible_config	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	add_to_page_cache_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	x86_mce_decode_callback	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_prepare_input	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_find_target	vmlinux	EXPORT_SYMBOL
+0x00000000	ide_pio_bytes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_object_find	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_portunreliable	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_proc_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_mii_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	dget_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	__release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	complete_all	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_set_vt_switch	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_free_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_register	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_data	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_clear_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_param_value	vmlinux	EXPORT_SYMBOL
+0x00000000	pccard_get_next_tuple	vmlinux	EXPORT_SYMBOL
+0x00000000	hex_asc	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_time_unix2fat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	per_cpu__x86_cpu_to_apicid	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_follow_master	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_ratelimit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	agp_free_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	agp_copy_info	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_get_pgrp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strncasecmp	vmlinux	EXPORT_SYMBOL
+0x00000000	default_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwpower	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwpower	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_read_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_use_lock_sync_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_do_probe_ddc_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_peeraddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_fragment	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_prep_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	match_octal	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_map_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_targets	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_freewait	vmlinux	EXPORT_SYMBOL
+0x00000000	si_meminfo	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_cmos_read	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_pause	vmlinux	EXPORT_SYMBOL
+0x00000000	current_umask	vmlinux	EXPORT_SYMBOL
+0x00000000	get_fs_type	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_iterate_active_interfaces	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_driver_kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_get_private_data	vmlinux	EXPORT_SYMBOL
+0x00000000	dquot_acquire	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_prot_inuse_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	tipc_set_portimportance	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sound_dsp	vmlinux	EXPORT_SYMBOL
+0x00000000	genphy_config_aneg	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_check_used_features	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_copy_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kzfree	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	sas_slave_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_bus_generate_proc_event4	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_removexattr	vmlinux	EXPORT_SYMBOL
+0x00000000	deactivate_super	vmlinux	EXPORT_SYMBOL
+0x00000000	vmap	vmlinux	EXPORT_SYMBOL
diff -Naur /home/jara/linux-2.6.32/pap.cfg /usr/src/linux/pap.cfg
--- /home/jara/linux-2.6.32/pap.cfg	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/pap.cfg	2013-08-29 15:36:25.000000000 -0300
@@ -0,0 +1,2545 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32
+# Sat Feb 23 06:36:03 2013
+#
+# CONFIG_64BIT is not set
+CONFIG_X86_32=y
+# CONFIG_X86_64 is not set
+CONFIG_X86=y
+CONFIG_OUTPUT_FORMAT="elf32-i386"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_TIME_VSYSCALL is not set
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+# CONFIG_HAVE_CPUMASK_OF_CPU_MAP is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ZONE_DMA32 is not set
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+# CONFIG_AUDIT_ARCH is not set
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_X86_32_SMP=y
+CONFIG_X86_HT=y
+CONFIG_X86_TRAMPOLINE=y
+CONFIG_X86_32_LAZY_GS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_USER_SCHED is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_NS=y
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+CONFIG_RELAY=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_X86_MPPARSE=y
+# CONFIG_X86_BIGSMP is not set
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_MRST is not set
+# CONFIG_X86_RDC321X is not set
+# CONFIG_X86_32_NON_STANDARD is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_PARAVIRT_GUEST is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+CONFIG_M686=y
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+# CONFIG_GENERIC_CPU is not set
+CONFIG_X86_GENERIC=y
+CONFIG_X86_CPU=y
+CONFIG_X86_L1_CACHE_BYTES=64
+CONFIG_X86_INTERNODE_CACHE_BYTES=64
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_X86_XADD=y
+# CONFIG_X86_PPRO_FENCE is not set
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=5
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_CYRIX_32=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_CPU_SUP_TRANSMETA_32=y
+CONFIG_CPU_SUP_UMC_32=y
+# CONFIG_X86_DS is not set
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+# CONFIG_IOMMU_HELPER is not set
+# CONFIG_IOMMU_API is not set
+CONFIG_NR_CPUS=8
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+# CONFIG_X86_ANCIENT_MCE is not set
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+CONFIG_VM86=y
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+CONFIG_X86_REBOOTFIXUPS=y
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_X86_MSR=y
+CONFIG_X86_CPUID=y
+# CONFIG_X86_CPU_DEBUG is not set
+# CONFIG_NOHIGHMEM is not set
+CONFIG_HIGHMEM4G=y
+# CONFIG_HIGHMEM64G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_HIGHMEM=y
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_MEMORY_FAILURE is not set
+CONFIG_HIGHPTE=y
+CONFIG_X86_CHECK_BIOS_CORRUPTION=y
+CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
+CONFIG_X86_RESERVE_LOW_64K=y
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+# CONFIG_MTRR_SANITIZER is not set
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_EFI=y
+CONFIG_SECCOMP=y
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+CONFIG_HZ_1000=y
+CONFIG_HZ=1000
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+# CONFIG_KEXEC_JUMP is not set
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+CONFIG_X86_NEED_RELOCS=y
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_VERBOSE is not set
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_TRACE=y
+CONFIG_PM_TRACE_RTC=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HIBERNATION_NVS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+# CONFIG_PM_RUNTIME is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+# CONFIG_ACPI_POWER_METER is not set
+CONFIG_ACPI_SYSFS_POWER=y
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_VIDEO=y
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_HOTPLUG_CPU=y
+# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
+CONFIG_ACPI_THERMAL=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+# CONFIG_ACPI_DEBUG is not set
+# CONFIG_ACPI_PCI_SLOT is not set
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+# CONFIG_ACPI_SBS is not set
+# CONFIG_SFI is not set
+# CONFIG_APM is not set
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_DEBUG=y
+# CONFIG_CPU_FREQ_STAT is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPUFreq processor drivers
+#
+CONFIG_X86_ACPI_CPUFREQ=y
+# CONFIG_X86_POWERNOW_K6 is not set
+# CONFIG_X86_POWERNOW_K7 is not set
+# CONFIG_X86_POWERNOW_K8 is not set
+# CONFIG_X86_GX_SUSPMOD is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_SPEEDSTEP_ICH is not set
+# CONFIG_X86_SPEEDSTEP_SMI is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+# CONFIG_X86_CPUFREQ_NFORCE2 is not set
+# CONFIG_X86_LONGRUN is not set
+# CONFIG_X86_LONGHAUL is not set
+# CONFIG_X86_E_POWERSAVER is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+# CONFIG_PCI_GOOLPC is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_DMAR is not set
+CONFIG_PCIEPORTBUS=y
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+# CONFIG_PCIEASPM is not set
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_LEGACY is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_HT_IRQ=y
+# CONFIG_PCI_IOV is not set
+CONFIG_ISA_DMA_API=y
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+# CONFIG_OLPC is not set
+CONFIG_K8_NB=y
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_CARDBUS=y
+
+#
+# PC-card bridges
+#
+CONFIG_YENTA=y
+CONFIG_YENTA_O2=y
+CONFIG_YENTA_RICOH=y
+CONFIG_YENTA_TI=y
+CONFIG_YENTA_ENE_TUNE=y
+CONFIG_YENTA_TOSHIBA=y
+# CONFIG_PD6729 is not set
+# CONFIG_I82092 is not set
+CONFIG_PCCARD_NONSTATIC=y
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_FAKE is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ is not set
+# CONFIG_HOTPLUG_PCI_IBM is not set
+# CONFIG_HOTPLUG_PCI_ACPI is not set
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+# CONFIG_INET_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_DEFAULT_BIC is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_HTCP is not set
+# CONFIG_DEFAULT_VEGAS is not set
+# CONFIG_DEFAULT_WESTWOOD is not set
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_NETLABEL=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_MATCH_IPV6HEADER=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_MANGLE=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_INGRESS is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+# CONFIG_AX25 is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_CFG80211_DEFAULT_PS_VALUE=1
+# CONFIG_CFG80211_DEBUGFS is not set
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+# CONFIG_MAC80211_MESH is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_LEDS=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+CONFIG_PNP_DEBUG_MESSAGES=y
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_PMP=y
+CONFIG_SATA_AHCI=y
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_SVW is not set
+CONFIG_ATA_PIIX=y
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_PATA_ACPI is not set
+# CONFIG_PATA_ALI is not set
+CONFIG_PATA_AMD=y
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5535 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+CONFIG_ATA_GENERIC=y
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_MARVELL is not set
+CONFIG_PATA_MPIIX=y
+CONFIG_PATA_OLDPIIX=y
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PCMCIA is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+CONFIG_PATA_SCH=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_AUTODETECT=y
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+# CONFIG_DM_CRYPT is not set
+# CONFIG_DM_SNAPSHOT is not set
+CONFIG_DM_MIRROR=y
+# CONFIG_DM_LOG_USERSPACE is not set
+CONFIG_DM_ZERO=y
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# You can enable one or both FireWire driver stacks.
+#
+
+#
+# See the help texts for more information.
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+CONFIG_MACINTOSH_DRIVERS=y
+CONFIG_MAC_EMUMOUSEBTN=y
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_VETH=m
+# CONFIG_NET_SB1000 is not set
+# CONFIG_ARCNET is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+# CONFIG_ETHOC is not set
+# CONFIG_DNET is not set
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+# CONFIG_TULIP is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_ULI526X is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_HP100 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+CONFIG_AMD8111_ETH=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+CONFIG_FORCEDETH=y
+# CONFIG_FORCEDETH_NAPI is not set
+CONFIG_E100=y
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+CONFIG_NE2K_PCI=y
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_R6040 is not set
+# CONFIG_SIS900 is not set
+CONFIG_EPIC100=y
+CONFIG_SMSC9420=y
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+# CONFIG_ATL2 is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+CONFIG_E1000=y
+CONFIG_E1000E=y
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_R8169=y
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+CONFIG_SKY2=y
+# CONFIG_SKY2_DEBUG is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_TIGON3=y
+CONFIG_BNX2=y
+# CONFIG_CNIC is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_JME is not set
+CONFIG_NETDEV_10000=y
+# CONFIG_CHELSIO_T1 is not set
+CONFIG_CHELSIO_T3_DEPENDS=y
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_ENIC is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_NIU is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_BNX2X is not set
+# CONFIG_QLGE is not set
+# CONFIG_SFC is not set
+# CONFIG_BE2NET is not set
+CONFIG_TR=y
+# CONFIG_IBMOL is not set
+# CONFIG_IBMLS is not set
+# CONFIG_3C359 is not set
+# CONFIG_TMS380TR is not set
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+# CONFIG_PCMCIA_PCNET is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_WAN is not set
+CONFIG_FDDI=y
+# CONFIG_DEFXX is not set
+# CONFIG_SKFP is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+CONFIG_NETCONSOLE=y
+# CONFIG_NETCONSOLE_DYNAMIC is not set
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_VMXNET3=y
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_WACOM is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_APANEL is not set
+# CONFIG_INPUT_WISTRON_BTNS is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_WINBOND_CIR is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_SYNCLINK_GT is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_STALDRV is not set
+# CONFIG_NOZOMI is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_PNP=y
+# CONFIG_SERIAL_8250_CS is not set
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DETECT_IRQ=y
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_GEODE=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_NVRAM=y
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_IPWIRELESS is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_CS5535_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+# CONFIG_HPET_MMAP is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_I801=y
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_I2C_SCMI is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Graphics adapter I2C/DDC channel drivers
+#
+# CONFIG_I2C_VOODOO3 is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_SENSORS_APPLESMC is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_SENSORS_ATK0110 is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_THERMAL=y
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_SC520_WDT is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_ITCO_WDT is not set
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_SBC8360_WDT is not set
+# CONFIG_SBC7240_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83697HF_WDT is not set
+# CONFIG_W83697UG_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+# CONFIG_AGP_ALI is not set
+# CONFIG_AGP_ATI is not set
+# CONFIG_AGP_AMD is not set
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=y
+# CONFIG_AGP_NVIDIA is not set
+# CONFIG_AGP_SIS is not set
+# CONFIG_AGP_SWORKS is not set
+# CONFIG_AGP_VIA is not set
+# CONFIG_AGP_EFFICEON is not set
+CONFIG_VGA_ARB=y
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_I810 is not set
+# CONFIG_DRM_I830 is not set
+CONFIG_DRM_I915=y
+# CONFIG_DRM_I915_KMS is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_VESA is not set
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I810 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_GEODE is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_PROGEAR is not set
+# CONFIG_BACKLIGHT_MBP_NVIDIA is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=64
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_SEQ_DUMMY=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_HRTIMER=y
+CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_DMA_SGBUF=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_PCSP is not set
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5530 is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+CONFIG_SND_HDA_INTEL=y
+CONFIG_SND_HDA_HWDEP=y
+# CONFIG_SND_HDA_RECONFIG is not set
+# CONFIG_SND_HDA_INPUT_BEEP is not set
+# CONFIG_SND_HDA_INPUT_JACK is not set
+# CONFIG_SND_HDA_PATCH_LOADER is not set
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_SND_HDA_CODEC_ATIHDMI=y
+CONFIG_SND_HDA_CODEC_NVHDMI=y
+CONFIG_SND_HDA_CODEC_INTELHDMI=y
+CONFIG_SND_HDA_ELD=y
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_SND_HDA_CODEC_CA0110=y
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_SND_HDA_GENERIC=y
+# CONFIG_SND_HDA_POWER_SAVE is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_HIFIER is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SIS7019 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_USX2Y is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_US122L is not set
+CONFIG_SND_PCMCIA=y
+# CONFIG_SND_VXPOCKET is not set
+# CONFIG_SND_PDAUDIOCF is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_ALIX2 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_CLEVO_MAIL is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_BD2802 is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC=y
+
+#
+# Reporting subsystems
+#
+# CONFIG_EDAC_DEBUG is not set
+CONFIG_EDAC_DECODE_MCE=y
+# CONFIG_EDAC_MM_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+# CONFIG_INTEL_IOATDMA is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACER_WMI is not set
+# CONFIG_ASUS_LAPTOP is not set
+# CONFIG_FUJITSU_LAPTOP is not set
+# CONFIG_TC1100_WMI is not set
+# CONFIG_MSI_LAPTOP is not set
+# CONFIG_PANASONIC_LAPTOP is not set
+# CONFIG_COMPAL_LAPTOP is not set
+# CONFIG_SONY_LAPTOP is not set
+# CONFIG_THINKPAD_ACPI is not set
+# CONFIG_INTEL_MENLOW is not set
+CONFIG_EEEPC_LAPTOP=y
+# CONFIG_ACPI_WMI is not set
+# CONFIG_ACPI_ASUS is not set
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_ACPI_TOSHIBA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+CONFIG_EFI_VARS=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+CONFIG_SGI_PARTITION=y
+# CONFIG_ULTRIX_PARTITION is not set
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_X86_VERBOSE_BOOTUP=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_EARLY_PRINTK_DBGP=y
+# CONFIG_4KSTACKS is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+CONFIG_OPTIMIZE_INLINING=y
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_SECURITY_ROOTPLUG is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_IMA is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_AES_586=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_586 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+# CONFIG_CRYPTO_DEV_GEODE is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -Naur /home/jara/linux-2.6.32/scripts/basic/docproc /usr/src/linux/scripts/basic/docproc
--- /home/jara/linux-2.6.32/scripts/basic/docproc	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/basic/docproc	2014-06-14 14:24:09.000000000 -0300
@@ -0,0 +1,24 @@
+ELF              4   "      4    (      4   44                                      4  4                 h                               (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU f`3Vh?q^P                                                     	                                                                                               
+                                 #"          )K9                               X                            P              `                            D                            )                            t                                          f              5                                                                      m                                                        K                            ;              0              z                         __gmon_start__ libc.so.6 _IO_stdin_used fflush exit fopen __strdup perror fork putchar realloc fgets strlen strstr fseek stdout fclose malloc __ctype_b_loc getenv stderr execvp strncat getcwd fwrite waitpid fprintf strcmp __libc_start_main free GLIBC_2.1 GLIBC_2.3 GLIBC_2.0                                                ii         ii         ii   
+                             	  
+       $  (  ,  0  4  8  <  @  D  H  L  P  T  X  \  US    [  t   e    X[5%    %h    %h   %h   % h   %h    %h(   %h0   %h8   p%h@   `%hH   P%hP   @% hX   0%$h`    %(hh   %,hp    %0hx   %4h   %8h   %<h   %@h   %Dh   %Hh   %Lh   %Ph   p%Th   `%Xh   P%\h   @            1^PTRh0h@QVh0sUS= u?9s    9r[]t& '    Ut    t	$&    '    &    '    D$ $D$Mt& D$D$D$)t& D$ $D$t& UWVS  t$l$t& |$D$   4$  |$!uD$D<w$&    4$t& \$  
+t
+DY tJ fDB uL$,$Y\$t!ft
+DZ t  ,$|v \$t!ft
+DZ t  ,$xv \$   v ?t& t
+DY tJ fDB uL$,$y\$t!ft
+DZ t  ,$;v $  [^_]L$L$_&    UWVS$]$  $   8    }  D$C$]D$  CG:        C$D$8D$|x$
+   D$$$N$[^_]v H:P=I:P-J:PD$|PxPP3D$D$    D$    $D$|0xt& D$    $    D$	   D$   $	D$C$$   D$!   D$   $D$]D$7   D$   $D$8D$3   D$   $@D$D$6   D$   $tD$D$8   D$   $D$D$F   D$   $D$$   (D$D$$$   ,  $$  $   $(  $     \$  T     8  1      D$   $D$ $   D$7$)T$t$$QD$   D$   $KD$|$$   t& $  D$    T$$)$  tb   $   $$  $(  ,  t& $2X$    f  t& 	t& f  D$ |$0&    ,L$4t&    t
+u  uD$0D$@D$QD$ZD$D$L$D$    ,v U   W   VS,  $D  $@D$QtR~   V    t,DY utt1ZuG$@      5,  [^_]v '    UWVS<D$,'  R1t& 9u   $|D$$   D$$T$(L$(    @@Q@d   ~tD$   D$     v L$~0T$$iD$1T| :9D$D$ L$(D$9L$ u       L$,\$$    L$$uV$$<[^_]   $	|$           ZD$|        D$\        UWVS<  -$P  ~E1t& 9}.\$$uvt<  [^_]v t$/          
+  1tf  t    D$   4$D$E4$D$4$)T$%4$\$4$)|$=$MD$,=4$rD$_  $0  v D$D$   <$D$   D$<$|    t& Hu_t tt& DH u(uSsH tH ufXu_t E   D$E$]ED$4$T$]D$<$!T$$<  [^_]D$/ |$00f  D$	   D$   $	D$4$Z$   U]t& '    UWVSO   	  {)t$1ED$ED$E$9r[^_]$US t fu[]US    [	  Y[     	%s SRCTREE KBUILD_SRC r docproc:  depend %s	 Unknown option: %s
+ fork /scripts/kernel-doc exec  -docbook -function -no-doc-sections <!-- %s -->
+ -nofunction / EXPORT_SYMBOL_GPL EXPORT_SYMBOL PhhhhhhhhxUsage: docproc {doc|depend} file
+   Input is read from file.tmpl. Output is sent to stdout
+ doc: frontend when generating kernel documentation
+ depend: generate list of files referenced within file
+  Environment variable SRCTREE: absolute path to sources.
+                         KBUILD_SRC: absolute path to kernel source tree.
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             lo4   P   `
+                                                   oo   od                                                            *:JZjz
+*:JZjz        GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll                  D   o   44  ,                N         ``                V         PP                   ^   o   dd  >                k   o     @                z   	                           	                                  0                                                                                                                 H                          00                                                                                                                                                                                     x                          ``!                             h!                          0       h!  8                               !                                  @'  @     <         	              .                                                 (          H          l          4          `          P          d               	          
+                                                                 0                                                                       `                                                             (         5          K        Z        h   `                  t            0                                                                                                     P      0     "       *       3  m     ;      K  d    X       n                           `               x       0                                                                    #             5        ;             N             _             |               |                           `                                                                 &       8             J             \             m  d     z                      @Z                                                                        h                  $       2       =             O       T       f             v                h                                                            0             crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux docproc.c noaction noaction2 adddep adddep2 printline parse_file srctree kernsrctree find_export_symbols intfunc extfunc singfunc docsect exec_kernel_doc docfunctions _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC data_start symfilelist externalfunctions __libc_csu_fini _start __gmon_start__ _Jv_RegisterClasses _fp_hw realloc@@GLIBC_2.0 exitstatus getenv@@GLIBC_2.0 _fini putchar@@GLIBC_2.0 fgets@@GLIBC_2.0 __libc_start_main@@GLIBC_2.0 perror@@GLIBC_2.0 internalfunctions _IO_stdin_used free@@GLIBC_2.0 __data_start fflush@@GLIBC_2.0 __ctype_b_loc@@GLIBC_2.3 fseek@@GLIBC_2.0 defaultline fclose@@GLIBC_2.1 stderr@@GLIBC_2.0 execvp@@GLIBC_2.0 strlen@@GLIBC_2.0 fopen@@GLIBC_2.1 __dso_handle waitpid@@GLIBC_2.0 __DTOR_END__ __libc_csu_init printf@@GLIBC_2.0 fwrite@@GLIBC_2.0 fprintf@@GLIBC_2.0 strstr@@GLIBC_2.0 strncat@@GLIBC_2.0 __bss_start malloc@@GLIBC_2.0 entity_system symfilecnt getcwd@@GLIBC_2.0 _end stdout@@GLIBC_2.0 fork@@GLIBC_2.0 singlefunctions symbolsonly _edata strcmp@@GLIBC_2.0 __strdup@@GLIBC_2.0 exit@@GLIBC_2.0 __i686.get_pc_thunk.bx docsection main _init 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/scripts/basic/fixdep /usr/src/linux/scripts/basic/fixdep
--- /home/jara/linux-2.6.32/scripts/basic/fixdep	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/basic/fixdep	2014-06-14 14:24:09.000000000 -0300
@@ -0,0 +1,25 @@
+ELF              4         4    (      4   44                                                     P  t                            (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU Y-)F?fL/                         	      
+                                                                                                                            "       K9                              =              I                             5                                          .              W              P              B                                          |                                          s              l              )                 ,     e         __gmon_start__ libc.so.6 _IO_stdin_used exit perror realloc mmap strlen memcmp memcpy __ctype_b_loc stderr munmap __fxstat fwrite close open strchr fprintf __ctype_tolower_loc __libc_start_main GLIBC_2.3 GLIBC_2.0                                      ii         ii                              	  
+                    US    [  tN     D
+  X[5%    %h    %h   %h   %h   %h    %h(   %h0   %h8   p%h@   `%hH   P%hP   @%hX   0%h`    %hh   %hp    %hx   %h   %h   %h   1^PTRhphQVhUS= u?9s    9r[]t& '    Ut    t	$UWVSr1v       tl$$tE ,9|$\$$5= 8
+= [^_]$0$       '    $\$t$|$<$   9|)943(\$t$|$        UWVS,  T$+T$ &    9v)x
+uL$<
+u9u,  [^_]t& T$|$ \$l$<$,\$9D  v2&    _t@   =  w
+C 9r|$$,  [^_]f/v UWVS  D$:   $R  )D$H|$,+\$$jD<H $SD$p1     9vg    <\t< t<
+v    9w9   )T$H$|$t$aD$HD<H    s9w$D$D$$D$  [^_]    9ut& ; f9fw9]Qt& CSAt;t& zD$HBTD$H,>L$HL$$ D$HD$    $\D$,  D$,$H  L$$   D$1$t    L$,D$    D$   D$   L$D$$    D$4   $t  T$4T$(T$49T$(   L$4\$8l$<DD$0(=ONFIkt)=NFIGkt=FIG_   9\$(vU=CONFu;l$0w   uu;t$(sQu<_   ;|$(rv \$8l$<$t  D$D$4$T$,$k$]D$,$D$   D$   $>D$$   D$   D$   $D$VT$H$$   W$D$   D$T$$oT$$u)W0t& '    UVS   ECONFL  }  PP@T$$D$uD$    $  D$(D$\$$   D$TtfD$    \$D$   D$   D$$    jt[T$T*D$T4$D$J$   1[^]t& D$D$$$$\$D$+   D$   $lD$$   T$D$8$x$   D$   D$   $D$7$$   nU]t& '    UWVSO     )t$1ED$ED$E$9r[^_]$UStfu[]US    [l  Y[     fixdep:malloc fixdep: parse error
+ deps_%s := \
+ include/linux/autoconf.h arch/um/include/uml-config.h .ver   %s \
+ fixdep:  fixdep: mmap CONFIG_ _MODULE 
+%s: $(deps_%s)
+
+ $(deps_%s):
+ cmd_%s := %s
+
+ fixdep: %s is empty
+        $(wildcard include/config/%s.h) \
+  fixdep: sizeof(int) != 4 or wrong endianess? %#x
+   Usage: fixdep <depfile> <target> <cmdline>
+                          p      lo      4
+                                                    oo   ol                                                            &6FVfv        CONF    GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll                  D   o     $                N         44  `              V                             ^   o   ll  ,                k   o     0                z   	                           	                                pp  0                             @                           ,	                                                       ((  p                                                                                                                                                                                                       X                                                         $                        0         8                               $                                         2         	                                                               (          H          l                    4                    l               	          
+               p                                        (                                                                                                                                            (         5         K        Z        h   p                  t                                                           PT                                    
+                .       7         B             R             b  p     r                                                           (                                                                   ,     )        6       >             W       i             {                                    Z                                                                              &             E       P       U             i             {                                   p       crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux fixdep.c define_config strrcmp use_config parse_dep_file test.4555 _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC data_start open@@GLIBC_2.0 mmap@@GLIBC_2.0 __libc_csu_fini memcmp@@GLIBC_2.0 _start len_config __gmon_start__ _Jv_RegisterClasses _fp_hw realloc@@GLIBC_2.0 strchr@@GLIBC_2.0 _fini __libc_start_main@@GLIBC_2.0 perror@@GLIBC_2.0 _IO_stdin_used __data_start depfile __ctype_b_loc@@GLIBC_2.3 stderr@@GLIBC_2.0 memcpy@@GLIBC_2.0 strlen@@GLIBC_2.0 cmdline __dso_handle __DTOR_END__ __libc_csu_init printf@@GLIBC_2.0 close@@GLIBC_2.0 fwrite@@GLIBC_2.0 fprintf@@GLIBC_2.0 __bss_start size_config target __ctype_tolower_loc@@GLIBC_2.3 str_config _end __fxstat@@GLIBC_2.0 munmap@@GLIBC_2.0 _edata exit@@GLIBC_2.0 __i686.get_pc_thunk.bx main _init 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/scripts/basic/hash /usr/src/linux/scripts/basic/hash
--- /home/jara/linux-2.6.32/scripts/basic/hash	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/basic/hash	2014-06-14 14:24:09.000000000 -0300
@@ -0,0 +1,6 @@
+ELF              @4   D      4    (      4   44                                                                  $  $$               (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU U3V!ED                                                            K                               5              .              )                       __gmon_start__ libc.so.6 _IO_stdin_used exit printf __libc_start_main GLIBC_2.0                        ii   G                 US    [,  t        X[5%     %h    %h   %h   %h   1^PTRh h0QVh0US= u? 9s      9r[]t& '    U t    t	$ $$D$$           UWVS]}$tC    uLS     tu?\$$$    v :	uMP:
+uA@:u5S11t&    Huv U]t& '    UWVSO     w)t$1ED$ED$E$9r[^_]$UStfu[]US    [0  Y[     Usage: %s <djb2|r5> <modname>
+  djb2 %d
+ r5                                lo      
+   Q                                                  oxo   oj                                                    $        &6        GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll  ,                D   o                      N           `               V           Q                  ^   o   jj                  k   o   xx                   z   	                           	                                   0                             P                          @@  |                                                         4                                                                                                                                                 $$                                                                                                                                          0         8                               T                                    @     /         	              4                                                 (          H          l                                        j          x     	          
+                                   @                                                                       $                                                                                          (          5   p      K        Z         h                     t                                                     $        $                                  $     	                 $  @      +              :              N       U        [             x                               0Z                           (                                  0              crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux hash.c usage program _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC data_start __libc_csu_fini _start __gmon_start__ _Jv_RegisterClasses _fp_hw _fini __libc_start_main@@GLIBC_2.0 _IO_stdin_used __data_start __dso_handle __DTOR_END__ __libc_csu_init printf@@GLIBC_2.0 __bss_start _end _edata exit@@GLIBC_2.0 __i686.get_pc_thunk.bx main _init 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/scripts/conmakehash /usr/src/linux/scripts/conmakehash
--- /home/jara/linux-2.6.32/scripts/conmakehash	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/conmakehash	2014-06-14 14:24:12.000000000 -0300
@@ -0,0 +1,36 @@
+ELF              4          4    (      4   44                                                     4  \                           (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU UZY-Da                                                                                                        	   
+                                   ("           K8gUa                               v              M                            4              F              Z              S              .              ~              o              }              ;              )                      h         @         __gmon_start__ libc.so.6 _IO_stdin_used exit fopen perror puts stdin strtol fgets fclose __ctype_b_loc stderr fwrite strchr fprintf __libc_start_main GLIBC_2.1 GLIBC_2.3 GLIBC_2.0                                    ii         ii         ii                                 	  
+          US    [  t     d
+  X[5%    %h    %h   %h   %h   %h    %h(   %h0   %h8   p%h@   `%hH   P%hP   @%hX   0%h`    %hh   1^PTRhh QVh /US= u?9s    9r[]t& '    Ut    t	$WVS  f< ~@i   9tJ)	"1t& 39t*9|   ")f	 < [^_ D$*   D$   $D$`$A   t& VS<	u
+<	t< t<Ut[^{+uS DPtSDPtSDPtSDPtKSDHuD$   D$    $o    '    UWVSD  E  E@D$  :LD  B:M4  D$ ND$$1t&      =   u\$8&    D$$D$   $D$  D$
+   $p$<  A    T$8$<  	  &    	t t$<  #tt$8  D$    T$$ED$($8  ;$<  u  t& $<  	t t-D$,    i  |$(     T$(  D$,2  |$,     D$(9D$,  $<  <	u$<  <	t< t   K  T$(9T$,||$,9}$<  $<      v $<  	t t#H@D$T$  D$hT$$_ f&    zT$ D$T$D$$D$ $$B   +v t$(f$<  y$<   ,	#5    T$  D$VT$$$<  2$<  	u$<  	t t-B  $<  $<  9  1  L$,+L$()9  t$(9t$,19t$,}$<  $8  $<  D$    T$$rD$,$8  ;$<    |$(   $<  SD$(T$ D$@D$T$ $$A   T$$1$&1t& 4 =   uU1D$   B$D$ $D$6$   tE $D$   tu$f$t$$,   F1D$,11t$(v ;    S 
+&    ~   1)  $D$9|$,tR)t$;|$(}r$;|$(|$    $UD$D$ $$@   \$D$r $$A   p!T$,D$ D$T$D$T$,D$D$ |$D$T$T$(D$ T$$*$A   >D$ D$tD$lT$,D$(D$T$T$ D$ T$$$A   U]t& '    UWVSO     )t$1ED$ED$E$9r[^_]$UStfu[]US    [  |Y[     ERROR: Only 255 unicodes/glyph permitted!
+  Usage: 
+        %s chartable [hashsize] [hashstep] [maxhashlevel]
+  %s: Glyph number (0x%x) larger than font length
+    %s: Corresponding to a range of font positions, there should be a Unicode range
+    %s: Bad Unicode range corresponding to font position range 0x%x-0x%x
+   %s: Unicode range U+%x-U+%x not of the same length as font position range 0x%x-0x%x
+    %s: trailing junk (%s) ignored
+ /*
+ * Do not edit this file; it was automatically generated by
+ *
+ * conmakehash %s > [this file]
+ *
+ */
+
+#include <linux/types.h>
+
+u8 dfont_unicount[%d] = 
+{
+	    
+u16 dfont_unitable[%d] = 
+{
+	  - stdin r %s: Warning: line too long
+ Bad input line: %s
+ %s: Bad end of range (0x%x)
+ idem %3d 
+}; ,
+	 ,  0x%04x                                  lo    L   ,
+                         p               h            o(o   o                                                            6FVfv        GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll                  D   o       ,                N         ,,                 V         LL                    ^   o     $                k   o   ((  @                z   	      hh                     	        p                          0                                                           	                                                                                                                                                                                                                                                                D                                                                                  0         8                               0                                          /         	                                                               (          H          l                     ,          L                    (     	     h     
+                                                                                                                                                                                                     (         5   @      K        Z        h                     t                                                                                                                  0        7              F              Z       a             s        y                                                                                                      $             5       B       O   Z     _             q        z                                                                                          z                     crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux conmakehash.c addpair getunicode _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC data_start __libc_csu_fini _start __gmon_start__ _Jv_RegisterClasses _fp_hw strchr@@GLIBC_2.0 _fini fgets@@GLIBC_2.0 __libc_start_main@@GLIBC_2.0 perror@@GLIBC_2.0 _IO_stdin_used strtol@@GLIBC_2.0 __data_start __ctype_b_loc@@GLIBC_2.3 fclose@@GLIBC_2.1 stderr@@GLIBC_2.0 fopen@@GLIBC_2.1 __dso_handle __DTOR_END__ __libc_csu_init printf@@GLIBC_2.0 unicount fwrite@@GLIBC_2.0 fprintf@@GLIBC_2.0 __bss_start stdin@@GLIBC_2.0 _end puts@@GLIBC_2.0 _edata unitable exit@@GLIBC_2.0 __i686.get_pc_thunk.bx main _init 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/scripts/kallsyms /usr/src/linux/scripts/kallsyms
--- /home/jara/linux-2.6.32/scripts/kallsyms	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/kallsyms	2014-06-14 14:24:12.000000000 -0300
@@ -0,0 +1,30 @@
+ELF              4   #      4    (      4   44                                      h  h                                                (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU d$N'e+?B	^1                                                   	                                                          
+                                                        ("           K8gUa                              x                             J                            B              d                                                        j              _              )              X                            q                                          =              5                            0                              R         __gmon_start__ libc.so.6 _IO_stdin_used strcpy exit strncmp puts putchar realloc stdin printf feof fgets strlen strstr __isoc99_fscanf malloc stderr fwrite strchr qsort __ctype_toupper_loc memmove strcmp __libc_start_main free GLIBC_2.3 GLIBC_2.7 GLIBC_2.0                                           ii         ii         ii                                 	  
+       $  (  ,  0  4  8  <  @  D  H  US    [  t>       X[5%    %h    %h   %h   % h   %h    %h(   %h0   %h8   p%h@   `%hH   P%hP   @% hX   0%$h`    %(hh   %,hp    %0hx   %4h   %8h   %<h   %@h   %Dh   %Hh       1^PTRhhQVhPUS= u?9s    9r[]t& '    Ut    t	$UW1VS1T$u+W&       9\$t.D   9u u9\$uv  [^_]v D$Q   D$   $D$$   x        UWVS<  D$;D$$/  D$T$D$T4$b  l$;7  c   ugST$;$?PS$C  T$;T$$0C$/  1<  [^_]fSD$(T$,,$D$t   F,$D$]   u$/   A   i   -         #    :D$;l$<t& uc<  [^_]v D$(T$,FVt& D$(T$,FVt& Ut} $t7|$;$tNv kT$;t$D$  $\E$T$$D$T$$tE<.NFD$?   D$   $D$u$       '    $t$|$l$X@P~	{_St1$t$|$l$fz_uk   tO   t?   t/t   tt   t&    y&    '    \$\$t$t$|$l$CV>9sf\$t$|$l$t& v   &    9    w9r9rn{M Ww	Ww	9t)$$9t	)l1}_Mu&    :_t)1_ou&    :_t)9uF+C    '    StG\$D$$D$u1\$$[t& \$$    \$D$$[t& UWVS  $$
+$*$<$R$X$j$$   11D$3v w9rd+D$(T$,$D$T$9vh |$P
+<Ac  P-= 9|$(l$,s|$(l$,$)|$l$9w$
+   "$D$y$
+      $$       11l$(1    uL$(,D0$D$ Pt*1f@$D$ 9Xw$
+   / T09=v-l*v    P $T$D$sTl$($
+   &   t/1t& D $D$%   9w$
+   1t$0,$$0  17{D$( v  D$(,|$$L
+!%t  u )D$(   lu$
+   f1Zf$oD$F   u$
+     [^_]D$5   D$   $D$$   vv '    UWVST}~p      9~_E4D${4$tD$   D$4$  FV<"  <'  t5>'  kD$ $ tTk3t"$ub9s  kDD$   D$   $D$$   -D$D$   D$ $ D$@    D$L    T$<D$H    L$D\r9   9   9`  ^9%  ^D$1$+tiD$HD$@|$<9|$H\  t$Dt$@tV   R9t   = u1V9O`u@t/D$$x    r9'|$L9|$HtVkD$L   |$D\$<D$DHX~1T4 9|D$LkD$H9$D$P9^T$(L$,D$$T$(L$,jD$L     11T$D@;t$Ls01z t J	  ;Br|$L 9  D$LD$0   D$0    11=   t 9}=   uL$L5T$0Y   D$8    D$4        D$8 Xp\$HN  D$L1x\$@t$D;T$@%  8u|$LX:u\$@t$D  1t& T<, 9|D$0T$HD$<T$@\$<y)t$HD$H|$DL$<$D$l$@|$HvS\$H~HT$Lr1\$t& ;T$}$8u|$LX:utt$D{t& t$@ L$@T$8LL~%1    T 9|D$4\$4D$8;yl$0l$L|$0T1[^_]D$   D$   $D$$   >z"EB<&    sv z'U]t& '    UWVSO     C)t$1ED$ED$E$9r[^_]$US t fu[]US    [  Y[             Usage: kallsyms [--all-symbols] [--symbol-prefix=<prefix char>] < in.map > out.S
+   kallsyms failure: unable to allocate required amount of memory
+ kallsyms failure: unable to allocate required memory
+   %llx %c %499s
+ _text __kernel_syscall_via_break __kernel_syscall_via_epc __kernel_sigtramp __gp atd start_ stop_ end_ _start _end .globl %c%s
+ .globl %s
+ 	ALGN %c%s:
+ #include <asm/types.h> #if BITS_PER_LONG == 64 #define PTR .quad #define ALGN .align 8 #else #define PTR .long #define ALGN .align 4 #endif 	.section .rodata, "a" kallsyms_addresses 	PTR	_text + %#llx
+ 	PTR	_text - %#llx
+ 	PTR	%#llx
+ kallsyms_num_syms 	PTR	%d
+ kallsyms_names 	.byte 0x%02x , 0x%02x kallsyms_markers kallsyms_token_table 	.asciz	"%s"
+ kallsyms_token_index 	.short	%d
+ --all-symbols --symbol-prefix= out of memory
+ _compiled. No valid symbol.
+ _stext _etext _sinittext _einittext _stext_l1 _etext_l1 _stext_l2 _etext_l2 _SDA_BASE_ _SDA2_BASE_                         &7Z                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ,   \   lo       L
+                                    |   d            o$o   o                                                            r"2BRbr                                                                                                                    GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll                  D   o       ,                N         LL                V                            ^   o     4                k   o   $$  @                z   	      dd                     	      ||                          ,,  0                           \\  p                                                     \\                                                          dd                                                                                                                                                                                     d                          ``!                              !  @                       0       !  8                               "                                  '       <         	              8.  |                                               (          H          l                     L                              $     	     d     
+     |          ,          \                    \                    d                                                                       `                                                             (         5          K        Z        h   `                  t            d                  0                     }        4        P                       `            %      5       B  `    L       V        \       h       s  @$                                       `                                                              (              <       C             V             h  \      n                                                                          `                                  +  d     8             H             Z        e       r  Z                                                                                            	                                  1       8             J             Z  *     q  Pb    v  ,       crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux kallsyms.c expand_symbol usage read_symbol symbol_prefix_char _text text_ranges may_be_linker_script_provide_symbol compare_symbols output_label write_src table_cnt table all_symbols table_size special_symbols.3414 _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC data_start __libc_csu_fini qsort@@GLIBC_2.0 _start __isoc99_fscanf@@GLIBC_2.7 __gmon_start__ _Jv_RegisterClasses _fp_hw realloc@@GLIBC_2.0 strchr@@GLIBC_2.0 _fini putchar@@GLIBC_2.0 fgets@@GLIBC_2.0 __libc_start_main@@GLIBC_2.0 _IO_stdin_used __ctype_toupper_loc@@GLIBC_2.3 free@@GLIBC_2.0 __data_start token_profit stderr@@GLIBC_2.0 strlen@@GLIBC_2.0 __dso_handle feof@@GLIBC_2.0 strcpy@@GLIBC_2.0 best_table __DTOR_END__ __libc_csu_init printf@@GLIBC_2.0 best_table_len fwrite@@GLIBC_2.0 strstr@@GLIBC_2.0 __bss_start malloc@@GLIBC_2.0 stdin@@GLIBC_2.0 memmove@@GLIBC_2.0 _end puts@@GLIBC_2.0 strncmp@@GLIBC_2.0 _edata strcmp@@GLIBC_2.0 exit@@GLIBC_2.0 __i686.get_pc_thunk.bx main _init 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/scripts/kconfig/conf /usr/src/linux/scripts/kconfig/conf
--- /home/jara/linux-2.6.32/scripts/kconfig/conf	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/kconfig/conf	2014-03-01 13:46:58.000000000 -0300
@@ -0,0 +1,258 @@
+ELF              P4        4    (      4   44                                                                                      (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU b)zNV`C   K              4   .   )   ,   <       	   B   :           D   =       8   1           0   I           -   G      6   @              3   7          F      C      +               >       9       E       J               '   /          ?   5   (   2   ;   "                                                                        
+                                      H                                       !   $                             &                                      A       *   #   %                                                   @           }@   C   H   |(CEK8qXfUa2                             T                          l                                                                                                                                                           7                                                                                                                                      "                                                                    Y                           v                           a             '             Z                                        }              .             `              &                          A             b                          %             B                          h             N                                       o             U                                                       $             t                                         g              @       G        -       J   $F            4               :   $      4   E                       libncurses.so.5 __gmon_start__ _Jv_RegisterClasses _fini _init libc.so.6 _IO_stdin_used fflush strcpy exit sprintf _IO_putc setlocale srand fopen strncmp optind strrchr regexec __strdup dcgettext regfree putchar mkdir realloc stdin getpid strtol isatty fgets strlen __errno_location chdir read getopt clearerr vsnprintf ctime stdout fputc fputs memcpy fclose malloc strcat __ctype_b_loc getenv regcomp optarg stderr strncat fileno fwrite gettimeofday rename strchr __ctype_tolower_loc __xstat memmove uname bindtextdomain strcmp __libc_start_main vfprintf _edata __bss_start _end GLIBC_2.1 GLIBC_2.3 GLIBC_2.3.4 GLIBC_2.0                                                                                    @          ii   E     ii   O     ti	   Y     ii   e        I  D  F   A   J                   	   
+  $  (  ,  0  4  8  <  @  D  H  L  P  T  X  \  `  d  h  l  p  t   x!  |"  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  US    [  t     p  X[5%    %h    % h   %h   %h   %h    %h(   %h0   %h8   p%h@   `% hH   P%$hP   @%(hX   0%,h`    %0hh   %4hp    %8hx   %<h   %@h   %Dh   %Hh   %Lh   %Ph   %Th   %Xh   p%\h   `%`h   P%dh   @%hh   0%lh    %ph   %th    %xh   %|h   %h  %h  %h  %h   %h(  %h0  %h8  p%h@  `%hH  P%hP  @%hX  0%h`   %hh  %hp   %hx  %h  %h  %h  %h  %h  %h  %h  %h  p%h  `%h  P%h  @%h  0%h   %h              1^PTRhPEh`EQVh#US=$ u?(9s    ((9r$[]t& '    Ut    t	$tD$   D$(F$    $D$   D$G$    $|D$   D$G$    $X$   &    \$t$|$$  C:   `
+a $     @uB $)D$   $`D$L   \$t$|$v v;   D$`$F   \$t$|$    C:   iv D$   D$3F$    p$8&    4$1\$`
+t$a |$4$   \$t$|$v 4$1\$t$|$    ,\$$\$t$($d  \$4$  $   $0RD$$8,  \$$t$(,        WVS`fDB u$`t@D$\$$`t0``DJ tt&   DJ u[^_&    WVSXt& GD$   @$    D$D$2F$:FD$D$CtD$$AFk$   $[   D$ns      $N   D$GD$   $  K     <$     $F$^  -  h`<Y   ;  <MP  f     <?ft&  $M   D$D$    $+    'D$   $
+  0$MF*<$  $    $PF&    at2:UF!b:VFc:WF   t$$j6  f1[^_&    t[`v v <n    tf<yt& j<m=a    t$$5  f $Y   D$?    <NHat8SF1b:TF1t$$5  8#v $JF&    $GFD&    UWVSL$=  w  Got@v  `  ,  E8  E   _t& D$   G@$    D$FD$2F$:FD$D$C$AFD$$S  $I  tt$$Flt}`<
+A  <?  `
+!%t  u ``_ t$$v9  t&     [_tt& ut-L[^_]=@  <$c  D$   D$$    D$*   D$*   D$*   T$T$D$T$$XF1Xt& =a
+.     v GD$0$  T$0D$0R8$   T$4    T$0B  M  <$t  D$   $    D$D$2F$hFD$D$T$0B` _*  |$81D$<    t& $
+     $z:  tC  9  D$    $wFD$7$  D$   $    D$Gt$${FD$CPtT$$FC@:PD$   D$F$    $'<$'  D$   $    D$D$2F$hFD$D$o}a1t& |$8D$   D$FD$8$    ^T$8D$2FT$$   \$<t$$F<$    $F@     w    Vt4$8  t	  6uD$>   $wFD$ot$</9=kL[^_](  $Fv`T$0$*  D$0x; $BD$   $`D$e|`?  T$,T$, DPD$
+   D$    $`$  D$   $    D$D$*   $oFD$D$FL$4 \$$K%[$?   &`
+!%t  u `_?tND$   F$|.  ^Ft& 	uy1D$   D$F$    \$1D$2F$<.l+&    VS$!6  t*stF:ft&[t&    u[^t& 4$  uF8t~fu    HPHt$N  D$   D$F$    $r        UWVStu]|$hD$2F$   
+D$F$F$FD$F\$4$A  D5v9D$   D$F$    	D$$$   $I@   t& @   D   q&    D$    <$tD$lT$h$@   2@   #@   @   D$   D$F$    0$$    <@    @   &    9  $  D  =@   @$hJ$"G\$t\$D$$   d  @2    uOG\$t$$   )  \$D$nG$   	uD$    $nG`  t& =D  =@wQ@$J@   &    H    \5HufDtNa  t%$    V  tD$   D$IWf     1t[^_]&    $    V  t      $Kn  D$   D$H$    \$$$   $    m  D$   D$XI$    D$$   7$   DP  t& $   /P  $   P  $    P  $   O    t$yGVt	8    $    Mu1$   0t$       u  \$\$$   D$D$   D$G$    t$D$$$   t& D$    4$]  Kt v ]GAG4GD$   D$HX*]  D$   D$GSD$t=P@     PB $H@   @,    Ht(;t[P 4H [Df$v '     v '    v '    v '    v '    D$$    D$     D$    v '    D$    Tv '    PJtB        D$@&    SD$||t8u[[v '    D$|D$&    |t& D$    S\$ trv8tv [Cxu{ u   C    &    C$CC$C[    '    \$\$ t$t$$t;v1\$t$    $R&    19s\$t$t& 9st>19s\$t$&    [u&    t$C$it   \$t$t& t$C$ARt& \$\$ t$t$$ttbvt{t>1\$t$ut$C$   ut$C$9s\$t$    9suS   @t9su{ x        L$1T$9t
+v    $ Sttttfu   &    T$BtfB8 uu   fz4uf&    '    T$JwTq'    D$@<txut& xt& t ut& D$@<txut& xt& t ut& D$H8   @<t    PtJ ut& S1t& t4t& yt#A<I8   tt& PtJ u	u  u[        D$t$t$$PtFH4tv1$t$tKPD9s@8 tNv uF    @8 uH4=    u   H4uuv     19t& r9&    T$Bw#JKFtHFsv NFtBv '    D$P4;PDfD$@u1fw@fT$Jwq    <@&    '    @P<        <@<    '    T$Bt@R1tBfv '    D$=uv @=tPtzu&    D$@v D$@tv 2Fv '    S9t>t3t[    P$T$@ @D$qD$$;<u@<[        SD$ \$(P$T$@ @D$JD$$D$$\$D$$I$
+   D$[t& '    PJTtBD$L$D$J$%D$$D$D$ D$$$
+   D$3t& '    S(9HtG  Jw qL$ $qD$E1([t& <Y    ;t  wg q\$ $qD$<\$P$T$@ @D$JD$$"1([    D$J J$qD$fSD$ \$(P$T$@ @D$JD$$D$$\$D$$Y$
+   D$[t& '    ,\$$@t$(T$0KA9tItUJw4TqJwTqAt<t$T$D$D$r$(\$$t$(,t& Q\$$t$(,JSpD$J\$$D$lD$$D$ \$D$$\$
+   D$t[&    PJTtBD$L$D$J$<D$$D$D$ D$$$
+   D$JfVS1t$ t8u:t&&    Ct$$uC8tu[^Fun ty@tmt1t& Bu   yv $KetK$-K5tGGVSD$T$xw@$Sv M<,   f1[^r0uBr<Xt<xuZr&     
+&    DXtu   [^2Z<-tLsDBt0u<ftDBu_&    $4S    rZ1; t2f$   %`   \    X  h    d    ,   v t& W$,      1D$ B<BB TB$@_        WS\$$$(   _
+   1ZD$ BB TB$tC<t u[_<$   T$ T$$PT$(P'    $   T$ T$$PT$(P'    T$ D$$ttD$T$$   t& v '    T$ D$$ttD$T$$   it& v '    $   %@    T$ T$$P'    $   @    T$     P'    St tgvt8[f&    rCCCC[    {u $j$D$fCC[    VS$@\$4@D$D$0$@FD$8FD$<5Ft5DJ u5@PtD$WK4$@p^$[^    D$D$<K4$D$DB tt& DB uD$(D$    D$D$$D$D$ $t& D$(D$    D$D$$D$D$ $t& SD$ C@D$C$C[    D$$$T$(D$    T$D$D$ $    '    StevD$$hK1[$SC$   [&    C$   uC$   t& [u1t& Cu[&    WVS@@ct[^_&    _<u&    tCvC'u{uG8uCt& tt& L\$<\$Pt$@|$Dl$HC8tRC?  S<D$B$D$B @D$@rD$$.t$@\$<|$Dl$HLt&  w      n  s<fut& 6t~uVt(Jut& Jv tI8   RuC8   C8c8H  Fu&    b8@tPu   G8 f   G<uv      txu@t   19uVNt& J    C<u     txu@t
+v;1$Qt;CtRD$D$K$9t<v@@nv 1_   C8c8J1$
+   D$ntUumv UT$,$T$,tBD$KD$$Y'    t& \$\$ t$|$t7PvC$CC$Ct|t/tt$\$|$s>w$T&    CxuS t`T  @u   $RC    C    CxuS t   @b   C    PfF=@
+  =  = *$v   F@$Z1>t& ~4$9$1       F$   D$/   CF    t&    @$lrD$   C C    b@$rD$   C@C    6$   F $f   FS\$ tk   v L$$K\$ [v uu*tC$C$\$ [f[u[t& S\$ tt}t[C$CC$S:C   8uH    @u$hCPSPS$M&    C$eCC$WS:CtL8[H t@D$C$   C@C    J t$@uv J t@$C0$9C$.   C C    t& S\$ Ct$MC        [&    )t& S\$ tL$t(;t.Ku\$ [fC$\$ [     [v $tm(t`$($    uIt>(t1PHP 4 L   Dv (t& $t9t& (t($$(    4$u$1$    (    0    4    8    ,                 '    UWVS\D$p8 u1\[^_]D$D$0D$   $u11D$,    t$(D$,tW{tJC8uDCt=D$D$0D$    D$    D$    $quo9}BD$(uD$,|$,  ut$(t    D$0$5v T$(    D$$T$$T$$D$(u$p&    U1W   VS,|$@t$Dthf1   uCv s8u(t0C|$$uuC8t,[^_]t& <$T$$H   2   1T$	s8S,[^_]t& Gu"n ty@tmx1	Bu   t& '    \$t$D$$   4$D$   $iC\$t$v '    D$ t$t$$\$|$   t[t\$t$|$     $   D$@@$C\$t$|$    =@_C<K8   u   t&     xfu@t   1Xt$$,J\$D$ s<$L1&       @;BD$ r\$t$|$\$$   D$   4$6$G$   D$X4$t"t$|$\$
+f@@t$D$(s$w\@@JVSt$ u+v t"C4$D$u[^&    $   (     @    @    @    @    4$C[^t$t$$\$\$ |$4$4${t$\$|$ t& '    UWVSl$   t/C8x(SC8CT$\D$XCsCC    Cl[^_]&    _  =5C8 uC8G  C{s%  r  t& ,  fC8{st	  Cn     e  t$X   {t-C<K8   tfPtJ u9   s8   tzC<u&     txuHtWAtP      P8	P8t%P8@<t&    PtJ uItAus8   s8l[^_]s=l5pK4tC8   C8b  $  @hK8   ,$}p
+     t$D$    C$G@  9   {"  t$D$D$K4$&4$C*fC8 twK4   t   S8ts9vkDurS8A  CD9sC  C8   t& K4G@  92{    NS8S<u
+ftzuRt
+
+v19ZRt& t$D$D$F4${tf  W4uOs<u   6   ~uF$]  FtFt
+v1  G4t{x$t& 	  K8   @$  u9E$  ys<u	6t~uvu&t& &      o4qvt~uC    1U @(C8 t
+{4#= \$t$$Ct1u   Ct$D$    $\$t$t& 
+   '    1v tt& xt`8 u  u$   > t$='    WVS\$ t$${9tt$$1tPK8   u%C<  K8tt& PtJ u tt9   st
+,   [^_C<u&     txu@t
+v`1H8   X@<u     txu@tt& PJ4tJ8   @u9   sgl@&    '    WVSt$ ~ &       \$4$u+9t't2fr1!\$4$t[^_&       VS\$    vD$$K1[^$(TC$]C$RCPwHKFtHFrNFtPCHwXKFtHFrNFtHL$$,      [^t& C$C@[^C$C$CPwHKFtHFrNFtPCHwXKFtHFrNFtHL$$|P1[^C$}[^   )    C$]C$P9[^C$5C$(9&    '    SX<t#t& {uC$Cuu[t& '    \$\$ t$t$${w'C$HTt& t$$   t& 1\$t$ft$$t$\$ \$ht$$\tA  4$D$   D$       C@19|C   @9mv M<,Z$`T   4$D$
+   D$    {
+   C@U19C
+   @99&    D$$   \$ t$\$t& D$$        D$$          v t& '    ,\$\$0t$ t$4|$$l$(C   t$$   C8   u!  C8C<tPtJ u{4${h   tt$<$s   t8,$Ct$$<$9p   M<,v1\$t$ |$$l$(,$U    D$4   \$0t$ \$|$$l$(,tt& D$4        D$4       >0uF<X0<x(&    ,$C 0@x*v WV1SX<1t1t& CtC$v9Csu   9G4twO8G4G<O8tt& PtJ u uCW@1t$tL9GDt'GDG<O8   tt& PtJ u[^_O8v t    lWftu   5HG8 t4tts&    SD$ X<t{uC$_Cuu[t& '    WVS\$ {tWst`4$C@u0t:CPt0[u'&    t$t   [^_f1[^_&    G$G&    L\$<\$Pt$@t$T|$D|$Xl$H  +D$\l$$W~D$KD$    <$+vol$l$D$K,$l$D$    <$    D$D$\$~D$FD$    <$\$<t$@|$Dl$HL$UD$KD$    <$CPD$<$T$D$[OD$    <$CPD$<$T$D$!OD$    <$N    CP  T$D$<$(CPD$<$T$K
+D$KD$    <$D$   |$t$C$Rt& CP  T$D$<$D$KD$    <$CPD$<$T$CP*  T$D$<$D$KD$    <$CPt& D$KD$    <$D$   9    D$   |$t$C$}D$KD$    <$D$   |$t$C$MD$   |$t$C$-D$KD$    <$D$       D$NFD$    <$    D$JD$    <$V    D$JD$    <$    D$JD$    <$a&    '    D$$D$    D$D$D$ $Yt& D$$D$    D$D$D$ $)t&   = uAD$$2D$    $K
+$   H8   @     '    S\$($T$ $D$   T$D$8[\$\$ |$1t$tG$   ?SVSV;v:1$KD$4$    \$t$|$    $UCFCFCFfC$]FC$MFC$?Fv '    ,\$\$0t$ t$8|$$|$4l$(I  ;v1t$ \$|$$l$(,t& $V&    Cl$(t$8\$|$0t$ D$4|$$,t$D$   C$it$D$   C$P@    h  ]\$4D$0   \$t$ |$$l$(,kv t$D$   C$t$D$   C$@    uD$l$$   `q[4$It& t>@tRt^ ~\$0t$ \$|$$l$(,f    @tt@ @$<D$4v D$0@\$t$ |$$l$(,pD$0     D$l$$   l}t& S(T$0L$4;t1([&    w$,Vt& B;AfB;AuB;AfAD$B$t& $hD$0D$4$XD$4D$4D$D$0$  T$0:t)1D$$T$4$D$<D$48uJ;HUWVS\$0l$4|$8t$<9t(9uED$|$l$$69ut$T$l$$?t& D$$t0E t9D$$T$E $t=t[^_]&    $ $ z[^_]$@d$@VfVS$t$0D$\$4D$D$    t$\$$   T$1t$$D$$[^v VS$t$0D$\$4D$D$    t$\$$   oL$1t${$oD$$[^v UWVS9t!)9u39u?&    tL$$u+[^_]v uB;Au=@t= uv $?$5t0u$@$@[^_]&    $ $ [^_]        |$|$ \$\$$t$t4t.pv;19tFvE$$\$t$|$&    &    eWVS :9  	99  9t   t
+ [^_v    $8$   D$X$D$$D$D$D$D$$
+D$t	8   D$$D$$4$w [^_   "$$   D$$D$$D$D$D$D$$D$t8px@cf$$ =t& x ,$$@]&    L>Wt& &Iv UWVS<9t91u-9u?9tPvt%   <[^_]    u+7l$4$2  PY  U J    NL$(\  M9L$(uL$(IL$,v|$,u	  |$,[%  N9    $@)  &    +7l$4$pE  P|  U J    NL$(   M9L$(L$(IL$            t&   ~  D$@D$($   D$   fM9.It& M9I<v 4$@$$$ v3<[^_]4$$$$@13<[^_]{nt& i&    LfO&    ,f8m&    fVNL$	L$(w5L$IL$(NL$	L$(wL$IL$(|$(t|$(t    .N@       tytb }D$@D$($   D$-$U:v } }@uL$(D$$   L$a}@FD$ j}t} 3~@%|$yX  gf  SF=@s  =    =   = $}D$@L$($   L$9D}@fXxf@~ v PL$($N} t}&f}@   } ^B}@D$0VEB8/@8%9t<D$v UFB8@89t	D$$ w} y}D$ T'    VSD$ t%t& 0    Vv[^L$ D$ L$  5D$ t$D$ &    '    UWVS<D$Pxh<  t
+E8  T$PB  @l$D$&    G$mT$$\$$$GG  X<tt& s9u  u?uD$Pl$X      $8uT$PZ  t$P&       E8   C   @8    SH8 @  x<uCv ?t:H  G9tu@9ht<$D$s[?ut& }  D$    l$$   >}<ut& ?tuG  x@uD$    $   SPfKtSf  z[  o  C$,$D$,D$5T$T$$D$,$9WD$,tzt$ D$,{C*St
+i  D$    $FT$$T$T$$T$D$B@$FT$B@]ua@ tRPtRt$T$Pzu1,$D$D$PxtRl$E$?tG=@tHufpuC       E8f   M-  tD$PPn  ]<u+zt& t& R  &       tQCuCt   E1   zvB$D$`tD$uE8E8u?T$Pzt4$nT$PD$B@$D$E@$E@<[^_]    D$ls<$(v _PEPED$ t$D$ Ettt& C8ED$s$D$EvD$t$SJAp      D$L$`qCxD$@l$$   &D$CD$D$$CCx<ut& ?9_uWD$T$$T$T$$fGRT$A,$D$>SRBH!B,$D$RfmD$PP1tBD$ 1D$   $$0$T$PD$  C  v @D$,l$$   t$,l$4$   D$ D$   4$-D$,$$iD$,D$$9T$(T$D$(D$,$D$,$D$(t68t($   T$P    ZUx@u$&    $^T$PStCCT$PD$s$E8D$Ls$C,D$Pl$@D$<D$PXD$L$}Zt& '    \$Bt$$jt$\$$XuX0 \$t$        t$\|$\$|2;=`CXt$\$$X5\5\0 \$t$|$    X|$$e\=`X&    '    UVUUUW1VSt$0    tCt& Ct0S8   u%tw   w5ft~    u  utw[^_]t& t;u    g)RS8)Ktt   S8C        C       C   f1v u      {tC8   ut${us<ut&     6t~uF   H   1	fPt
+@u~Ft<Ht51A    @t"Ht9uA   K@uv C8   $C8+  1f|t& '    S(  $0  D$R$uEtA;/tE$.L-t5\$\$D$D$6L$]D$R$](  [1(  [    UWVSl$0  D$GL$IL     t$D$   D$   $VLnu%F    CD$hL4$D$Ut#;uCD$oL4$D$2uD$tL4$D$tAt& Ct5@<uf     txu@t
+vK[ut$D$   D$   $L4$l$$IL1[^_]fxtG$tYD$GD$L4$D$SD$L4$D$:t$D$   D$   $P
+F2F<LCS\$ $@      C@   [ &    ,\$t$ |$$l$(($$13C(   t(9tC    C$    C    /\$t$ |$$l$(,        ,\$\$4|$$|$0t$ l$(tYw4$$l;/w$\$4|$$t$0\$t$ l$(,ht& 4$l$/Gv \$t$ |$$l$(,t& UWVS  $0  $4   t	; z  e$4  T$$D$(D$(T$$D$LD$D$4T$$$Ljt	8   T$$$   D$L$T$D$D$GL$D$ D$   D$    $  $LU${4$$Lt8 2Fu4$M~C   sD$   D$t$    ^T$ l$|$t$$D$b-|  =  wtv F8   GtGwu<$tG  @D$D$ D$M$Gut& uf  tv CKFHFNF4$(F8fLF8F   1$LVf*  ^FD$QMD$D$ $0l$ |$,t&   "t2\t-1&    "t\t4un  _L$D$]M,$  V:0uJX  x  T$FD$aMD$D$ ${D $F    FT$ D$MD$$<v D$ $X$    tyT$(D$$T$$zL$$!%t  u .oldD$4A T$$$T$ T$4$   T$$uID$   D$<u$    iT$4T$$)$      1[^_]t&      [^_]D$4$    D$GL$D$ v $  D$\$$   u$  %   = @    D$/   $N\$($4  D$$;)x$4  |$\$$F<4   D$(~ UD$("fl$D$   D$$LqT$ |$,D$   D$   T$$LFKFHFNFNKF/HF$NFwVKFtHFrNFtFD$T$ FD$aM$D$~GFD$7MD$D$ $^'FT$ D$DMD$$5$4  \$D$$$T$$D$L$uD$(mW1B&    '    JL\$<t$@|$Dl$Hv1\$<t$@|$Dl$HL&    j   vHe8e0wxL$8uL$l$$T$,L$T$,f TMfUWVS  |$  D$$   $   )\$^D$$ 
+f0nu_t D$    <$$FwVKFtHFrNFtFD$$ G\$$    [^_]SXx$.Lt<\$D$D$6L$ (D$D$D$ $   ltx[t&  x[        UWVS<  $P    $  $T  1l   l$,p    $T  \$(yt    x    v 4t\l$$l$(t& ~t?F8!F8t	F8FwDt$D    D    6ul$$  u\$(D$0$T  D$D$2l$,D$T$$L$,T$0l$D$   $|S  D$0p<t<
+t$M><#   <Cfut$oM   uL$7D$=   $tx  D$
+   <$D$ T$ tx  y  $T    D$7T$ $T$   ^8#  ~   Ff$dVt$oM   T$9D$    $3  pwM
+   $T     L$9$&  ^8I  FwT$$	^8D    pF8 fF<ut&  txu@tc  1T$$D     T9sD$$TR"y  t/T$ ^T$ &    t
+DQ tF   |$4$	  F|$$uD$,$ 1t
+$q1<  [^_]L$7T$ D$    $T$ x @   D$$| b  T$$tDL$$TF$uD$lT$$D$,!G8DTxD$9D$    $x @   <$L$$	^8Dz"GD$(<"   <\   D$(u$M6B<m  <y   <ntKF|$$uD$BFT$ $uD$eT$ @ ~L$$	^8D    GF$uD$,T<"t& t=$L$ NT$($T$D$*L$ T$$	^8D    F$uD$\$2#$   tp<t
+~t6   yF$=tF8u@@&$tD$   D$`u$    \$$D$$	^8D   $   Ydt& UWVS  $M@D$   $$MHF  D$$    |$4D$     D$   t& {  $C8  s  #     1  Cr>      T$FT$t"_u/   uf.hA D$  D$A  <${  8N      /4$D$/   F"   $   D$|$$   tD$  <$tD$$   $M  |$$   D$GL$MKD$   D$GL$M+D$$  D$    $  $L $&4$4$JSwKKFtHFrNFtSD$D$ T$D$v$24$SwKKFtHFrNFtSD$D$$T$D$pv$D$(        D$(  t& zn  $T$BT$B9T  BI  J=  $VCS$T$Hct& D$ |$   ,     [^_]D$  D$A  <$  $   t8C{ qC;C [v wJKFtHFrNFtZD$D$ T$\$D$aM$kT$\$BD$NND$D$$$HT$~D$(|$(  SD$ $KD$$$?$dN  D$$M+z$MD$t& J:  cD$D$ T$D$DM$T$BD$ND$D$$$lT$t& rD$D$ T$D$QM$5T$BD$"ND$D$$$T$T$,f   "t.\t)1    <"t<\ft<uuBD$ T$uD$]M$E D$]MD$D$$$t& D$ D$   \$4$D$`D$$D$   \$4$D$DuT$,D$ D$   D$   T$D$$LD$$D$   D$   $LD$~T$3Z;0uKXJxAD$D$ T$\$D$aM$~T$\$BD$6ND$D$$$~T$<D$D$ T$D$7M$Z~T$BD$MD$D$$$;~T$qD$$   D$ $?}   wN &    WV1S$    ,D$ D$    $H   f  u3      u    fJ     t
+xv tr{t${8   tC<u txu@!  P  	fPtz4 t#J8@u!K8u  Af1    tkt& CtXS8   tM uHK4u=xu	S8w&C$D$uc8xt& u  {=t    tn$1[^_t&    Cw#C;C!K8 CS$T$|te1=x S('  $8'  D$$4'  \$$D$'  D$y$0'  \$$L('  [t& UWVS\D$tt$pD$,t9@t0R  L$,QT$D$D$N4$`D$,@<D$(  t& T$(B9  D$   D$$    yD$   D$N$    y\$4$D$L$(Ax$@ XD$   D$N$    y|$\$4$D$T$(BtT8  D$   D$ O$    Gy4$D$T$(t$B$D$1F4$L$(AX>  1ftG\0S~D$      D$N$    x4$D$D0D$$   @D$   D$$    xD$    l$D$N4$D$CtOPwPKFtHFrNFtX@G  \$D$D$N4$OD$1F4$t:T$$T$$C<S12B*&    L$(	L$(D$,X<tQ1&    t8{u   D$N4$Dt$C$U   u   T$,B@tKD$   D$N$    /w4$D$L$,t$A@$D$1F4$t$pD$t0F\[^_]t& D$   D$J$    v&    x@L    D$K4$IKFBHF7NF"$D$1F4$&    |$|$ \$\$$t$Ww   FtOD$D$O$@GtiD$   D$$    u$D$D$1F$t!t$$|$\$ t$\$5t& \$t$|$2FD$ Y$H    \$D$(t$\$$t$ D$4$tQCv&Ct$ \$D$(t$D$$O[v SKFtHFrNFu\$t$        S\$ $ t>$   v     @    $@   @   [\$$#OMu$   v    '    D$D$pL$hu$   \v&    $\$t$   0S;(v\$t$v     T$$r$   0    uz   1    9rtf  t 0{f$   t$tW     0   (    Et&  yv f  ov$?v$v \$\$ t$|$l$   $   -(t/5D=40~=H~tM(CHC 4 L   D\$t$|$l$v (&    '    S\$$1t	(9tatg(tD4JHJCHC 4 L   D[t& (    ,\$\$4|$$|$0t$ l$(w1\$t$ |$$l$(,| u| u$0   rtC]}}E    E     ]E    E   E(    E,    ,$w&    UWVSt$4|$0n,$rtN~1f9uD3 3 $l$tC   [^_]twHw    S\$ $p$D$d[VSt$$$0   oqtEs4$[qCt T$ C   >[^    wvt& wft& S$tK(t<T$ BHB4  D[&    3( D$ @  $$$t(&    (nfWVS |$0<$$   Dp     @    $1t(A<$ tVD$ @  $s$k5C   u^CC   C [^_PJTtB|$L$D$$7Oo$   EpPCTXJtB\$|$L$D$$wn$   oPJTtB|$L$D$$wn$   oUWVS<-8   54D1,@Y@]~t& `e)=D 54'v'yt& 54Dz    $V=,8   u
+,   5 t`tF$tm(t`Ip H545 D t&  ,   =t& ( D$ @  $$($b=54D$$D(-$L Q9T$   ATD$ HT$(T$D9s6T$(&    
+-$(L ;AwT$(QT$ T$()D$ HA(D @9s
+ xT$$FV=V4D,   ,   @  v <[^_]X,     	  H`@t9 $j$1t($<C$1$Hj  d5t
+@!  X  $    0,	   PRTt
+@  sX    $   j`   \    X  ,   N@@9     >!PJTtBL$D$$@xi@  ,   DF)4=VDF 4@X,        @1F}`|  =L p  t& A<	?  u%hdh]O~,   @  DF)4=VDF 4X  tWDF)4=VDF 4%X      &    !     +D$(D-$(D P,D$J  HT$J4T$ 9T$   D9D$ T$$  D$@(1  D$ +D$$x  L$A5H|$$,954   t
+@Y9
+	@]w{1~%119t<	uh=du9)~)t&    TOfG|TOI,T$L$B HA,   @D$ D$ D$$)D$ D$ ~5l$ 1|$t& 9u-$(|$D D$T$z,  T$ L$Q   4|$\$,\$ t$$Q    V~pFD$F$EcFtE)-$<8(=4D PM1t	(t VnuF    xFF< v |$t$$\$,T$'bT$         ~    |$\$,\$ t$$"?	       $d$(p $al$t$$bHx|$t$$\$,(-$D$    T BHD$,!  (D$,D$ L ;AL$$  T HR ($PHD $(|$@   |$|  T$(4,954v8f   t
+<@Y9<:?@]wtxT$L$-$(L$T$D D$4D$ D$$H    B    D$    (HD$   D L$,@,   D$$D$$L    4,#bqO|$t$$\$,H/L$,T$$D$B$6`L$$(-$AD H  D$ H-D$$ $+HD$   -$T$,	 $`1t$(=5,954v6   t
+@Y9
+	@]wk B]54X,	     +xD$ H-$(    UWV1S  $p  l$P    D$8    D$(   l$<D$D$@    D$4   T$4f3|$0W9   |$('    d$(|$('  vD$('  L$(D$(D L$,$`  )D$0$T$ D$|${_L$,    T$ D$D$<
+$L$$D$K_T$ ;|$L$$t<$^L$$T$ |$(CB,z9|$4  L$<  6ftK  R  =!     w`h:=  w i9L$8   T$8mD$,   T$,   n)D D$De  T$D    L$,))mP o# o  ~    p|$0f k  L  &    D$@   t$0-t& 9tl`pMQ#|ft  wf?iu?k~D$@   U H       =tT$8\Q{9\$0t+t$0v `pzQ{9u|$9|$0tD$0$|\  [^_]v |$@up= ~aT$8;Q5{t$0$8Wf;	it	kot&     1m
+  t$0|$@T$@U !D$D     t+PJTtPL$T$$Pb\$    E$@P<D$Dav |$0   PD$,}|$D"ED$E$   D$ PJTtPL$T$$QP[M L$D@@^	  @    PJTtPL$T$$P>[kD$   E$H8   $D$    D$    $     PJTtPL$T$$PZE D$E$   D$@D$DE     y< @<PJTtPL$T$$P7ZdE $   D$kD$DHE}D$E$   D$e|$$   D$ 
+PJTtPL$T$$PYM1L$L}|$HD$HQt
+@(  D$H$lyD$?{T$L$uXD$   E $D$DE $NX[E}@P      ))36ft$0@@H8    PJTtPL$T$$PXD$    PE     w< @<PJTtPL$T$$P4Xa$    |D$    E$   D$4 -PJTtPL$T$$PWE     %w< @<PJTtPL$T$$PgW t+PJTtPL$T$$Q.Wu{VE D$E$   D$v|D$D3$Ou"E$OD$u
+E $I}D$DE D$E$   D$|D$DE $OD$su$ObufE$OD$Hu$O7uxD$    E$H8   $z IPJM=TtPL$|$T$$,PUD$    E$H8   $jz PJM=TtPL$|$T$$
+PU }t<T}JMD$HPtPL$L$HT$$PL$2U$DU$    yD$    E$   D$(} !PJTtPL$T$$QTE}D$E$   D$|E@t$lu J=THPtPL$|$T$$_POT|}D$    E$|$$   D$| EPJTtPL$T$$rPSEx }D$    E$||$$   D$8| PJTtPL$T$$PtSE D$E$   D${E D$E$   D$xD$D_ED$DSUT$DGU @P7E$V{ PJTtPL$T$$)QRE@$s EHJP=TtPL$|$T$$APmR   f1    U T$@$i$s U$<ysv '    VSD$ $?j<@D$    $    xH8   @    D$    D$Q$   y=     x< td$1t$t& {t$
+{tu  u= uHD$    [^hD$$   vD$    $Q$UwCf$   RWVSD$$"   Q't& \$~D$   D$   $QPD$"   <$Nt')t|$D$D$Q$P&    \$<$M\$$"   HQ[^_    '    WVS5|$   ^"  t& C8  |$D$   D$   $PP{  |$D$   D$   $QOt& [<uO&    tB;suC    '  D$D$R<$Out& ^t>$N:
+u     ^:
+t\$D$*R<$GO|$$
+   wOF   ^^tC    Ct8  |$D$
+   D$   $URN|$C$|$$
+   Nhv v    vv 
+  Ft
+xp  tEv C$X|$D$	   D$   $Q2NY|$D$   D$   $QN4|$D$
+   D$   $QM|$D$   D$   $QM|$D$
+   D$   $QMt& CD$P<$D$Mvt& |$D$	   D$   $QTMSFCt88   |$D$   D$   $PRM|$C$|$$
+   KM2f|$D$   D$   $RLv |$D$
+   D$   $QL|$C$Ct8Sx@Fp&    [^_|$D$   D$   $?RMLS?|$$
+   L;f|$D$	   D$   $5Rx@|$D$	   D$   $FRKkU]t& '    UWVSO   ;  H)t$1ED$ED$E$9r[^_]$US t fu[]US    [:  |LY[                             aborted!
+
+ (NEW)  %*s%s  (%s)  /n /m /y /? o es %*c
+%*c %s
+%*c
+ %*s%s
+ %*c %s
+ %*c  %d. %s  (%s)  (NEW) %*schoice [1]: 1 [1-%d ]:  [%s]  *
+* Restart config...
+*
+ /usr/share/locale linux See README for usage info
+ osdD:nmyrh %s: Kconfig file missing
+ KCONFIG_ALLCONFIG allno.config allmod.config allyes.config allrandom.config all.config KCONFIG_NOSILENTUPDATE Console input/output is redirected.     Run 'make oldconfig' to update configuration.
+
+ ***
+*** You have not yet configured your kernel!
+*** (missing kernel config file "%s")
+***
+*** Please run some configurator (e.g. "make oldconfig" or
+*** "make menuconfig" or "make xconfig").
+***
+    ***
+*** Can't find default configuration "%s"!
+***
+ 
+*** Kernel configuration requires explicit update.
+
+   
+*** Error during writing of the kernel configuration.
+
+    
+*** Error during update of the kernel configuration.
+
+ `@0888ffff++P<none> ??? unknown %s:%d:warning:  %s:%d:  <token> %s:%d: location of the '%s'
+ <choice> KCONFIG_AUTOCONFIG include/config/auto.conf KCONFIG_CONFIG leading whitespace ignored prompt redefined Oops! How to check %d?
+  -> %s how to free type %d?
+ 0x%x expr_calc_value: %d?
+ ( ! !=  ||   &&   ^  [ <unknown type %d> UNAME_RELEASE can't copy type %d
+ choice must have a prompt range is invalid srctree %s/%s .kconfig.d w ..config.tmp deps_config := \
+ 	%s \
+ 	%s
+ 
+%s: \
+	$(deps_config)
+
+ ifneq "$(%s)" "%s"
+ %s: FORCE
+ 
+$(deps_config): ;
+ / %s%s KCONFIG_OVERWRITECONFIG %s.tmpconfig.%d KERNELVERSION KCONFIG_NOTIMESTAMP #  
+#
+# %s
+#
+ # CONFIG_%s is not set
+ CONFIG_%s=m
+ CONFIG_%s=y
+ CONFIG_%s=" \%c CONFIG_%s=%s
+ CONFIG_ is not set unexpected data invalid string found include/config/auto.conf.cmd include/config ../.. .tmpconfig .tmpconfig.h #define CONFIG_%s_MODULE 1
+ #define CONFIG_%s 1
+ #define CONFIG_%s " #define CONFIG_%s 0x%s
+ #define CONFIG_%s %s
+ KCONFIG_AUTOHEADER include/linux/autoconf.h Symbol: %s [=%s]
+ Prompt: %s
+   Defined at %s:%d
+   Location:
+ %*c-> %s  (%s [=%s])   Selects:    Selected by:    Depends on:  CONFIG_%s:
+
+  [=%s] can't find file %s
+ %s:%d: can't open file "%s"
+          flex scanner jammed input in flex scanner failed unexpected end statement unknown statement "%s" unexpected option "%s" invalid statement unknown option "%s" invalid option %s:%d:config %s
+ %s:%d:endconfig
+ %s:%d:menuconfig %s
+ %s:%d:type(%u)
+ %s:%d:prompt
+ %s:%d:default(%u)
+ %s:%d:select
+ %s:%d:range
+ %s:%d:choice
+ %s:%d:endchoice
+ %s:%d:optional
+ %s:%d:default
+ %s:%d:if
+ %s:%d:endif
+ %s:%d:menu
+ %s:%d:endmenu
+ %s:%d:source %s
+ %s:%d:comment
+ %s:%d:help
+ %s:%d:depends on
+ Error: discarding Error: popping Cleanup: discarding lookahead Cleanup: popping Linux Kernel Configuration MODULES %.*s \"   boolean
+   tristate
+   string
+   integer
+   hex
+   ???
+   prompt    default    #choice value
+   unknown prop %d!
+   help
+%s
+ 
+comment  
+menu  
+endmenu
+  if    depends  endmenu endchoice endif depends boolean tristate integer hex string comment default select range env                            #GB=88L`PPh```````````````````````````````````````((`HhH 88@0@088P>P(XX(2x``2PnpX		H	xxJ	#%%#%$ &#%&&:)D)U)_)&&7(#%#&#T((()&&_*@'''((i)S%S%8%##99C:b:2222222222222u::;n5:W52222222'>4%<<622<7A4K554I62222222477=22N4L82222284922222j;;29=2222=2u=224==22A4K5: :946=&6?87A4,AfCACCBBarch/$ARCH/defconfig    There is no help available for this kernel option.
+                                                                                                                                      	   
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ! " # # $ % &            ! " # # $ % &   ' ( )   * * + * * * * * * * * * * * * *    ,  - - - - - - - - - - - - - - -  . /  0 0 0 0 0 0 0 0 0 0 0 0 0 0  1 1 2 1 1 1 1 1 1 1 1 1 1    3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3    5   6 6 6 6 6 6 6 6 6 6 6 6 6 6 6  7    8 9 9  9 9 9   :  ;  ' ( )   * * + * * * * * * * * * * * * *  * * + * * * * * * * * * * * * *   ,  - - - - - - - - - - - - - - -  . /  0 0 0 0 0 0 0 0 0 0 0 0 0 0   1 1 2 1 1 1 1 1 1 1 1 1 1   4    6 6 6 6 6 6 6 6 6 6 6 6 6 6 6   < 9 9  9 9 9    9 9 9                             "                                              	    
+        11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111  111 1  
+ 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111  	 !  ( & G M 9 = ? L W e     ' h A       D  H H   N  H           H              q                           	
+ !"                                   : ;  V W      	 
+   a         !  S T "  C   F  H    _       	 
+                         	 
+             ] C   F  H          l           	 
+              E  G            	 
+                  	 
+                 	 
+             D E  G E  G       	 
+           D E  G                           !         C m < (                         . /  1 Q R 5      	 
+    +    V 8 9 , - : W 0   ;  p 2  }  } Z  [ 6 \ ] ^ _ ` a b 4 c 7 Z  > d ? [ @ \ k l m n  I  s c K ~ L ~ o  8 9 S T    Z M [ N \ ] ^ _ ` a b x c  O  d     	 
+    S T             
+     P   X Z  Y  \ t w c  z Z  |   \     v {   c     | I S T S T   S T     T           B r  U             H                                m        4>CTKT[\  ] n ^   kl   d_          `GO0P h  @  	
+    Y   , %$ ! #"  Y 89576?32DFBEAVWULNJMIagijfeR b bbb   S<b b   &Z  b.+ ; Xc'()  -:=*/                                           #$%%%%%%%%%&&&&&&&''''''(()*+,-------...../001123456666667777889:;<<<<=>?@AAAABCDEFGGGGHIIJJKKKLLMMNNNNNNNOOPP                 z  ; }       E         e     A f g      u ! C q D " y # E $ %  & G ' ( ) h i F j   * J  < = 3      $% 	
+&')*+,2359;=>@BCDKJJJPJ"NO--68<GAGLNN L!(./EFH(7FH'4K'5:@K(H'5?@KNNOOJIJNO0JINMMMMOMMNM!1J            cR`RJkRhRJJJJJuRrRxRJRRRRR                    LRcRRkRRRR%s:%d: missing end statement for this entry
+    unexpected '%s' within %s block '%s' in different file than '%s'    type of '%s' redefined from '%s' to '%s'    %s:%d:error: found recursive dependency: %s boolean symbol %s tested for 'm'? test forced to 'n'
+   boolean symbol %s tested for 'm'? test forced to 'y'
+   trying to redefine defconfig symbol redefining environment symbol from %s   environment variable %s undefined   choice value must have a prompt defaults for choice values not supported    choice value used outside its choice group  config symbol defined without type  default for config symbol '%' must be a single symbol   config symbol '%s' uses select, but is not boolean or tristate  '%s' has wrong type. 'select' only accept arguments of boolean and tristate type    range is only allowed for int or hex symbols    #
+# Automatically generated make config: don't edit
+# Linux kernel version: %s
+%s%s#
+   #
+# configuration written to %s
+#
+  #
+# using defaults found in %s
+#
+   override: reassigning to symbol %s  symbol value '%s' invalid for %s    %s creates inconsistent choice state    override: %s changes choice state   #
+# Automatically generated make config: don't edit
+# Linux kernel version: %s
+# %s#
+   /*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: %s
+ * %s */
+#define AUTOCONF_INCLUDED
+  out of dynamic memory in zconfensure_buffer_stack() out of dynamic memory in zconf_scan_buffer()    out of dynamic memory in zconf_scan_bytes() bad buffer in zconf_scan_bytes()    out of dynamic memory in zconf_create_buffer()  %s:%d: do not source '%s' from itself
+  %s:%d: file '%s' is already sourced from '%s'
+  flex scanner push-back overflow %s:%d:warning: multi-line strings not supported
+    fatal flex scanner internal error--end of buffer missed fatal error - scanner input buffer overflow out of dynamic memory in yy_get_next_buffer()   fatal flex scanner internal error--no action found  warning: menuconfig statement without prompt    warning: ignoring unknown option %s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      @      $   E   lo      
+   o                                4      0         oo   o                                                            jz
+*:JZjz
+*:JZjz
+*:JZjz
+*:                                                                            NF    NF                                                                                  KF    KF                                                                                  HF    HF                                                                                   2F    2F                                                                               on env endif option endmenu optional endchoice range choice default def_bool help bool config def_tristate boolean defconfig_list string if int select modules tristate menu source comment hex menuconfig prompt depends mainmenu                                                                                                                                            %            /            5            <            D           M            R           W   	         ^           k           s                                                                                                                                                                                                 
+                                                                                                                                                                     GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll  @               D   o     P                N                         V           o                 ^   o                     k   o     P                z   	        0                   	      44                         $$  0                           TT                           PP                            E                              F   p3                           y                                                                                                                                                                                                                                       $                        0        8                                                                               	              $ 2                                               (          H          l                                                       	          
+     4          $          T          P          E           F          y                                                                                                                                     (         5         K   $     Z   (     h                     t            y                  E                                     z       `         T                9              Pi                    H     &  D     3           ?  $     O  (     c  4     n  H     y  D       P              |       Tq       q        <       @              d       `e       u       P     )   q4     4       N  Pi     [  p     g  l     u  t       n       `       \       X       h       d       ,                     @k       L       0     (  8     0  F     @      T   5     g  W     y         1                           p      `      D     
+  0       `t     *  `     :  e     K      Y  0     k        z         x        Y4       (       -      @Y       @]      `ez       fh      `h"      i      m       no     	   oo       o\        p\        k    (  `p     /   @     C       Y         j         }                                                          ,                            0'                                       .        5  0+     A  p3     Q             c             t  H                           0      PE       P                                           +            %       <             O  p]     c              r                `H       0z        F                    @              0t                               #             5  E      ;   !     O             b      p  0)     x  !                                   +                                     	   r     	  0M     +	             H	  6     V	       g	  |     q	  ]     	             	             	       	      	             	  >?    	  6      
+        
+       
+             /
+  X     <
+  $F     K
+             c
+  PT     w
+             
+       
+             
+       
+       
+       
+             
+         
+  `'       p          (             :  T     I  0
+     X             k       |               `                          6                    `P      0n       0k    "             4   s     D       N       `             r  `2                    P'                                 z       @W               5            "             7             K             ]       j  `EZ     z                                          
+       @        !q      P                                 +  `    C  00    N       c       p  }                                )                                              p                           !     1       =      L  P     Y             k  5    y  ]              0       @               `W                                             "       -       >  Pe     H  H     Z  
+     j  )                           PL       "                   
+                    0s       ,       '       @     *  P      7       N  $     Z       _        q  r    |                      p                          P       )                              H       
+     ,       8  +     F             Y             m                              K      _       o       @|             ,                                $             8             H       T  @*     a       o  E       `      @      `6                     0              +       $        E               l     '  @H      crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux conf.c check_stdin valid_stdin conf_askvalue line print_help T.67 conf_sym indent conf rootEntry check_conf conf_cnt sync_kconfig zconf.tab.c yy_buffer_stack yy_buffer_stack_top yy_c_buf_p yy_n_chars yy_hold_char current_pos conf_changed_callback sym_change_count CSWTCH.541 CSWTCH.543 current_menu current_entry last_entry_ptr yydestruct prop_warn zconf_error zconf_endtoken CSWTCH.539 kconf_id_strings_contents conf_warning conf_lineno conf_filename conf_warnings zconfprint text_asize text_size text first_ts last_ts yy_start menu_check_dep sym_check_expr_deps sym_check_sym_deps yy_did_buffer_switch_on_eof yy_buffer_stack_max yy_init sym_add_default sym_calc_visibility sym_get_range_prop sym_get_range_val expr_print_gstr_helper expr_print_file_helper inited.8594 trans_count __expr_eliminate_eq expr_eliminate_dups2 expr_eliminate_dups1 alloc_string append_string zconf_init_buffer kconf_id_lookup asso_values.3554 wordlist.3615 conf_expand_value res_value.6403 fullname.6433 conf_unsaved nohelp_text yy_fatal_error zconfensure_buffer_stack yy_ec yy_nxt yy_accept yypact yytranslate yycheck yydefact yyr2 yyr1 yypgoto yydefgoto yytable yystos print_quoted_string _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC fileno@@GLIBC_2.0 data_start fputs@@GLIBC_2.0 __errno_location@@GLIBC_2.0 rootmenu sprintf@@GLIBC_2.0 zconfin expr_alloc_one srand@@GLIBC_2.0 expr_copy open@@GLIBC_2.0 cdebug expr_fprint menu_add_symbol getpid@@GLIBC_2.0 mkdir@@GLIBC_2.0 symbol_mod regfree@@GLIBC_2.0 defconfig_file expr_calc_value __libc_csu_fini _start zconfchar file_list menu_is_visible menu_end_entry zconfget_in menu_add_prompt sym_type_name zconf_switch_to_buffer __xstat@@GLIBC_2.0 expr_extract_eq_and __gmon_start__ _Jv_RegisterClasses symbol_empty zconf_scan_bytes _fp_hw realloc@@GLIBC_2.0 zconfpop_buffer_state menu_has_help conf_get_default_confname strchr@@GLIBC_2.0 vsnprintf@@GLIBC_2.0 getenv@@GLIBC_2.0 _fini conf_get_configname putchar@@GLIBC_2.0 sym_re_search str_new conf_get_autoconfig_name zconfleng expr_contains_symbol fgets@@GLIBC_2.0 sym_set_changed rename@@GLIBC_2.0 regexec@@GLIBC_2.3.4 sym_check_deps expr_eliminate_dups zconf_starthelp __libc_start_main@@GLIBC_2.0 expr_alloc_or zconf_flex_debug expr_free expr_extract_eq_or strrchr@@GLIBC_2.0 uname@@GLIBC_2.0 zconfalloc conf_set_all_new_symbols bindtextdomain@@GLIBC_2.0 conf_parse expr_alloc_and zconfget_debug prop_get_symbol read@@GLIBC_2.0 conf_defname _IO_stdin_used gettimeofday@@GLIBC_2.0 sym_set_all_changed strtol@@GLIBC_2.0 zconflval free@@GLIBC_2.0 optind@@GLIBC_2.0 menu_get_help sym_tristate_within_range dcgettext@@GLIBC_2.0 __data_start expr_alloc_symbol conf_write symbol_hash fflush@@GLIBC_2.0 menu_add_entry zconfset_debug regcomp@@GLIBC_2.0 conf_get_changed __ctype_b_loc@@GLIBC_2.3 menu_get_prompt menu_add_option isatty@@GLIBC_2.0 sym_set_change_count fclose@@GLIBC_2.1 expr_transform zconf_flush_buffer expr_eliminate_yn getopt@@GLIBC_2.0 expr_trans_bool zconffree stderr@@GLIBC_2.0 memcpy@@GLIBC_2.0 sym_get_type strlen@@GLIBC_2.0 expr_alloc_comp fopen@@GLIBC_2.1 conf_read_simple expr_eliminate_eq zconf_fopen sym_clear_all_valid str_append sym_get_default_prop __dso_handle setlocale@@GLIBC_2.0 clearerr@@GLIBC_2.0 strcpy@@GLIBC_2.0 __DTOR_END__ __libc_csu_init printf@@GLIBC_2.0 chdir@@GLIBC_2.0 ctime@@GLIBC_2.0 zconfset_in input_mode zconf_nextfile expr_depends_symbol menu_get_root_menu zconfget_lineno menu_set_type zconf_scan_buffer sym_string_within_range zconfparse sym_add_change_count zconfget_out sym_set_string_value close@@GLIBC_2.0 fwrite@@GLIBC_2.0 get_symbol_str fprintf@@GLIBC_2.0 time@@GLIBC_2.0 menu_add_menu sym_lookup str_get strncat@@GLIBC_2.0 sym_is_changable zconf_scan_string __bss_start sym_calc_value zconfrealloc malloc@@GLIBC_2.0 menu_finalize zconf_delete_buffer menu_init sym_string_valid menu_end_menu menu_add_prop sym_init sym_set_tristate_value menu_get_ext_help fputc@@GLIBC_2.0 current_file zconfget_text zconfnerrs stdin@@GLIBC_2.0 menu_warn expr_compare_type zconfset_lineno menu_get_parent_menu memmove@@GLIBC_2.0 zconftext str_printf zconflex __ctype_tolower_loc@@GLIBC_2.3 zconfset_out strcat@@GLIBC_2.0 zconf_initscan sym_get_env_prop expr_alloc_two zconf_lineno zconfrestart zconfpush_buffer_state zconflineno _end stdout@@GLIBC_2.0 expr_print puts@@GLIBC_2.0 sym_defconfig_list conf_write_autoconf textdomain@@GLIBC_2.0 expr_extract_eq zconf_curname str_free rand@@GLIBC_2.0 expr_eq symbol_no conf_set_changed_callback file_lookup menu_add_expr strncmp@@GLIBC_2.0 vfprintf@@GLIBC_2.0 _IO_putc@@GLIBC_2.0 optarg@@GLIBC_2.0 modules_val expr_trans_compare prop_alloc sym_toggle_tristate_value zconfdump _edata sym_get_choice_prop strcmp@@GLIBC_2.0 zconfout sym_env_list __strdup@@GLIBC_2.0 exit@@GLIBC_2.0 current_buf menu_add_dep zconfget_leng __i686.get_pc_thunk.bx file_write_dep conf_read sym_get_string_value zconflex_destroy prop_get_type_name sym_find main expr_gstr_print _init str_assign modules_sym zconf_create_buffer symbol_yes 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/scripts/kconfig/lex.zconf.c /usr/src/linux/scripts/kconfig/lex.zconf.c
--- /home/jara/linux-2.6.32/scripts/kconfig/lex.zconf.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/kconfig/lex.zconf.c	2012-08-04 07:02:11.000000000 -0300
@@ -0,0 +1,2429 @@
+
+#line 3 "scripts/kconfig/lex.zconf.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yylineno zconflineno
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+#define yywrap zconfwrap
+#define yyalloc zconfalloc
+#define yyrealloc zconfrealloc
+#define yyfree zconffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+#define YY_NO_INPUT 1
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int zconflex_destroy (void );
+
+int zconfget_debug (void );
+
+void zconfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE zconfget_extra (void );
+
+void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *zconfget_in (void );
+
+void zconfset_in  (FILE * in_str  );
+
+FILE *zconfget_out (void );
+
+void zconfset_out  (FILE * out_str  );
+
+int zconfget_leng (void );
+
+char *zconfget_text (void );
+
+int zconfget_lineno (void );
+
+void zconfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( zconftext, zconfleng, 1, zconfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		while (zconfleng) {
+			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+				break;
+			zconfleng--;
+		}
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+	current_file->flags = FILE_BUSY;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	if (file->flags & FILE_BUSY) {
+		printf("%s:%d: do not source '%s' from itself\n",
+		       zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	if (file->flags & FILE_SCANNED) {
+		printf("%s:%d: file '%s' is already sourced from '%s'\n",
+		       zconf_curname(), zconf_lineno(), name,
+		       file->parent->name);
+		exit(1);
+	}
+	file->flags |= FILE_BUSY;
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file->flags |= FILE_SCANNED;
+	current_file->flags &= ~FILE_BUSY;
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
diff -Naur /home/jara/linux-2.6.32/scripts/kconfig/mconf /usr/src/linux/scripts/kconfig/mconf
--- /home/jara/linux-2.6.32/scripts/kconfig/mconf	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/kconfig/mconf	2014-03-01 13:44:52.000000000 -0300
@@ -0,0 +1,468 @@
+ELF              4        4    (      4   44                                      \ \          \ \\4  T           p pp               (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU t<rGIa   g   d   F   -   O                   X   U       S   Y                     [   B   ]   f              8   6   Z   Q               V   3      I   *   e   L       D       R   C      K       G                               /   =   E                            M   ;   9   >   !   ,   1   ^      P       W   :       
+   J       .   	                  H   7               $   0                                                                                                                                                                                                       '   _                       2                         +      A   a   4       &   %   b   )             @       N       ?   "   (          <   \   c       `                          #   5           T          Z          @@ !C  Z   ^   f   |(XOCE+K8 qX'|fUa                             K              1                          d                                                                              p                                                                                                                                          q                                        ;                                                                                            D                                                                                                                                                   x             c                           >                                        7                                       u                          X             4                                                                    -             X                           ?                          w                                                                   J                           +                                                                  Q                          E                          T                           l                                        }                           $                          _             9  g     $       h         &       a        I              9       -                                  |       libncurses.so.5 __gmon_start__ _Jv_RegisterClasses cbreak doupdate delwin scrollok wnoutrefresh stdscr acs_map waddch flash noecho wgetch subwin wtouchln wscrl wprintw nodelay waddnstr _fini has_colors ungetch endwin _init wrefresh winch keypad COLS wclrtoeol newwin wmove init_pair initscr wbkgdset start_color LINES libc.so.6 _IO_stdin_used strcpy exit sprintf _IO_putc setlocale fopen strncmp strrchr regexec __strdup dcgettext strncpy regfree mkdir realloc stdin getpid strtol fgets strlen __errno_location chdir read clearerr vsnprintf ctime stdout fputc fputs memcpy fclose rand malloc strcat strcasecmp __ctype_b_loc getenv regcomp stderr strncasecmp strncat fileno fwrite rename strchr __ctype_toupper_loc __ctype_tolower_loc __xstat memmove uname bindtextdomain strcmp __libc_start_main vfprintf _edata __bss_start _end GLIBC_2.1 GLIBC_2.3 GLIBC_2.3.4 GLIBC_2.0                                                                                                                                               ?         ii   >     ii   H     ti	   R     ii   ^      H  ^  `  a  c  d  [   \  X  \  `  d  h  l  p  t  x	  |
+                                             !  "  #  $  %  &  '  (  )  *  +   ,  -  .  /  0  1  2  3   4  $5  (6  ,7  08  49  8:  <;  @<  D=  H>  L?  P@  TA  XB  \C  `D  dE  hF  lG  pH  tI  xJ  |K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  US    [T t   -  8 X[5P%T    %Xh    %\h   %`h   %dh   %hh    %lh(   %ph0   %th8   p%xh@   `%|hH   P%hP   @%hX   0%h`    %hh   %hp    %hx   %h   %h   %h   %h   %h   %h   %h   %h   p%h   `%h   P%h   @%h   0%h    %h   %h    %h   %h   %h  %h  %h  %h   %h(  %h0  %h8  p%h@  `%hH  P% hP  @%hX  0%h`   %hh  %hp   %hx  %h  %h  % h  %$h  %(h  %,h  %0h  %4h  p%8h  `%<h  P%@h  @%Dh  0%Hh   %Lh  %Ph   %Th  %Xh   %\h  %`h  %dh  %hh   %lh(  %ph0  %th8  p%xh@  `%|hH  P%hP  @%hX  0%h`   %hh  %hp   %hx  %h  %h  %h  %h  %h  %h  %h  %h  p    1^PTRhhQVh US=  u?hd9s    d9r []t& '    Ult    t	$lVS$D$    $u4  $8  4$#  D$   D$$    t$\$D$  $ D$q=  v- $   \$D$D$  $-7=   v= $[^&    UWVS<$F    ~^	  <$a  D$(G8  ^-oD$,    t$E  t	9k  u_<$R  J  |$(  |$(	  $t     4$  4$  D$   $    D$D$    $D$-D$       -^-tv u-)-<[^_]&    ;5-  - _t	`  |$(r  |$(  <$  $c<$  $D$  -G:D$(J  4$     D$   $    D$|T$(\$D$    $)RD$!D$  $s     4$  t&    ;5-f   4$B  S  x  -   D$   D$$    D$    $D$-D$  $:     4$  6t& $t  |$,t$  4$  f\$,d&    1C      <$    D  l$$  $t   R  4$Z  G:8  4$  D$   $    D$\$D$    $D$-D$  Fx3$  Vt& <$     *D$$E  BT$,D$,$h  D$   $    D$$D$`  $T  T$,B---*D$$  S       D$$  *D$$j  gl$$U  R<$  D$   D$$    04$I  D$   $    D$D$    $D$-D$  $:   !  4$)  a<$   D$   D$$    -D$   D$$    b--   ~(-  D$AD$    D$T$$  $m   c  4$k  -N(t& }-D$   D$$    D$    $D$-D$$  $:     4$  ~l$$ X  UD$-D$    $D$/  \$t$|$f  D$ |$t$$D$  \$t$|$&    '    ,\$ \$t$$|$($a  \$<$T  $  <$  D$   $    D$1$    J$(  \$ t$$|$(,fUW1VSl$l$\y  D$\    &      --   W   W  D$   D$$       D$   t$$    D$(T$(l$|$T$$  tbt]= tVD$(  U  H  D$,  1T$(D$,tD$,H$ v l[^_]D$   D$$    D$(T$(T&    $  $:   H  D$   D$($    $  $L     D$   D$T$    $  $S     RD$   D$$    j1@$    +  D$   D$$    6D$   D$$    D$(T$(D$D$K   D$
+   T$$"  WD$   D$$ _ _  $	(  D$,D$L$^  D$,  T$,  D$D$L$y     t$0t$,\$4&    T$T$L$y  ut$0\$4D$PD$XD$LD$TD$,$T$T$V  D$   D$$    D$(T$(1$    D$T$H%  L$($t     L$(\  $?3  rL$($t     L$(VD$   $1  AL$($t     L$(%D$    $1  L$($t   h  L$($D$   1  L$(D$   $p1      1$J   v E  D$,L$(  L$(L<(r$ uR= _ W$ _]    D$   D$$    [   $<   1  D$-D$7   D$   D$@$    I  n  g&    uR= _ $ _t  :  D$   D$9$       $&   1t  D$-D$7   D$   D$$        f#$m   t& {  D$,_jA8ty  T$,BxD$,$!  D$0T$,B$        D$   D$#$    D$4  T$,B$  L$0I  D$0T$(D$   $    D$]T$(T$T$4D$K   D$
+   $T$i     t& -T$,D$ _B$3  D$   D$$       $+   1-tT$,1z( B(jD$   D$k$    1$    C$D$   D$N$    N1$    D$,Q>D$   D$@$    D$4cD$   D$`$    D$4>D$   D$$    D$4D$   D$$    T$L$D$@Y  MD$   D$ $    kD$   D$$    D$(KT$(1$     D$   D$$    D$(T$(D$,$3  D$   $    D$T$,\$0D$8B@D$40  D$,X-txt$<$r4  t\C  $  D$   $    D$$D$c  $  C;D$4g  V9BJ  ut$<  D$   D$$    #|$8 7  T$8D$   $    T$\$D$   D$F   D$   $:  S   ux         @\$0D$   $+  _$
+  D$   $    D$s$D$W  $:            &    tv ]\$0tct& +  4[\$43$X   L  $   [  CD$   D$$    D$, &    i _q$     H _V9UVS(D$$   D$$$}E@$  $    'n  $tD$$3O  vt0X$    $  ,    WH  N  uBt$$  D$   D$P$    n$V1([^]&    D$   D$$    8D$<   D$   $    D$  aD$t$$  D$h   $-"U  LD$   D$$    D$$9   ;v -   D$-   D$   $<D$D$,   D$   $lD$(   [^]D$   D$$    D$$(1[^]SD$t=P@     PB OH@   @,    HtO;t[P O\(O=[$Ofv '    =v '    =v '    Wv '    \v '    D$    D$=    D$=    =v '    D$=    4Ov '    0OtB        D$@&    S`OD$\O\Ot8u[[v '    D$\OD$&    \Ot& D$`O    S\$ trv8tv [Cxu{u   C    &    C$CC$C[    '    \$\$ t$t$$t;v1\$t$    $ &    19s\$t$t& 9st>19s\$t$&    [u&    t$C$it   \$t$t& t$C$ARt& \$\$ t$t$$ttbvt{t>1\$t$ut$C$   ut$C$9s\$t$    9suS    t`9su{x        L$1T$9t
+v    $@ttttfu   &    T$BtfB8 u\u   fz4uf&    '    T$w'    D$@<txut& xt& t ut& D$@<txut& xt& t ut& D$H8   @<t    PtJ ut& S1t&  Xt4t& yt#A<I8   tt& PtJ u	u  u[        D$t$t$$PtFH4tv1$t$tKPD9s@8 tNv uF    @8 uH4=\    u   H4uuv     19t& r9&    T$Bw#Jtsv tBv '    D$P4;PDfD$@u1fw@fT$w    OW OWhOW&    '     OPhOO        OhO@O    '    T$Bt@R1tBfWv '    D$=Wuv @=WtPtzu&    D$@v D$@tv v '    S9t>t3t[    P$T$@ @D$D$$;OuhO@O[        SD$ \$(P$T$@ @D$D$$*D$$\$D$$$
+   D$\[t& '    0O\4OtBD$L$D$-$D$$D$D$ D$$$
+   D$t& '    S(9HtG  5w`L$ $D$E1\([t& OY    ;\t  wg`\$ $0D$O\$P$T$@ @D$=D$$1\([    D$5 5$0D$fSD$ \$(P$T$@ @D$D$$:D$$\$D$$!$
+   D$l[t& '    ,\$$ Ot$(T$0KA9tItUw4wAt<t$T$D$D$T$(\$$t$(,t& Q\$$t$(,ZSPOD$\$$D$LOD$$=D$ \$D$$$$
+   D$oTO[&    0O4OtBD$L$D$-$D$$D$D$ D$$$
+   D$fVS1t$ t8u: Xt&&    Ct$$uC8tu[^Funty tm`t1t& Bu   yv $ctv$tVSD$T$xw@$\v M<,   f1[^r0uBr<Xt<xuZr&     
+&    DXtu   [^2Z<-tLDBt0u<ftDBu_&    $t    rZ1; t2f$   @O   <O    8O  HO    DO    O   v qt& W$,   \   1D$ BOB\B 4OB$hOhO O_        WS\$$$(   
+   1ZD$ B\B 4OB$tC<t u[_<$   T$ T$$PT$(P'    $   mT$ T$$PT$(P'    T$ D$$ttD$T$$   t& v '    T$ D$$ttD$T$$   it& v '    $   @    T$ T$$P'    $   @    T$     P'    St tgvt8[f&    rCCCC[    {`u \$j$D$fCC[    VS$ O\$4@D$D$0$ OFD$8FD$<5Ft5DJ u5 OPtD$4$ Op^$[^    D$D$4$D$DB tt& DB uD$(D$    D$D$$D$D$ $t& D$(D$    D$D$$D$D$ $t& SD$ C OD$C$C[    D$$$T$(D$    T$D$D$ $    '    StevD$$K1[$(C$   [&    C$   uC$   t& [u1t& Cu[&    WVS@@ct[^_&    _<u&    tCvC'u{uG8uCt& tt& L\$<\$Pt$@|$Dl$HC8tRC?  S<D$B$D$B @D$D$$t$@\$<|$Dl$HLt&  w      n  s<fut& 6t~uVt(Jut& Jv tI8   RuC8   C8c8H  Fu&    b8@tPu   G8 f   G<uv      txu@t   19uVNt& Z    C<u     txu@t
+v;1$Qt;CtRD$D$$79t<v@@nv 1_   C8c8Z1$
+   D$@\ntUumv UT$,$T$,tBD$D$$zY'    at& \$\$ t$|$t7PvC$CC$Ct|t/tt$\$|$s>w$H&    CxuSt``T   u   $RC    C    CxuSt`    b   C    PfF= 
+  =`  =*$   F $r1>t& ~4$Q$I       F$   D$/   CF    t&    @$D$   CC    b@$D$   C C    6$   F$~   F`S\$ tk   v L$$D\$ [7v uu*tC$C$\$ [f[u[t& S\$ tt}t[C$CC$S:C   8uH    u$CPSPS$e&    C$eCC$WS:CtL8[Ht D$C$   C C    Jt$ uv Jt $C0$9C$.   CC    t& S\$ Ct$eC        [&    At& S\$ tLOtO;t.Ku\$ [fC$\$ [     [v OtmOt`$OO    uIt>Ot1P(OP O\=,O   $Ov Ot& Ot9t& Ot($OO    4Ou$1O    O    O    O    O    O    =    =        '    UWVS\D$p8 u1\[^_]D$D$0D$   $u11D$,    t$(D$, XtW{tJC8uDCt=D$D$0D$    D$    D$    $Iuo9}BD$(uD$,|$,  ut$(t    D$0$5v T$(    D$$T$$>T$$D$(u$&    U1W   VS,|$@t$Dthf1    XuCv s8u(t0C|$$uuC8t,[^_]t& <$T$$H      1 XT$	s8S X,[^_]t& Gu"nty tm`x1	Bu   t& '    \$t$D$$   4$D$   $iC\$t$v '    D$ t$t$$\$|$   t[t\$t$|$     \$   D$ O@$C\$t$|$    = O_C<K8   u   t&     xfu@t   1Xt$$$J\$D$@<$L1&    \    O;BD$ \$t$|$\$$   D$   4$6$G\$   D$\X4$bt"t$|$\$
+f@ Ot$D$h$w\ O@\JVSWt$ u+v t"C4$D$u[^&    $        @    @    @    @    4$CWW[^t$t$$\$\$ |$4$4${t$\$|$ t& '    UWVSl$   t/C8x(SC8CT$\D$XCsCC    Cl[^_]&    _  =5C8 uC8G  C{s%  r  t& ,  fC8{st	  Cn     e  t$X   {t-C<K8   tfPtJ u9 \  s8   tzC<u&     txuHtWAtP      P8	P8t%P8@<t&    PtJ uItAus8   s8l[^_]s=,50K4tC8   C8b  $  @hK8   ,$}p
+     t$D$    C$G@  9   {"  t$D$D$4$4$C*fC8 twK4   t   S8ts9vkDurS8A  CD9sC  C8   t& K4G@  92{    NS8S<u
+ftzuRt
+
+v19ZRt& t$D$D$M4$|{tf  W4uOs<u   6   ~uF$]  FtFt
+v1  G4t{x$t& 	  K8   @$  u9E$  ys<u	6t~uvu&t& &      o4qvt~uC    1U \@\(C8 t
+{4#=\ \$t$$Ct1u   Ct$D$    $\$t$t& 
+   '    1v  Xtt& xt`8 u  u$   > \t$='    WVS\$ t$${9tt$$1tPK8   u%C<  K8tt& PtJ u tt9   st
+,   [^_C<u&     txu@t
+v`1H8   X@<u     txu@tt& PJ4tJ8   @u9   sgl@&    '    WVSt$ ~ &       \$4$u+9t't2fr1!\$4$t[^_&       VS\$    vD$$1[^$hC$]C$RCPwHtrtPCHwXtrtHL$$$      [^t& C$C@[^C$C$CPwHtrtPCHwXtrtHL$$tP1[^C$}[^   )    C$]C$P9[^C$5C$(9&    '    SX<t#t& {uC$Cuu[t& '    \$\$ t$t$${w'C$t& t$$   t& 1\$t$ft$$t$\$ \$ht$$\tA  4$D$   D$       C@19|C   @9mv M<,Z$   4$D$
+   D$    
+   C@U19C
+   @99&    D$$   \$ t$\$t& D$$        D$$          v t& '    ,\$\$0t$ t$4|$$l$(C   t$$   C8   u!  C8C<tPtJ u{4$8{h   tt$<$k   t8,$HCt$$9<$Qp   M<,v1\$t$ |$$l$(,$T    D$4   \$0t$ \$|$$l$(,tt& D$4        D$4       >0uF<X0<x(&    ,$C 0@x*v WV1SX<1t1t& CtC$v9Csu   9G4twO8G4G<O8tt& PtJ u uCW@1t$tL9GDt'GDG<O8   tt& PtJ u[^_O8v t    lWftu   5\HG8 t4t\ts&    SD$ X<t{uC$_Cuu[t& '    WVS\$ {tWst`4$C@u0t:CPt0[u'&    t$t   [^_f1[^_&    G$G&    L\$<\$Pt$@t$T|$D|$Xl$H  +D$\l$$W~D$D$    <$+vol$l$D$5,$l$D$    <$    D$D$\$~D$2D$    <$\$<t$@|$Dl$HL$D$3D$    <$CPD$<$T$D$D$    <$CPD$<$T$D$D$    <$N    CP  T$D$<$(CPD$<$T$K
+D$/D$    <$D$   |$t$C$Rt& CP  T$D$<$D$"D$    <$CPD$<$T$CP*  T$D$<$D$#D$    <$CPt& D$7D$    <$D$   9    D$   |$t$C$}D$*D$    <$D$   |$t$C$MD$   |$t$C$-D$%D$    <$D$       D$D$    <$    D$ZD$    <$V    D$ZD$    <$    D$ZD$    <$a&    '    D$$D$    D$ $D$D$ $Yt& D$$D$    D$ D$D$ $)t&   == uAD$=$
+D$    $G
+$   H8   @     '    S\$($T$ $D$   T$D$[\$\$ |$1t$tG$   SVSV;v:1$UD$4$    \$t$|$    $,CFCFCFfC$]FC$MFC$?Fv '    ,\$\$0t$ t$8|$$|$4l$(I  ;v1t$ \$|$$l$(,t& $L&    Cl$(t$8\$|$0t$ D$4|$$,t$D$   C$it$D$   C$P    h  ]\$4D$0   \$t$ |$$l$(,kv t$D$   C$t$D$   C$    uD$l$$   `q[4$It& t> tR`t^~\$0t$ \$|$$l$(,f     t`t@@$<D$4v D$0 \$t$ |$$l$(,pD$0    D$l$$   l}t& S(T$0L$4;t1([&    w$lt& B;AfB;AuB;AfAD$B$t& $hD$0D$4$XdOD$4D$4D$D$0$  T$0:t)1D$$T$4$D$dO<D$48uJ;HUWVS\$0l$4|$8t$<9t(9uED$|$l$$69ut$T$l$$?t& D$$t0E t9D$$T$E $t=t[^_]&    $$z[^_]$ d$ VfVS$t$0D$\$4D$D$    t$\$$   T$1t$$D$$[^v VS$t$0D$\$4D$D$    t$\$$   oL$1t${$oD$$[^v UWVS9t!)9u39u?&    tL$$u+[^_]v uB;Au= t=uv dO$?$5t0u$ $ [^_]&    $$[^_]        |$|$ \$\$$t$t4t.pv;19tFvE$$\$t$|$&    &    eWVS :9  	99  9t   t
+ [^_v    $8$   D$X$D$$D$D$D$D$$
+D$t	8   D$$D$$4$w [^_   "$$   D$$D$$D$D$D$D$$D$t8px cf$$dO=t& x,$$ ]dO&    L>Wt& &Iv UWVS<9t91u-9u?9tPvt%   <[^_]    u+7l$4$2  PY  U J    NL$(\  M9L$(uL$(IL$,v|$,u	  |$,[%  N9    $ )  &    +7l$4$pE  P|  U J    NL$(   M9L$(L$(IL$            t&   ~`  D$ D$($   D$   fM9.It& M9I<v 4$@$$$vdO3<[^_]4$$$$ 1dO3<[^_]{nt& i&    LfO&    ,f8m&    fVNL$	L$(w5L$IL$(NL$	L$(wL$IL$(|$(t|$(t    .N    `   ty`tb}`D$ D$($   D$-$U:v }} uL$(D$`$   L$a} FD$j}`t}3~ %|$yX  gf  SF= s  =   =`   =$}`D$ L$($   L$9D} fXxf@~v PL$($N}t}`&f}    }^B} D$`0VEB8/@8%9t<D$v UFB8@89t	D$$w}y}`D$T'    VSD$ t%dOt& 0dO    VvdO[^L$ D$ L$  5dOD$ t$D$ &    '    UWVS<D$Pxh<  t
+E8  T$PB  @l$D$&    G$mT$$\$$$GG  X<tt& s9u  u?uD$Pl$X      $8uT$PZ  t$P&       E8   C   @8    SH8  O  x<uCv ?t:H  G9tu@9ht<$D$[?ut& }  D$    l$$   >}<ut& ?tuG  x@uD$    $   SPfKtSf  z[  o  C$,$D$,D$5T$T$$D$,$9WD$,tzt$ D$,{C*St
+i  D$    $FT$$T$T$$T$D$B@$FT$B@]ua O tRPtRt$T$Pzu1,$D$D$PxtRl$E$?tG= OtHufpuC       E8f   M-  tD$PPn  ]<u+zt& t& R  &       tQCuCt   E1   zvB$D$D$uE8E8u?T$Pzt4$`nT$PD$B@$D$E@$E@<[^_]    D$<$(v _PEPED$`$D$ Ettt& C8ED$($D$EvD$$SJAp      D$$`qCxD$ l$$   &D$CD$D$$CCx<ut& ?9_uWD$T$$T$T$$fGRT$A,$D$>SRBH!B,$D$RfmD$PP1tBD$1D$   $$0$T$PD$  C  v @D$,l$$   t$,l$4$   D$D$   4$-D$,$$iD$,D$$9T$(T$D$(D$,$D$,$D$(t68t($   T$P    ZUx u$&    $^T$PStCCT$PD$$E8D$$C,D$Pl$@D$<D$PXD$i$}Zt& '    \$Bt$$t$\$$8O8O0 \$t$        t$<O|$\$|2;=@OC8Ot$\$$?8O5<O5<O0 \$t$|$    8O|$$<O=@O8O&    '    UVUUUW1VSt$0     XtCt& Ct0S8   u%tw   w5ft~    u  utw[^_]t& t;u    )RS8)Ktt   S8C        C       C   f1v  Xu      {tC8   ut${us<ut&     6t~uF   H   1	fPt
+@u6Ft<Ht51A    @t"Ht9uA   K@uv C8   $C8+  1f|t& '    S(  $0  D$$uEtA;/tE$t5\$\$D$D$$D$$(  [1(  [    UWVSl$0  D$$E     t$D$   D$   $Wu%F    CD$4$D$t#;uCD$4$D$uD$4$D$\tAt& Ct5@<uf     txu@t
+vK[ut$D$   D$   $4$l$$1[^_]fxtG$:tYD$GD$4$D$D$4$D$t$D$   D$   $&FCS\$ $@     C@   [ &    ,\$t$ |$$l$(($O13C(   tO9tC    C$    C    /\$t$ |$$l$(,        ,\$\$4|$$|$0t$ l$(tYw4$$l;/w$\$4|$$t$0\$t$ l$(,0t& 4$l$p/Gv \$t$ |$$l$(,t& UWVS  $0  $4   t	; z  e$4  T$$D$(D$(T$$D$D$D$4T$$>$("t	8   ?T$$$   D$@$T$D$D$$D$ D$   D$    $  $U${4$$Pt8 u4$dC   sD$   D$$$    vT$ l$|$t$$D$-\O  =W  wtv F8   GtGwu<$tG  @D$D$ D$g$xGut& uf  tv C4$(F8fLF8F   1$f*  ^FD$D$D$ $l$ |$,t&   "t2\t-1&    "t\t4un  _L$D$,$N  V:0uJX  x  T$FD$D$D$ $D \$F    FT$ D$rD$$v D$ $p$    tyT$(D$$T$$BL$$!%t  u .oldD$4A T$$$T$T$4$   T$$uID$   D$|$    T$4T$$a$      1[^_]t&      [^_]D$4$    D$$D$ v $  D$\$$   qu$  %   = @    D$/   $&\$($4  D$$;)x$4  |$\$$F<4   D$(~ UD$("fl$D$   D$$qT$ |$,D$   D$   T$$FN/$wVtrtFD$T$ FD$$D$GFD$D$D$ $'FT$ D$D$$$4  \$D$$$T$$D$&$=D$(mW1B&    '    JL\$<t$@|$Dl$Hv1\$<t$@|$Dl$HL&    j   vH 8 0wxL$8uL$l$$T$,L$T$,f TMfUWVS  |$ > D$$   $   )\$^D$$ >o
+f0nu_t D$    <$$FwVtrtFD$$ >pG\$$ >[   >[^_]S(x$t<\$D$D$$ ?D$D$D$ ?$   tx[t&  ?x[        UWVS<  $P    $  $T  1LO   l$,PO    $T  \$(yTO    XO    v 4 Xt\l$$l$(t& ~t?F8!F8t	F8FwDt$D    D    6ul$$  u\$(D$0$T  D$D$2l$,D$T$$L$,T$0l$D$   $TS  D$0PO<t<
+t$><#   <Cfut$   uL$7D$=   $tx  D$
+   <$D$ vT$ tx  y  $T    D$7T$ $T$   ^8#  ~   Ff$t$   T$9D$    $  p
+   $T     L$9$&  ^8I  FwT$$	^8D    pF8 fF<ut&  txu@tc  1T$$D     T9sD$$TR"y  t/T$ vT$ &    t
+DQ tF   |$4$	  F|$$D$,$1 \1t
+$q1<  [^_]L$7T$ D$    $T$ x @   D$$| b  T$$tDL$$TF$D$lT$$D$,!G8DTxD$9D$    $x @   <$L$$	^8Dz"GD$(<"   <\   D$(u$6B<m  <y   <ntKF|$$D$BFT$ $D$eT$ @ ~L$$	^8D    GF$4D$,T<"t& t=$L$ vT$($T$D$L$ T$$	^8D    F$D$\$2#$   \tp<t
+~t6   yF$=tF8u@@&$tD$   D$$    \$$D$$	^8D   $   Ydt& UWVS  $@D$   $$F  D$$    |$4D$     D$  X  t& {  $C8  s  #     1  Cr>      T$T$t"_u/   uf.hA D$  D$A  <$u}{  G}8N      /4$D$/   }"   $   D$|$$   }tD$  <$"}tD$$   $  |$$   D$$$sD$   D$$/SD$$  D$    $  $ $&4$*4$SwKtrtSD$D$ T$D$X$4$2SwKtrtSD$D$$T$D$$jD$(        D$( X  t& zn  $T$BT$B9T  BI  J=  $CS$T$@ct& D$ |$   ,     [^_]D$  D$A  <$z  $Y~   t8C{ qC;C [v wJtrtZD$D$ T$\$D$$}T$\$BD$D$D$$$}T$~D$(|$(  SD$ $c|D$$$W|$z  D$$/{z$$D$zt& J:  cD$D$ T$D$$}T$BD$XD$D$$$|T$t& rD$D$ T$D$$|T$BD$mD$D$$$|T$T$,f   "t.\t)1    <"t<\ft<uuBD$ T$uD$$6|E D$D$D$$$|t& D$ D$   \$4$D${D$$D$   \$4$D${uT$,D$ D$   D$   T$D$${D$$D$   D$   $D$e{T$3Z;0uKXJxAD$D$ T$\$D$$4{T$\$BD$D$D$$${T$<D$D$ T$D$$zT$BD$<D$D$$$zT$qD$$   D$ $Wy    &    WV1S$    ,D$ D$    $H   f   Xu3      u    fJ     t
+XOv tr{t${8   tC<u txu@!  P  	fPtz4 t#J8@u!K8u  Af1     Xtkt& CtXS8   tM uHK4u=XOu	S8w&C$D$uc8XOt& u  {=TO    tn$1[^_t&    Cw#C;C!K8 CS$T$yte1=XO S('  $8'  D$$4'  \$$D$'  D$ku$0'  \$$L('  [t& UWVS\D$tt$pD$,t9@t0R  L$,QT$D$D$4$`D$,@<D$(  t& T$(B9  D$   D$$    uD$   D$$    u\$4$D$L$(Ax$@ XD$   D$$    u|$\$4$D$T$(BtT8  D$   D$K$    _u4$D$T$(t$B$D$4$L$(AXW>  1fWtG\0S~D$      D$$    t4$D$D0D$$   @D$   D$$    tD$    l$D$4$D$CtOPwPtrtX@G  \$D$D$#4$OD$4$t:T$$T$$C<S12B*&    L$(	L$(D$,X<tQ1&    t8{u   D$/4$Dt$C$U   u   T$,B@tKD$   D$;$    Gs4$D$L$,t$A@$D$4$t$pD$t\[^_]t& D$   D$Z$    r&    x L    D$*4$IB7"$D$4$&    |$|$ \$\$$t$Ww   FtOD$D$Z$@GtiD$   D$$    q$D$D$$t!t$$|$\$ t$\$5t& \$t$|$D$@$H    \$D$(t$\$$t$ D$4$tQCv&Ct$ \$D$(t$D$$g[v Stru\$t$        S\$ $=t>$   r\     @    $@   @   \[\$$nq$   s    '    D$D$$q$   ds&    O\$t$   OS;Ov\$t$v     T$$nO   O    uz   1    9rtf  t O{f$   `qOtW     O   O    Et&  yv f  o$O?$Ov \$\$ t$|$l$   O   -Ot/5$O=O0~=(O~tMOC(OC=O\ ,O   $O\$t$|$l$v O&    '    S\$O1t	O9tatgOt$OOJ(OJC(OC=O\ ,O   $O[t& O    ,\$\$4|$$|$0t$ l$(w1\$t$ |$$l$(,| u| u$0   *otC]}}E    E     ]E    E   E(    E,    ,$X&    UWVSt$4|$0n,$ntN~1f9uD3 3 $l$tC   [^_]    S\$ $l$D$d[VSt$$$0   ntEs4$mCt T$ C   >[^    vt& ft& SOtKOt<T$ B(OBO\= $O[&    3O=D$ @  $OOtO&    OnfWVS |$0<$$   l     @    O1\tOA<$=tVD$ @  $s$k\5\C   u^C\C   C\ [^_0O4OtB|$L$D$$9k$   Mm0OC4OXtB\$|$L$D$$0 j$   m0O4OtB|$L$D$$ j$   lUWVS<-O   5O$O1O~t& )=\W$O 5O'v'Ht& 5O$Oz    $=OO   u
+O   5=t`=tFOtmOt`Ip (O5O5\=$O=t& =O   =t& O=D$ @  $OOOb=\5OD$$$OO-OL Q9T$   ATD$ (OT$(T$D9s6T$(&    
+-OOL ;AwT$(QT$ T$()D$ (OAOD @9s
+` T$$FV=\VO$OO   O   \@  v <[^_]8OO   W  \	  H`@\\t9=$fO1tO$<C$1\$`f  \d5W\t
+@!  8OW  $    W\0\O	   0OR4Ot
+@  \Ws8OW    \$   ]g@O   <O    8O  O   N\@@\9     >!0O4OtBL$D$$ e\@  O   $OF)OW=\V$OF O\@8OO   W  \   @}`W|  =\L p  t& A<	?  Wu%HODOHO~\O   @  $OF)O=\WV$OF WO\8OW  W\tW$OF)O=\WV$OF WO\%8OW  W\    &    !     +\D$($O-OOD P,D$J  (OT$JOT$ 9T$   \D9D$ T$$  D$@(1  D$ +D$$x  L$A5(O|$$O95O   t
+9
+	w{W1~%\119t<	uHO=DOu9)~)t&    fG|I,T$L$B=(OA,   W@D$ D$ D$$)D$ D$ ~5l$ 1|$t& 9u-OO|$D D$T$z,  T$ L$Q   O|$\$,\$ t$$Q    V~pFD$F$^FtE)-O<8O=OD PM1t	Ot VnuF     FF< v |$t$$\$,T$]T$         ~    |$\$,\$ t$$"?	  =    $@`OOp=$ ]l$t$$ _(Ox|$t$$\$,O-OD$    T B(OD$,!  OD$,D$ L ;AL$$  T (OR OOP(OD OO|$@\   |$|  T$(4O95Ov8f   t
+<9<:?w T$L$-OOL$T$D D$OD$ \D$$(O    B    D$    O(OD$   D L$,@,   D$$D$$,O    OO#b|$t$$\$,(O/L$,T$$D$B$[L$$O-OAD H  D$ (O-D$$=$+(OD$   -OT$,\	=$]1t$(=\5\O95Ov6   t
+9
+	wk 5O8OO	   W  +D$ (O-OO    UWV1S  $p  l$P\    WD$8    D$(   l$<D$D$@    D$4   T$4f3|$0W9   |$('    d$(|$('  vD$('  L$(D$(D L$,$]  )D$0$T$ D$|$[L$,    T$ D$D$<
+$L$$D$s[T$ ;|$L$$t<$ZL$$T$ |$(CB,z9|$4  L$<  6 tKW  R  =!     w:=  w 9L$8   T$8 D$,   T$,   )D D$De  T$D    L$,))mP`#   ~   @|$0f    L  &    D$@   t$0\-t& 9tl#| t  wf?u? ~WD$@   U H       =WtT$8W{9\$0t+t$0v {9u|$9|$0tD$0$X  [^_]v |$@up=W ~aT$8W5{t$0W$xf;	t	 ot& W    1m
+  t$0W|$@T$@WU !D$D    t+0O4OtPL$T$$X$    E$ OPhOOD$Dav W|$0   PD$,}|$D"ED$E$   D$0O4OtPL$T$$WM L$D O@^	  @   0O4OtPL$T$$fvWkD$   E$H8   $D$    D$    $    0O4OtPL$T$$VE D$E$   D$@D$DE     yOhO@O0O4OtPL$T$$oVdE $   D$kD$DHE}D$E$   D$e|$$   D$
+0O4OtPL$T$$UM1L$L}|$HD$HQt
+@(  D$H$D$?{T$L$TD$   E $D$DE $fT[E}@P      ))36 t$0 O@H8   0O4OtPL$T$$TD$    PE     wOhO@O0O4OtPL$T$$ lTa$    |D$    E$   D$4-0O4OtPL$T$$-TE     %wOhO@O0O4OtPL$T$$9St+0O4OtPL$T$$hfSu{VE D$E$   D$v|D$D3$u"E$D$u
+E $I}D$DE D$E$   D$|D$DE $	D$su$ bufE$2D$Hu$F7uxD$    E$H8   $zI0OM=4OtPL$|$T$$wRD$    E$H8   $jz0OM=4OtPL$|$T$$UQ}t<4O}MD$H0OtPL$L$HT$$HL$jQ$DU$    yD$    E$   D$(}!0O4OtPL$T$$YPE}D$E$   D$|E@t$lu=4OH0OtPL$|$T$$P|}D$    E$|$$   D$|E0O4OtPL$T$$ PEx }D$    E$||$$   D$8|0O4OtPL$T$$OE D$E$   D${E D$E$   D$xD$D_ED$DSUT$DGU  OP7E$V{0O4OtPL$T$$tNE@$sEH0O=4OtPL$|$T$$N   f1    U T$@$i$sU$|sv '    VSD$ $?jOW OWhOWD$    $    xH8   @    \D$    D$$   yW=\     \x< td$W1 Xt$t& {t$
+{t\u  u=\ uHD$    [^hD$$   vD$    $$UwCf$   OWVSD$$"   N't& \$~D$   D$   $9MD$"   <$iJt')t|$D$D$$%M&    \$<$@I\$$"   N[^_    '    WVS5W|$   ^"  t& C8  |$D$   D$   $zL{  |$D$   D$   $4PLt& [<uO&    tB;suC    '  D$D$a<$Lut& ^t>$K:
+u     ^:
+t\$D$u<$K|$$
+   LF   ^^tC    Ct8  |$D$
+   D$   $;K|$C$|$$
+   Khv v    vv 
+  Ft
+xp  tEv C$|$D$	   D$   $JY|$D$   D$   $-J4|$D$
+   D$   $"`J|$D$   D$   $;J|$D$
+   D$   $Jt& CD$[<$D$Jvt& |$D$	   D$   $;ISFCt88   |$D$   D$   $I|$C$|$$
+   I2f|$D$   D$   $PLIv |$D$
+   D$   $E$I|$C$Ct8Sx Fp&    [^_|$D$   D$   $HS?|$$
+   +I;f|$D$	   D$   $x |$D$	   D$   $UHk<\$,D$@|$4|$Dl$8l$Ht$0t$LT$L$D$l$|$$DD$  t]C$D$DD$D$$ZHD7l$D$$D;t$}\D$T$T$9}It^C$D$PDt$0\$@|$4D$H\$,D$Dl$8<Gtd]C$D$D$D$C$D$C\$@t$0\$,|$4D$Dl$8<Ct& tT]C$D$C$D$C$D$}C$D$lCt& '    UWVStT]CD$    t$$?ClO~$1&    D$    $	C9=lOpOt$$D$Bt   ]C$:        tf   ]CtOt$$D$BtS   $D$BtuTt]C/  D$$D$Ft pOt$$D$HB$PD[^_]t& ]]a    ]'    $X     D$$XD$1ELt$@l$Hl$P\$<F|$DzD$,D$   D$$    DC1T$T$,|$$T$D$  D$   D$$    C1T$kt$|$$D$  T$,|$$D*D$At$@\$P|$D\$<l$HLCUWVSl^8  ^= ^5  D$4    1${  u;^   ^t5= ^t.$X   p  t  @  t  D$4v \$4$   1$   $   D$P    T$X$   D$T$   L$\$   D$,    )D$LT$DtP;T$Tq
+  tP;T$XW
+    $   T$$9P  +$   $   +$   L$$   l$|$D$$  $   $   l$|$T$$?D$   D$<$9?\L$<$   D$    D$d\$T$D$    D$$   D$  L$<t\T$<BL$\D$<D$    L$$>tT$<D$$>T$L~7t$(t$<1|$0|$Lt& 4$D$X>9|t$(|$0D$<^  L$<d\A$D$#>$   $   L$<D$T$$  d\T$<BL$L$   T$<D$   L$D$$D$   g  L$D$   l$TlOT$T$<D$$   $D$>D$   D$@$=T]L$DD$   D$d]L$D$lOD$$   D$D$<$  ^pO       ^= ^t[pO-    pO^pO   ^t3= ^t,  $?9w  $?XpOlO$   )9T$4CpOtO|D$4)p)t$4l$$~7l$$1|$4v 3$e  D$@199pO!  $   T$D\$4$L$T$T$4D$<$   $   D$<$    L$<$@D$@$@<|$,D  T$$T$Ht& L$<1$>|$$D$,~v-=T$,T$(D$0D$,D$8%t& L$0l$,9!   ;,t99\$$~03$U  |$(  wD$0T$88,   ;,u|$,  ;\$$      |$,+   |$,     |$,-   |$,Sx  t& #  |$,t& @  f  |$,?C  |$,Hf6  |$, 3  F;\$4|$,&  L$@$;D$<$;D$P   D$Pl[^_]&    |$,-t   L$4}  e  $   ~Q4$#
+  D$@11L$@D$   $^9D$@D$$J>T$@D$    $694$	  D$@   1OpO	  $   T$D4$L$T$1D$<\$1XL$<$=D$@$|;|$,\$4t& |$,+t
+|$,  u\$HT$49  \$4;\$4tZT$4$	  T$41D$@3$	  D$@   L$<$=D$@$:dt& \$4W&    \$4|$,xt&   |$,ht& t*|$,st+|$,XfD$,   )9\$4D$P   ^   ^ $    l  ^   ^t= ^ut$44$%  $   9  T$@$)9L$<$9D$Pl[^_]|$,  H|$,  m  |$,  +D$@$8T$<$8  |$,	v .  |$,
+t& 18\$4^68C  D$$5  9$   ~S<$4  T$H1D$@L$@D$   $m6D$@D$   $Y;T$@D$    $E6D$H$  T$H   D$@V=pO  $   T$D4$L$T$T$HD$<|$_L$<$  D$,!7\$4|$,     D$PD$P   D$P   D$P$   $   $D$<DT$<$$86\$4t^19$    D$5$   $   $    T$L$o  1|$P!D$Pb^D$4     l$PD$P'D$P kH\   L\   P\   X\    \\    `\   h\    l\   p\    x\   |\   \   \   \   \   \   \   \   \    \   \    \   \   \   \   \   \    \   \   \   \    \   \   \    \    ]    ]    ]   ]    ]    ]    ]    (]   ,]   0]   8]   <]   @]   H]   L]   P]   X]    \]   `]    h]   l]   p]   x]    |]   ]    ]   ]   ]   ]   ]   ]   ]   ]   ]   ]   ]   ]   ]   ]   ]   ]    ]   ]    ]   ]   ]   ]   ]    ^   ^   ^   ^   '    x\   |\   \   \   \   \   \   \   \   (]   ,]   0]   H]   L]   P]   ]   ]   ]   ]   ]   ]   &    D$@\    ^T$   ^T$   ^T$   ^tV^ ^tR      tC&     ^t8   u>   u^    1&    ^u1f^ ^1v ^   t& ^   t& ^   v ^1tt&    u^L$tC^= ^t@   uRt& = ^t19t=   u^    t& ^ut& ^ ^t& ^&    ^t^19u	9t   u1v ^v '    ^           ^D$8   &    VS^
+!%t  tf )t$$!%t  tD D$ t$$D$   )D$.^    [^    W$   1^tD^   16   ^D$$D$D$   D$ $D$t._v ^'    S^tv    $n/u^    ^ ^[v WVS\$ D$   $2.D$    $-$z0$p0f$d0uD$    $-D$   $O-u   u[^_utt<$f/    UWV1S1,l$@,$%/D$wv 0T5  <$|$-|$$-~u.t. Dxt D$D|$$,t,$.D$;t$r1,[^_]v '    UWVS,|$@l$PtG    \$L   D$LU1T$D$D$T D$v T$H<$T$T$DD$+   1h9t$   u
+9\$P             9\$   D$<$D$r+    9~(uv uD$X<$D$A+99t$L<,[^_]t& bD$X<$D$+9\$VD$T<$D$*sv D$X<$D$*Ut& D$X<$D$*5t& D$T<$D$*t& D$T<$D$f*t& D$T<$D$F*t& UWVS,D$D\$@l$L|$PD$D$HD$-   tT\CD$l$$D$l$)~%1v $+$%   D$)9t$9|N|$t$|$$)$a+$%   D$)$H+$%   D$g)9}\$@,[^_]-&    ,[^_]&    ,l$(l$4\$\$0t$ t$8|$$   ,$~Z+9   tt\C)40FD$D$    $(tD$    $(t$D$    $(t|$l$$U,\$0t$ D$4    \$|$$l$(,q(t& c\$t$ |$$l$(,t& UWVS,T$LD$H|$@t$DT$D$D$PT$T$<$D$T$!(tL$  \GD$1D$<$+1> ut& < ttT$  \G~1fD$    <$'9|   D$   \G<$D$_'\GD$t$<$+\G<$D$D$*T$|$@DD$HD$D$D,[^_]'v \    \G<$D$&\GD$t$<$v*\n\    $    D$&D$t$$    .*.    '    UWVS<  $T  l$/$P  $\  ,$D$(,$u(~#L t& 9t:
+u 9u$`  $X  )9Y  |$/   $`  \$D$   fD$    ,$$&t  $X  ,$)L$'9D$   VD$tNtJ$T$'T$;D$v.D$    $T$%T$   )9D$   D$t$1<$D$&%D$l$<$(D$twT$tD$    < t<  [^_]t& < ttD$   v D$$`  _$X  \$<$)D$x$l$<$D$(<  [^_]    '    D$ D$D$$D$$,$$/&g$t& '    SSxOT$SxO$T$ &SuxO[    xO    [t& UWVS,t$@D$D|$HD$D$LtFL$~F1t& D$    l$4$h#~1    D$    4$9#99l$tFt$@D$L   D$HD$D    ,[^_]$        SD\D$D$D$$$@\   t	D\PD$   D$    $"t@\D$D$$%&D$   D$   $X"=~0       D$$"9$B&[  WV"#  P@O    D$ $@\"?     ;  
+        c        D\    T\    d\    t\    \    \   \   \   \    \   \    \    ]    ]    $]    4]    D]    T]    d]    t]    ]   ]    ]   ]    ]   ]    ]   ]    ^    D$   $ "$1^_H\   L\    P\   X\    \\    `\    h\   l\    p\    x\   |\    \    \    \    \   \   \   \    \   \    \    \   \   \   \   \    \    \   \   \    \    \    \   \   \     ]    ]   ]    ]    ]   ]     ]    (]   ,]    0]   8]    <]    @]   H]   L]    P]    X]   \]    `]    h]    l]    p]   x]   |]    ]    ]   ]   ]    ]   ]    ]    ]   ]   ]   ]   ]    ]    ]   ]   ]   ]   ]    ]    ]   ]   ]   ]   ]     ^    ^   ^    ^     >\D\fT\\d\Rt\H\>\4\*\ \\\\]]$]4]D]T]d]t]]]]]]v]l]b]X^N4cv v &    v v w     Lt$@l$Hl$P\$<F|$DzD$,D$   D$%$    t1T$T$,|$$T$D$ED$   D$$    51T$kt$|$$D$T$,|$$D*D$Gt$@\$P|$D\$<l$HL;UWVS\$     D$$ _vD$x1T$|D$$D$0    D$<D$xT$@T$|D$DD$|T$,T$|D$(T$HtP;T$<  tP;T$@  +T$|$+T$x\$4T$|t$T$T$xT$T$xD$|\$t$$D$D$   $\T$xD$    D$    D$d\T$$D$D$|D$nt\CD$DD$    $D$t$D$pl$,~$l$,1    $D$H9|8  d\C$D$#T$|D$p$T$D$d\T$,CD$tT$D$   D$   D$$D$   D$   $PT$4\D$T$d\T$T$HT$ZL$|T$x$    D$4D$   $D$x\C _!%t      _;t$(  t$(+D$(PT$0~(|$81/_$D$9|$8FD$D$4$D$$  T$(T$8$|$$   htDj &      f  O&    x  X&    B  HuSt& $t& wD$$   D$$\[^_]&           N    f/  T$0  T$0:=    =  $=  t&      t& f Dx@T$0=  P  t	\Sl$8 __ 98  D$4nt$$D$^|$$BT$0T$ $RT$ )t&     x    =  ot& $D$$    D$$\[^_]    =  ,	#u|$0t\C  D$09D$8.  1D$0    T$4D$   $T$rL$(~9|$Ll$01|$(5 _u    T$$)9|$L _!%t  u  _)8  v 
+     	v D$$&  |$$  |$$T$xL$|$    T$0D$$    {&    /t& D$D$ _$b$T$02     _ :t& T$$   |$$#  |$$HL$|T$x$   D$$   %$3$t& 1|$$!D$$D$$\[^_]    T$xL$|$   T$0D$$   k&    L$|T$x$    RT$4FD$$T$G$OD$$p    $DD$$   !v $    D$T$|D$p$    T$D$T$,D$tD$   D$   T$D$$    K\T$HD$   D$   D$d\T$D$    $    D$-L$|1T$x$    WD$   D$   $    GD$4   T$xL$|$    FD$D$4$D$$T$0D$$L$|T$x$    D$$    D$$ D$0~T$4|$$0 _ T$tD$    $wD$4|$$D$s${D$0+D$(D$0{T$00T$0D$4D$   $T$ D$T$ |$8 |$L1T$0$2_D$9t$8|$LWVSW    ~mW1W=W9 ut19=W[W^_9tQ&    :
+ft9uW=WW   [^_&    '    V1SWW    CPp
+tgt& u<W   W      O u	5WO[^v   (OPp
+uW1t&    tt& W t& '    <\$,t$0|$4l$8L$ $W9v|= D$    t$$,D$    $<$TT$9sT$|$$$_\$,t$0|$4l$8<\$t$|$   D]$C%   D$:=W<$5W1)kdSCT$$D$Yt$$D$,\$t$|$D]$    %   D$=W<$L5W1)kdUWVS,D$D$@W    D$D$DD$D$HD$~811&    L$uWWt   9,$D$D$D$D$D$D$$BD$D$@,[^_]>fUWV1S\D$tW   W    W    W    WW8  QAZ    \$x\$8uT$8T$|T$0uD$0+D$0\$0$+D$8\$D$8l$T$D$T$, T$,\$\$8l$T$$D$   $+D$8|$0T$,l$D$<T$|$D$$:D$4Z  d\T$4B%   D$D$4$]T$4D$   $
+\T$8D$    D$    D$d\T$$D$D$0D$#t\CD$8D$    $D$H
+t$D$"
+~1$D$
+9  d\C%   D$$$D$	T$pD$0$T$D$~D$   D$4$    ^D$   $D$0T$D$0D$D$8D$$SD$0T$@d\T$4|$D$D$<$D$T$0D$@L$<<$T$T$4D$CD$<D$D
+    $g  qH  &       0&      f  E&       G&      Bu-WwD$<W  =       kt& r  f  x&    tf=    l!W=  W!  v Lt  bfee&    tXv fT$41$$\[^_]=R    ~[=h      
+  =  t&   =S  t& 
+rD$4$$\[^_]f=  7  =  f*f-WWT$0W   WD$@T$D$)  J  K    WWD$4D$   $T$4D$$	D$4D$    $T$<W    |  11\$Ht$Lt$4@&    14$
+uWWt   9l$<  t        W0  WW T$@D$0T$D$L$<T$4<$^   t& WT$@D$0W    T$D$hgj^WPT$4W    D$   $D$4D$   $	T$4D$    $~D$4T$DD$4$3	0T$@D$0$T$D$$D$8T$4$$ -WW   ,$D WD$<D$@T$0D$T$$:fd\$    %   D$$    D$T$0D$p$    T$D$D$   D$4$    D$   $    D$0T$D$0D$D$8D$P$    D$0D$@)&    d\W    u&    \$Ht$LTL|$Dt$@t$P\$<Gl$HjD$,D$   D$;$    1T$T$,l$$T$D$D$   D$A$    u1T$|$l$$D$FT$,vl$$DD$t$@\$P|$D\$<l$HLx        UW1VSLD$hl$lD$,    D$0D$hML$4uD$8tP;T$0o  tP;T$4U  $l$)+T$h\$L$hT$T$(L$]T$(D$h\$l$T$$mD$   $\L$hl$D$    D$d\L$D$    $D$t\CD$8D$    $D$!t$D$ ~51l$<t& 4$D$ 9|l$<  d\C$D$ L$`l$$L$Qd\CD$dD$   D$   t$D$$T$h$      $LY-  S   f    &       N&    u$v 'D$,   D$,L[^_]&    =  ~=  u$ =       &      D$,D$,   1|$,!D$,L$,T$h$)$}t& 	t
+$n D$,L[^_]    $nyt& f$t& ' D$,    D$,L[^_]&    D$,   Vv $    D$D$`l$$    D$cl$,D$,D$, >$D$,   )\$t$|$D$   $|$$$D$    >$1 \$t$|$t& UWVS,T$|$@L$l$Dt$HD$D$t D$CD$l$|$$D$  t]C$D$D$D$$+D7l$D$$g$o;t$}
+t$9t${td]C$D$"$D$$D$ $D$D$$D$D$D$\$@,[^_]v t^C$D$D$D$$O tT]C$D$o$D$^$D$M$D$<t& '    UWVS,D$@D$D$DD$W$t$W+W<$D$W+W D$H<$  T]CD$    l$$$T$   t]CWl$$D$|tD$|$$D$tDtL$   ]CWl$$D$,t7$D$T$tWl$$D$<$\$@,[^_]v ]>    ]|    D$    l$$    $    &    UWVS<t$PGjD$,D$   D$$     1T$T$,l$$T$D$D$   D$4$    1T$WT$l$$D$D$   D$$    1T$|$l$$D$ST$,vl$$DD$\$P<[^_]&    UW1VS1|D$l    D$D    D$X    r  BRpj@J  @  HL$PT$HD$@l$@9O  +D$H+D$PT$0L$0D$HT$4T$PL$D$D$4T$D$$NT$0L$4D$HT$T$PL$D$$VD$   D$<$r\L$HT$<D$    D$d\L$D$    $D$D$PD$t$<t\L$<AD$PD$    D$D$<$tT$<D$$L$HL$8~4l$Ll$<1\$Tt& ,$D$9l$L\$TL$<  T$<d\Bd\$%   D$L$<$D$AD$H$   L$<D$T$$d\T$<BL$8$   T$<D$   L$D$$D$   T$0D$HL$@T$T$4WD$D$<L$T$$D$   D$0$T]T$<D$   D$   D$d]$D$WD$D$@D$WO"  FW^tI^= ^tK$   f^   ^t,= ^t%t9u^ut& $   9D$lt 9s	  D$l    9  ~V1\$4T$D$$:   }F1D$19$D$019\$4L$0$L$l5WL$,*T$@L$,t$$   T$D$<T$PL$HD$<$    }WL$0|$$D$D$0$|  UMT$\L$L    D$0$=   + DXt   =  wo     \$$Q1    D$4   |$4    -D$8        S    +t&   R  t&   h  R   &    z  f  
+&      &      	O    v   D$XD$X,  D$X   T$XL$HD$<$T$PL$0$v   t& -D$8D$l$J$:   D$,T$,$    T$D$0|$8 ^  D$le  $$:   1T$$   D$0zL$l5WL$,T$@L$,t$$   T$D$<rL$<$D$0$vT$0$pL$<$dD$X   D$X|[^_]t& D$l$"$:   D$,T$,$    T$D$0+        S    R  fz  D$l&    |$4 tD$l   1t& w9~ePl$4|$TD$8t& 9t$4~9D$l$ID$H$4T$8:;,u|$Tl$49  9fD$l$$:   1T$$    D$0;|$\  ;|$L~|$LD$lD$0T$lD$l$$:   V11T$$    D$0D$lQ&    1~\$4t& G9~9~l\$l9}D$0   T$lD$lD$$:   L$L$    1D$D$0x9\$4v x?  m     n&    ~st& $   D$lL$0$sD$<$g|$l<$?$   SnD$X     /D$X   mD$X    D$X   D$X    t& D$0D$   $ D$l1\$4[D$0T$l.D$l$$:   f/$    11D$D$09D$l~1)9\$4BW     1l$4|$TD$89t$4c  D$l$D$H$L$89{;,u|$Tl$4v t$l9D$0   T$lD$lD${$:   OL$L$    1D$D$0D$lH?  t& D$X   $   D$lL$0$+D$<$|$l<$$   D$X|[^_]&    9h  D$DD$l+|$Dt& |$T1l$4  d  y fv     f+9pD$lD$D)ie/f  t& fL$0$D$<$D$X T$0$Sd\$    %   D$?$    D$zD$H$   $    D$T$@1|$X!D$X/)D$DD$lst	yID$X   l$XD$Xv11U]t& '    UWVSO   Qj  )t$1ED$ED$E$9r[^_]$US\t\fu[]US    [i  LY[             KERNELVERSION ++> %s%*c%s    %*c%s  --->    %*c*** %s *** ---%*c%s [%c] <%c>  (%s) -%c- {%c}  (NEW) %*c%s%s ---  Main Menu Internal mconf error! File does not exist! Load Alternate Configuration Save Alternate Configuration README Search Configuration CONFIG_ No matches found.
+ Search Results /usr/share/locale linux MENUCONFIG_MODE single_menu   %s - Linux Kernel v%s Configuration     Load an Alternate Configuration File        Save an Alternate Configuration File    You have made an invalid entry. Can't create file!  Probably a nonexistent directory.   Enter CONFIG_ (sub)string to search for (with or without "CONFIG")  Search Configuration Parameter  Your display is too small to run Menuconfig!
+   It must be at least 19 lines by 80 columns.
+    Do you wish to save your new kernel configuration?
+<ESC><ESC> to continue.  
+
+Error during writing of the kernel configuration.
+Your kernel configuration changes were NOT saved.
+
+ 
+
+*** End of Linux kernel configuration.
+*** Execute 'make' to build the kernel or try 'make help'.
+
+   
+
+Your kernel configuration changes were NOT saved.
+
+                   XH5XXXXXXFXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXe                            Arrow keys navigate the menu.  <Enter> selects submenus --->.  Highlighted letters are hotkeys.  Pressing <Y> includes, <N> excludes, <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help, </> for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < > module capable    Overview
+--------
+Some kernel features may be built directly into the kernel.
+Some may be made into loadable runtime modules.  Some features
+may be completely removed altogether.  There are also certain
+kernel parameters which are not really features, but must be
+entered in as decimal or hexadecimal numbers or possibly text.
+
+Menu items beginning with following braces represent features that
+  [ ] can be built in or removed
+  < > can be built in, modularized or removed
+  { } can be built in or modularized (selected by other feature)
+  - - are selected by other feature,
+while *, M or whitespace inside braces means to build in, build as
+a module or to exclude the feature respectively.
+
+To change any of these features, highlight it with the cursor
+keys and press <Y> to build it in, <M> to make it a module or
+<N> to removed it.  You may also press the <Space Bar> to cycle
+through the available options (ie. Y->N->M->Y).
+
+Some additional keyboard hints:
+
+Menus
+----------
+o  Use the Up/Down arrow keys (cursor keys) to highlight the item
+   you wish to change or submenu wish to select and press <Enter>.
+   Submenus are designated by "--->".
+
+   Shortcut: Press the option's highlighted letter (hotkey).
+             Pressing a hotkey more than once will sequence
+             through all visible items which use that hotkey.
+
+   You may also use the <PAGE UP> and <PAGE DOWN> keys to scroll
+   unseen options into view.
+
+o  To exit a menu use the cursor keys to highlight the <Exit> button
+   and press <ENTER>.
+
+   Shortcut: Press <ESC><ESC> or <E> or <X> if there is no hotkey
+             using those letters.  You may press a single <ESC>, but
+             there is a delayed response which you may find annoying.
+
+   Also, the <TAB> and cursor keys will cycle between <Select>,
+   <Exit> and <Help>
+
+o  To get help with an item, use the cursor keys to highlight <Help>
+   and Press <ENTER>.
+
+   Shortcut: Press <H> or <?>.
+
+
+Radiolists  (Choice lists)
+-----------
+o  Use the cursor keys to select the option you wish to set and press
+   <S> or the <SPACE BAR>.
+
+   Shortcut: Press the first letter of the option you wish to set then
+             press <S> or <SPACE BAR>.
+
+o  To see available help for the item, use the cursor keys to highlight
+   <Help> and Press <ENTER>.
+
+   Shortcut: Press <H> or <?>.
+
+   Also, the <TAB> and cursor keys will cycle between <Select> and
+   <Help>
+
+
+Data Entry
+-----------
+o  Enter the requested information and press <ENTER>
+   If you are entering hexadecimal values, it is not necessary to
+   add the '0x' prefix to the entry.
+
+o  For help, use the <TAB> or cursor keys to highlight the help option
+   and press <ENTER>.  You can try <TAB><H> as well.
+
+
+Text Box    (Help Window)
+--------
+o  Use the cursor keys to scroll up/down/left/right.  The VI editor
+   keys h,j,k,l function here as do <SPACE BAR> and <B> for those
+   who are familiar with less and lynx.
+
+o  Press <E>, <X>, <Enter> or <Esc><Esc> to exit.
+
+
+Alternate Configuration Files
+-----------------------------
+Menuconfig supports the use of alternate configuration files for
+those who, for various reasons, find it necessary to switch
+between different kernel configurations.
+
+At the end of the main menu you will find two options.  One is
+for saving the current configuration to a file of your choosing.
+The other option is for loading a previously saved alternate
+configuration.
+
+Even if you don't use alternate configuration files, but you
+find during a Menuconfig session that you have completely messed
+up your settings, you may use the "Load Alternate..." option to
+restore your previously saved settings from ".config" without
+restarting Menuconfig.
+
+Other information
+-----------------
+If you use Menuconfig in an XTERM window make sure you have your
+$TERM variable set to point to a xterm definition which supports color.
+Otherwise, Menuconfig will look rather bad.  Menuconfig will not
+display correctly in a RXVT window because rxvt displays only one
+intensity of color, bright.
+
+Menuconfig will display larger menus on screens or xterms which are
+set to display more than the standard 25 row by 80 column geometry.
+In order for this to work, the "stty size" command must be able to
+display the screen's current row and column geometry.  I STRONGLY
+RECOMMEND that you make sure you do NOT have the shell variables
+LINES and COLUMNS exported into your environment.  Some distributions
+export those variables via /etc/profile.  Some ncurses programs can
+become confused when those variables (LINES & COLUMNS) don't reflect
+the true screen size.
+
+Optional personality available
+------------------------------
+If you prefer to have all of the kernel options listed in a single
+menu, rather than the default multimenu hierarchy, run the menuconfig
+with MENUCONFIG_MODE environment variable set to single_menu. Example:
+
+make MENUCONFIG_MODE=single_menu menuconfig
+
+<Enter> will then unroll the appropriate category, or enfold it if it
+is already unrolled.
+
+Note that this mode can eventually be a little more CPU expensive
+(especially with a larger number of unrolled categories) than the
+default mode.
+
+Different color themes available
+--------------------------------
+It is possible to select different color themes using the variable
+MENUCONFIG_COLOR. To select a theme use:
+
+make MENUCONFIG_COLOR=<theme> menuconfig
+
+Available themes are
+ mono       => selects colors suitable for monochrome displays
+ blackbg    => selects a color scheme with black background
+ classic    => theme with blue background. The classic look
+ bluetitle  => a LCD friendly version of classic. (default)
+
+                     This feature depends on another which has been configured as a module.
+As a result, this feature will be built as a module.     Use the arrow keys to navigate this window or press the hotkey of the item you wish to select followed by the <SPACE BAR>. Press <?> for additional information about this option.              Please enter a decimal value. Fractions will not be accepted.  Use the <TAB> key to move from the input field to the buttons below it.                          Please enter a hexadecimal value. Use the <TAB> key to move from the input field to the buttons below it.                       Please enter a string value. Use the <TAB> key to move from the input field to the buttons below it.                            Enter the name of the configuration file you wish to load.  Accept the name shown to restore the configuration you last retrieved.  Leave blank to abort.       
+For various reasons, one may wish to keep several different kernel
+configurations available on a single machine.
+
+If you have saved a previous configuration in a file other than the
+kernel's default, entering the name of the file here will allow you
+to modify that configuration.
+
+If you are uncertain, then you have probably never used alternate
+configuration files.  You should therefor leave this blank to abort.
+                               Enter a filename to which this configuration should be saved as an alternate.  Leave blank to abort.                            
+For various reasons, one may wish to keep different kernel
+configurations available on a single machine.
+
+Entering a file name here will allow you to later retrieve, modify
+and use the current configuration as an alternate to whatever
+configuration options you have selected at that time.
+
+If you are uncertain what all this means then you should probably
+leave this blank.
+         
+Search for CONFIG_ symbols and display their relations.
+Regular expressions are allowed.
+Example: search for "^FOO"
+Result:
+-----------------------------------------------------------------
+Symbol: FOO [=m]
+Prompt: Foo bus is used to drive the bar HW
+Defined at drivers/pci/Kconfig:47
+Depends on: X86_LOCAL_APIC && X86_IO_APIC || IA64
+Location:
+  -> Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+    -> PCI support (PCI [=y])
+      -> PCI access mode (<choice> [=y])
+Selects: LIBCRC32
+Selected by: BAR
+-----------------------------------------------------------------
+o The line 'Prompt:' shows the text used in the menu structure for
+  this CONFIG_ symbol
+o The 'Defined at' line tell at what file / line number the symbol
+  is defined
+o The 'Depends on:' line tell what symbols needs to be defined for
+  this symbol to be visible in the menu (selectable)
+o The 'Location:' lines tell where in the menu structure this symbol
+  is located
+    A location followed by a [=y] indicate that this is a selectable
+    menu item - and current value is displayed inside brackets.
+o The 'Selects:' line tell what symbol will be automatically
+  selected if this symbol is selected (y or m)
+o The 'Selected by' line tell what symbol has selected this symbol
+
+Only relevant lines are shown.
+
+
+Search examples:
+Examples: USB	=> find all CONFIG_ symbols containing USB
+          ^USB => find all CONFIG_ symbols starting with USB
+          USB$ => find all CONFIG_ symbols ending with USB
+
+ M*M*<none> ??? m y unknown %s:%d:warning:  %s:%d:  <token> %s:%d: location of the '%s'
+ <choice> KCONFIG_AUTOCONFIG include/config/auto.conf KCONFIG_CONFIG .config leading whitespace ignored prompt redefined Oops! How to check %d?
+  -> %s how to free type %d?
+ 0x%x expr_calc_value: %d?
+ !=  ||   &&   ^  [ <unknown type %d> UNAME_RELEASE can't copy type %d
+ choice must have a prompt range is invalid srctree %s/%s .kconfig.d w ..config.tmp deps_config := \
+ 	%s \
+ 	%s
+ 
+%s: \
+	$(deps_config)
+
+ ifneq "$(%s)" "%s"
+ %s: FORCE
+ 
+$(deps_config): ;
+ / KCONFIG_OVERWRITECONFIG %s.tmpconfig.%d KCONFIG_NOTIMESTAMP #  
+#
+# %s
+#
+ # CONFIG_%s is not set
+ CONFIG_%s=m
+ CONFIG_%s=y
+ CONFIG_%s=" \%c CONFIG_%s=%s
+ is not set unexpected data invalid string found include/config/auto.conf.cmd include/config ../.. .tmpconfig .tmpconfig.h #define CONFIG_%s_MODULE 1
+ #define CONFIG_%s 1
+ #define CONFIG_%s " #define CONFIG_%s 0x%s
+ #define CONFIG_%s %s
+ KCONFIG_AUTOHEADER include/linux/autoconf.h Symbol: %s [=%s]
+ Prompt: %s
+   Defined at %s:%d
+   Location:
+ %*c-> %s  (%s [=%s])   Selects:    Selected by:    Depends on:  CONFIG_%s:
+
+  [=%s] can't find file %s
+ %s:%d: can't open file "%s"
+          flex scanner jammed input in flex scanner failed unexpected end statement unknown statement "%s" unexpected option "%s" invalid statement unknown option "%s" invalid option %s:%d:config %s
+ %s:%d:endconfig
+ %s:%d:menuconfig %s
+ %s:%d:type(%u)
+ %s:%d:prompt
+ %s:%d:default(%u)
+ %s:%d:select
+ %s:%d:range
+ %s:%d:choice
+ %s:%d:endchoice
+ %s:%d:optional
+ %s:%d:default
+ %s:%d:if
+ %s:%d:endif
+ %s:%d:menu
+ %s:%d:endmenu
+ %s:%d:source %s
+ %s:%d:comment
+ %s:%d:help
+ %s:%d:depends on
+ Error: discarding Error: popping Cleanup: discarding lookahead Cleanup: popping Linux Kernel Configuration MODULES %.*s \"   boolean
+   tristate
+   string
+   integer
+   hex
+   ???
+   prompt    default    #choice value
+   unknown prop %d!
+   help
+%s
+ 
+comment  
+menu  
+endmenu
+  if    depends  endmenu endchoice endif depends boolean tristate integer hex string comment default select range env                 hhX88  !xXX!@xH   P(x` (H8                             H8          BBBBBBBBBBhBBBBBBBBBBBBBBBBBBBBBBBBBBBBBh9H @ \(\b++
+8.ss,P@i,..x,f.~-/x,u.l/v/2222//1x,,/x,*0x,12!2280W0300112...,-,-CCTCCCv;v;v;v;v;v;v;v;v;v;v;v;v;CCdD>C>v;v;v;v;v;v;v;GT>EE.@v;v;@=>?=?v;v;v;v;v;v;v;T>ASAaFv;v;=Av;v;v;v;v;B=yBv;v;v;v;v;D!Ev;B/Gv;v;v;v;?Gv;Fv;v;H>G#Gv;v;=>lCC CH>@F?A@=JLL|LWL2Larch/$ARCH/defconfig    There is no help available for this kernel option.
+                                                                                                                                      	   
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ! " # # $ % &            ! " # # $ % &   ' ( )   * * + * * * * * * * * * * * * *    ,  - - - - - - - - - - - - - - -  . /  0 0 0 0 0 0 0 0 0 0 0 0 0 0  1 1 2 1 1 1 1 1 1 1 1 1 1    3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3    5   6 6 6 6 6 6 6 6 6 6 6 6 6 6 6  7    8 9 9  9 9 9   :  ;  ' ( )   * * + * * * * * * * * * * * * *  * * + * * * * * * * * * * * * *   ,  - - - - - - - - - - - - - - -  . /  0 0 0 0 0 0 0 0 0 0 0 0 0 0   1 1 2 1 1 1 1 1 1 1 1 1 1   4    6 6 6 6 6 6 6 6 6 6 6 6 6 6 6   < 9 9  9 9 9    9 9 9                             "                                              	    
+        11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111  111 1  
+ 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111  	 !  ( & G M 9 = ? L W e     ' h A       D  H H   N  H           H              q                           	
+ !"                                   : ;  V W      	 
+   a         !  S T "  C   F  H    _       	 
+                         	 
+             ] C   F  H          l           	 
+              E  G            	 
+                  	 
+                 	 
+             D E  G E  G       	 
+           D E  G                           !         C m < (                         . /  1 Q R 5      	 
+    +    V 8 9 , - : W 0   ;  p 2  }  } Z  [ 6 \ ] ^ _ ` a b 4 c 7 Z  > d ? [ @ \ k l m n  I  s c K ~ L ~ o  8 9 S T    Z M [ N \ ] ^ _ ` a b x c  O  d     	 
+    S T             
+     P   X Z  Y  \ t w c  z Z  |   \     v {   c     | I S T S T   S T     T           B r  U             H                                m        4>CTKT[\  ] n ^   kl   d_          `GO0P h  @  	
+    Y   , %$ ! #"  Y 89576?32DFBEAVWULNJMIagijfeR b bbb   S<b b   &Z  b.+ ; Xc'()  -:=*/                                           #$%%%%%%%%%&&&&&&&''''''(()*+,-------...../001123456666667777889:;<<<<=>?@AAAABCDEFGGGGHIIJJKKKLLMMNNNNNNNOOPP                 z  ; }       E         e     A f g      u ! C q D " y # E $ %  & G ' ( ) h i F j   * J  < = 3      $% 	
+&')*+,2359;=>@BCDKJJJPJ"NO--68<GAGLNN L!(./EFH(7FH'4K'5:@K(H'5?@KNNOOJIJNO0JINMMMMOMMNM!1J            555555                    |%s:%d: missing end statement for this entry
+    unexpected '%s' within %s block '%s' in different file than '%s'    type of '%s' redefined from '%s' to '%s'    %s:%d:error: found recursive dependency: %s boolean symbol %s tested for 'm'? test forced to 'n'
+   boolean symbol %s tested for 'm'? test forced to 'y'
+   trying to redefine defconfig symbol redefining environment symbol from %s   environment variable %s undefined   choice value must have a prompt defaults for choice values not supported    choice value used outside its choice group  config symbol defined without type  default for config symbol '%' must be a single symbol   config symbol '%s' uses select, but is not boolean or tristate  '%s' has wrong type. 'select' only accept arguments of boolean and tristate type    range is only allowed for int or hex symbols    #
+# Automatically generated make config: don't edit
+# Linux kernel version: %s
+%s%s#
+   #
+# configuration written to %s
+#
+  #
+# using defaults found in %s
+#
+   override: reassigning to symbol %s  symbol value '%s' invalid for %s    %s creates inconsistent choice state    override: %s changes choice state   #
+# Automatically generated make config: don't edit
+# Linux kernel version: %s
+# %s#
+   /*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: %s
+ * %s */
+#define AUTOCONF_INCLUDED
+  out of dynamic memory in zconfensure_buffer_stack() out of dynamic memory in zconf_scan_buffer()    out of dynamic memory in zconf_scan_bytes() bad buffer in zconf_scan_bytes()    out of dynamic memory in zconf_create_buffer()  %s:%d: do not source '%s' from itself
+  %s:%d: file '%s' is already sourced from '%s'
+  flex scanner push-back overflow %s:%d:warning: multi-line strings not supported
+    fatal flex scanner internal error--end of buffer missed fatal error - scanner input buffer overflow out of dynamic memory in yy_get_next_buffer()   fatal flex scanner internal error--no action found  warning: menuconfig statement without prompt    warning: ignoring unknown option %s (-) (+) (%c) Select  Help  <[( >]) < MENUCONFIG_COLOR classic bluetitle blackbg mono   Ok   (%3d%%)  Exit   Yes    No   YyNnMmHh ynmh                            ?        |   lo   d   
+   h                  L              ,      @         oo   o                                                    p        2BRbr"2BRbr"2BRbr"2BRbr"2BRbr"2BRbr                                                                                                                                                                                                                                                                                                                                                                                                                                on env endif option endmenu optional endchoice range choice default def_bool help bool config def_tristate boolean defconfig_list string if int select modules tristate menu source comment hex menuconfig prompt depends mainmenu                                                                                                                                            %            /            5            <            D           M            R           W   	         ^           k           s                                                                                                                                                                                                 
+                                                                                                                                                                     GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll  (               D   o     `                N           p              V         dd  h                 ^   o                     k   o     P                z   	        @                   	      ,,                           0                                                                                 ||)                            ) X                           XX                            \\                            dd                            ll                            pp                          HH                           LL l                                                      dL                        0        8                                                                h               	              x                                                (          H          l                              d                         	          
+     ,                                        |                    X          \          d          l          p          H          L                                                       \         d      (   l      5         K         Z        h   @                  t   `         X         l         P                     p                -       00       -       -       -                   )  -     :  `B     G  ~     Q  0    V      h  @    t   |       @e              x            @       `e       j            "       9           E  O     U  O     i  O     t  (O       $O       0O       `O       \O                      O        O       hO       Pd       e       0u            "  `4     -       G  i     T  PO     `  LO     n  TO     |   n       @O       <O       8O       HO       DO       O                     k       ,O       O     !  O     )   F     9      M  5     `  @W     r   $        1       =       dO       0                  @D              t     #       3        D      R       d   >     s   ?      XO       @4       %(       @%-                   z        h      "                    o       `o       \       @\            !       (  I     <           H  N    U  pP    `  lO     k  pO     s  tO     z   R                  ^g      a       o\       xO                z  x                         W       W        W       W              O    $  `     /  W     7       F        W  W     c           z       k           u  p[     H              W     s  W     z  P      L       \        \        p                                                                  .  W,     7             J  =     R  '     a  `     k  b
+       eg                           +       3                                 d       `H                  	      	       '	  q     5	       <	        C	  W     M	             T	  W     ^	             e	             k	  P     {	  p     	       	  q    	  d     	             	  p+     	        	  @'     	             	  ]     
+               
+              4
+   H     A
+  (z     R
+       Y
+             l
+       
+        
+  d     
+  t     
+             
+  i     
+             
+             
+               |                      `!     4      B  )     J             R  0!     k             t  W     ~  c                           +                                       r       M                  4  6     B   _    V  =     g  |     q  @\    u  p]                                                     0                   @H?      P6                   *             2             9             I  `d-     P  (     ]   ^     f       u               T                                 W                    0                                 (  '     :             @      K   X    W  T     f  
+     u               @                                        p      6                          P       c     +  n     >             G  k    Y             c  c     m  `s     }  0                           2                    e=       '                          @       @z     %  W     9  p     F  @     Q  5     f       l       y               k                                             h       Z                    o5                               $  yB
+    4             <  `
+     H  `*q    W             c       w                         f                    0p       '             9    
+                     &        3  p}    H             Y             k             q   )                                             b                                                 )!              0    *       7             I   5    W  c     n  @]       P                                  0f              W              0#                           \     $             -  @     ;  \     F       W  e     a  pm    p  cx     y  d       pH       P
+       )       ^                                 \       L       +                 -  p
+     :             L  $s     [  P,     l  '     {         )       p&              g              r      \                   	               p     /       =   )     F      S             c       k  H     u  P
+       P       @+                                                           R      g      \       0K    *  P_     5             ;   o     U  0J|    _       f             z   ,                                              =       \                                 `u      \       *       0       J     4      C      M  6     b  0     s  0               p      `+               E        \       b       ^       @)l       j        c        H      crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux mconf.c set_config_filename menu_backtitle.5438 filename build_conf child_count indent current_menu CSWTCH.79 CSWTCH.77 single_menu_mode show_textbox show_help conf menu_instructions search_help setmod_text save_config_text load_config_text save_config_help load_config_help inputbox_instructions_int inputbox_instructions_string inputbox_instructions_hex mconf_readme radiolist_instructions zconf.tab.c yy_buffer_stack yy_buffer_stack_top yy_c_buf_p yy_n_chars yy_hold_char current_pos conf_changed_callback sym_change_count CSWTCH.541 CSWTCH.543 current_entry last_entry_ptr yydestruct prop_warn zconf_error zconf_endtoken CSWTCH.539 kconf_id_strings_contents conf_warning conf_lineno conf_filename conf_warnings zconfprint text_asize text_size text first_ts last_ts yy_start menu_check_dep sym_check_expr_deps sym_check_sym_deps yy_did_buffer_switch_on_eof yy_buffer_stack_max yy_init sym_add_default sym_calc_visibility sym_get_range_prop sym_get_range_val expr_print_gstr_helper expr_print_file_helper inited.8594 trans_count __expr_eliminate_eq expr_eliminate_dups2 expr_eliminate_dups1 alloc_string append_string zconf_init_buffer kconf_id_lookup asso_values.3554 wordlist.3615 conf_expand_value res_value.6403 fullname.6433 conf_unsaved nohelp_text yy_fatal_error zconfensure_buffer_stack yy_ec yy_nxt yy_accept yypact yytranslate yycheck yydefact yyr2 yyr1 yypgoto yydefgoto yytable yystos print_quoted_string checklist.c print_arrows print_item list_width check_x item_x print_buttons util.c set_classic_theme set_bluetitle_theme init_one_color pair.5174 inputbox.c textbox.c back_lines begin_reached buf page end_reached get_line line.5231 print_line hscroll print_position refresh_text_box page_length yesno.c menubox.c do_scroll do_print_item menu_width _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC fileno@@GLIBC_2.0 scrollok data_start fputs@@GLIBC_2.0 __errno_location@@GLIBC_2.0 rootmenu sprintf@@GLIBC_2.0 zconfin expr_alloc_one expr_copy set_dialog_backtitle item_make open@@GLIBC_2.0 cdebug expr_fprint menu_add_symbol getpid@@GLIBC_2.0 mkdir@@GLIBC_2.0 item_str symbol_mod regfree@@GLIBC_2.0 expr_calc_value __libc_csu_fini on_key_resize stdscr _start zconfchar newwin file_list waddch wmove menu_is_visible menu_end_entry zconfget_in init_dialog item_is_tag keypad menu_add_prompt sym_type_name zconf_switch_to_buffer __xstat@@GLIBC_2.0 expr_extract_eq_and __gmon_start__ _Jv_RegisterClasses symbol_empty zconf_scan_bytes _fp_hw realloc@@GLIBC_2.0 zconfpop_buffer_state menu_has_help item_is_selected conf_get_default_confname endwin draw_shadow strchr@@GLIBC_2.0 vsnprintf@@GLIBC_2.0 getenv@@GLIBC_2.0 _fini strncpy@@GLIBC_2.0 conf_get_configname sym_re_search str_new nodelay conf_get_autoconfig_name doupdate zconfleng item_tag expr_contains_symbol fgets@@GLIBC_2.0 sym_set_changed rename@@GLIBC_2.0 regexec@@GLIBC_2.3.4 sym_check_deps expr_eliminate_dups zconf_starthelp __libc_start_main@@GLIBC_2.0 expr_alloc_or dialog_input_result zconf_flex_debug expr_free dlg expr_extract_eq_or strrchr@@GLIBC_2.0 uname@@GLIBC_2.0 zconfalloc delwin conf_set_all_new_symbols bindtextdomain@@GLIBC_2.0 conf_parse expr_alloc_and zconfget_debug prop_get_symbol initscr subwin read@@GLIBC_2.0 item_n conf_defname item_nil _IO_stdin_used wclrtoeol sym_set_all_changed strtol@@GLIBC_2.0 __ctype_toupper_loc@@GLIBC_2.3 zconflval free@@GLIBC_2.0 menu_get_help sym_tristate_within_range dcgettext@@GLIBC_2.0 __data_start expr_alloc_symbol winch conf_write symbol_hash menu_add_entry zconfset_debug regcomp@@GLIBC_2.0 conf_get_changed __ctype_b_loc@@GLIBC_2.3 wtouchln menu_get_prompt menu_add_option sym_set_change_count fclose@@GLIBC_2.1 dialog_textbox expr_transform item_count zconf_flush_buffer wrefresh expr_eliminate_yn init_pair item_data expr_trans_bool zconffree stderr@@GLIBC_2.0 memcpy@@GLIBC_2.0 sym_get_type strlen@@GLIBC_2.0 item_reset expr_alloc_comp fopen@@GLIBC_2.1 conf_read_simple expr_eliminate_eq zconf_fopen sym_clear_all_valid dialog_clear str_append sym_get_default_prop LINES __dso_handle setlocale@@GLIBC_2.0 print_button clearerr@@GLIBC_2.0 strcpy@@GLIBC_2.0 cbreak __DTOR_END__ __libc_csu_init printf@@GLIBC_2.0 end_dialog chdir@@GLIBC_2.0 ctime@@GLIBC_2.0 dialog_inputbox ungetch zconfset_in zconf_nextfile start_color expr_depends_symbol menu_get_root_menu zconfget_lineno menu_set_type first_alpha strcasecmp@@GLIBC_2.0 attr_clear zconf_scan_buffer sym_string_within_range zconfparse sym_add_change_count wgetch zconfget_out sym_set_string_value close@@GLIBC_2.0 fwrite@@GLIBC_2.0 flash get_symbol_str fprintf@@GLIBC_2.0 wprintw time@@GLIBC_2.0 item_set_tag menu_add_menu sym_lookup str_get strncat@@GLIBC_2.0 sym_is_changable zconf_scan_string __bss_start sym_calc_value zconfrealloc malloc@@GLIBC_2.0 menu_finalize item_activate_selected zconf_delete_buffer menu_init has_colors sym_string_valid menu_end_menu on_key_esc menu_add_prop sym_init sym_set_tristate_value menu_get_ext_help COLS fputc@@GLIBC_2.0 current_file waddnstr zconfget_text zconfnerrs stdin@@GLIBC_2.0 menu_warn print_autowrap item_set item_add_str expr_compare_type zconfset_lineno menu_get_parent_menu item_cur strncasecmp@@GLIBC_2.0 memmove@@GLIBC_2.0 zconftext str_printf zconflex __ctype_tolower_loc@@GLIBC_2.3 zconfset_out strcat@@GLIBC_2.0 zconf_initscan sym_get_env_prop expr_alloc_two zconf_lineno zconfrestart zconfpush_buffer_state zconflineno _end stdout@@GLIBC_2.0 expr_print sym_defconfig_list acs_map conf_write_autoconf textdomain@@GLIBC_2.0 expr_extract_eq zconf_curname str_free dialog_yesno rand@@GLIBC_2.0 expr_eq symbol_no conf_set_changed_callback file_lookup menu_add_expr strncmp@@GLIBC_2.0 wnoutrefresh vfprintf@@GLIBC_2.0 _IO_putc@@GLIBC_2.0 dialog_checklist draw_box modules_val expr_trans_compare prop_alloc wscrl sym_toggle_tristate_value zconfdump _edata snprintf@@GLIBC_2.0 sym_get_choice_prop noecho strcmp@@GLIBC_2.0 wbkgdset zconfout sym_env_list __strdup@@GLIBC_2.0 exit@@GLIBC_2.0 dialog_menu current_buf menu_add_dep zconfget_leng __i686.get_pc_thunk.bx file_write_dep conf_read sym_get_string_value zconflex_destroy prop_get_type_name sym_find main expr_gstr_print _init str_assign modules_sym item_set_data item_head zconf_create_buffer print_title item_set_selected symbol_yes 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/scripts/kconfig/zconf.hash.c /usr/src/linux/scripts/kconfig/zconf.hash.c
--- /home/jara/linux-2.6.32/scripts/kconfig/zconf.hash.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/kconfig/zconf.hash.c	2012-08-04 07:02:11.000000000 -0300
@@ -0,0 +1,239 @@
+/* ANSI-C code produced by gperf version 3.0.3 */
+/* Command-line: gperf  */
+/* Computed positions: -k'1,3' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+struct kconf_id;
+
+static struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+/* maximum key range = 47, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static unsigned char asso_values[] =
+    {
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 11,  5,
+       0,  0,  5, 49,  5, 20, 49, 49,  5, 20,
+       5,  0, 30, 49,  0, 15,  0, 10,  0, 49,
+      25, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval;
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("on")];
+    char kconf_id_strings_str3[sizeof("env")];
+    char kconf_id_strings_str5[sizeof("endif")];
+    char kconf_id_strings_str6[sizeof("option")];
+    char kconf_id_strings_str7[sizeof("endmenu")];
+    char kconf_id_strings_str8[sizeof("optional")];
+    char kconf_id_strings_str9[sizeof("endchoice")];
+    char kconf_id_strings_str10[sizeof("range")];
+    char kconf_id_strings_str11[sizeof("choice")];
+    char kconf_id_strings_str12[sizeof("default")];
+    char kconf_id_strings_str13[sizeof("def_bool")];
+    char kconf_id_strings_str14[sizeof("help")];
+    char kconf_id_strings_str15[sizeof("bool")];
+    char kconf_id_strings_str16[sizeof("config")];
+    char kconf_id_strings_str17[sizeof("def_tristate")];
+    char kconf_id_strings_str18[sizeof("boolean")];
+    char kconf_id_strings_str19[sizeof("defconfig_list")];
+    char kconf_id_strings_str21[sizeof("string")];
+    char kconf_id_strings_str22[sizeof("if")];
+    char kconf_id_strings_str23[sizeof("int")];
+    char kconf_id_strings_str26[sizeof("select")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str28[sizeof("tristate")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str31[sizeof("source")];
+    char kconf_id_strings_str32[sizeof("comment")];
+    char kconf_id_strings_str33[sizeof("hex")];
+    char kconf_id_strings_str35[sizeof("menuconfig")];
+    char kconf_id_strings_str36[sizeof("prompt")];
+    char kconf_id_strings_str37[sizeof("depends")];
+    char kconf_id_strings_str48[sizeof("mainmenu")];
+  };
+static struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "on",
+    "env",
+    "endif",
+    "option",
+    "endmenu",
+    "optional",
+    "endchoice",
+    "range",
+    "choice",
+    "default",
+    "def_bool",
+    "help",
+    "bool",
+    "config",
+    "def_tristate",
+    "boolean",
+    "defconfig_list",
+    "string",
+    "if",
+    "int",
+    "select",
+    "modules",
+    "tristate",
+    "menu",
+    "source",
+    "comment",
+    "hex",
+    "menuconfig",
+    "prompt",
+    "depends",
+    "mainmenu"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#ifdef __GNUC_STDC_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 31,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 48
+    };
+
+  static struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_ON,		TF_PARAM},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_OPT_ENV,	TF_OPTION},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str6,		T_OPTION,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_ENDMENU,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_OPTIONAL,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str10,		T_RANGE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str11,		T_CHOICE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,		T_HELP,		TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str15,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str16,		T_CONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str19,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_TYPE,		TF_COMMAND, S_STRING},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,		T_IF,		TF_COMMAND|TF_PARAM},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,		T_TYPE,		TF_COMMAND, S_INT},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str26,		T_SELECT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str28,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_SOURCE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,		T_TYPE,		TF_COMMAND, S_HEX},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,	T_MENUCONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_PROMPT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str37,	T_DEPENDS,	TF_COMMAND},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str48,	T_MAINMENU,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+
diff -Naur /home/jara/linux-2.6.32/scripts/kconfig/zconf.tab.c /usr/src/linux/scripts/kconfig/zconf.tab.c
--- /home/jara/linux-2.6.32/scripts/kconfig/zconf.tab.c	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/kconfig/zconf.tab.c	2012-08-04 07:02:11.000000000 -0300
@@ -0,0 +1,2455 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         zconfparse
+#define yylex           zconflex
+#define yyerror         zconferror
+#define yylval          zconflval
+#define yychar          zconfchar
+#define yydebug         zconfdebug
+#define yynerrs         zconfnerrs
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[257];
+
+static struct menu *current_menu, *current_entry;
+
+#define YYDEBUG 0
+#if YYDEBUG
+#define YYERROR_VERBOSE
+#endif
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_TYPE = 274,
+     T_DEFAULT = 275,
+     T_SELECT = 276,
+     T_RANGE = 277,
+     T_OPTION = 278,
+     T_ON = 279,
+     T_WORD = 280,
+     T_WORD_QUOTE = 281,
+     T_UNEQUAL = 282,
+     T_CLOSE_PAREN = 283,
+     T_OPEN_PAREN = 284,
+     T_EOL = 285,
+     T_OR = 286,
+     T_AND = 287,
+     T_EQUAL = 288,
+     T_NOT = 289
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	struct kconf_id *id;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Include zconf.hash.c here so it can see the token constants. */
+#include "zconf.hash.c"
+
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  3
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   259
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  35
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  46
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  110
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  180
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   289
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     5,     6,     9,    12,    15,    20,    23,
+      28,    33,    37,    39,    41,    43,    45,    47,    49,    51,
+      53,    55,    57,    59,    61,    63,    67,    70,    74,    77,
+      81,    84,    85,    88,    91,    94,    97,   100,   103,   107,
+     112,   117,   122,   128,   132,   133,   137,   138,   141,   145,
+     148,   150,   154,   155,   158,   161,   164,   167,   170,   175,
+     179,   182,   187,   188,   191,   195,   197,   201,   202,   205,
+     208,   211,   215,   218,   220,   224,   225,   228,   231,   234,
+     238,   242,   245,   248,   251,   252,   255,   258,   261,   266,
+     267,   270,   272,   274,   277,   280,   283,   285,   288,   289,
+     292,   294,   298,   302,   306,   309,   313,   317,   319,   321,
+     322
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      36,     0,    -1,    37,    -1,    -1,    37,    39,    -1,    37,
+      53,    -1,    37,    64,    -1,    37,     3,    74,    76,    -1,
+      37,    75,    -1,    37,    25,     1,    30,    -1,    37,    38,
+       1,    30,    -1,    37,     1,    30,    -1,    16,    -1,    18,
+      -1,    19,    -1,    21,    -1,    17,    -1,    22,    -1,    20,
+      -1,    30,    -1,    59,    -1,    68,    -1,    42,    -1,    44,
+      -1,    66,    -1,    25,     1,    30,    -1,     1,    30,    -1,
+      10,    25,    30,    -1,    41,    45,    -1,    11,    25,    30,
+      -1,    43,    45,    -1,    -1,    45,    46,    -1,    45,    47,
+      -1,    45,    72,    -1,    45,    70,    -1,    45,    40,    -1,
+      45,    30,    -1,    19,    73,    30,    -1,    18,    74,    77,
+      30,    -1,    20,    78,    77,    30,    -1,    21,    25,    77,
+      30,    -1,    22,    79,    79,    77,    30,    -1,    23,    48,
+      30,    -1,    -1,    48,    25,    49,    -1,    -1,    33,    74,
+      -1,     7,    80,    30,    -1,    50,    54,    -1,    75,    -1,
+      51,    56,    52,    -1,    -1,    54,    55,    -1,    54,    72,
+      -1,    54,    70,    -1,    54,    30,    -1,    54,    40,    -1,
+      18,    74,    77,    30,    -1,    19,    73,    30,    -1,    17,
+      30,    -1,    20,    25,    77,    30,    -1,    -1,    56,    39,
+      -1,    14,    78,    76,    -1,    75,    -1,    57,    60,    58,
+      -1,    -1,    60,    39,    -1,    60,    64,    -1,    60,    53,
+      -1,     4,    74,    30,    -1,    61,    71,    -1,    75,    -1,
+      62,    65,    63,    -1,    -1,    65,    39,    -1,    65,    64,
+      -1,    65,    53,    -1,     6,    74,    30,    -1,     9,    74,
+      30,    -1,    67,    71,    -1,    12,    30,    -1,    69,    13,
+      -1,    -1,    71,    72,    -1,    71,    30,    -1,    71,    40,
+      -1,    16,    24,    78,    30,    -1,    -1,    74,    77,    -1,
+      25,    -1,    26,    -1,     5,    30,    -1,     8,    30,    -1,
+      15,    30,    -1,    30,    -1,    76,    30,    -1,    -1,    14,
+      78,    -1,    79,    -1,    79,    33,    79,    -1,    79,    27,
+      79,    -1,    29,    78,    28,    -1,    34,    78,    -1,    78,
+      31,    78,    -1,    78,    32,    78,    -1,    25,    -1,    26,
+      -1,    -1,    25,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   107,   107,   109,   111,   112,   113,   114,   115,   116,
+     117,   121,   125,   125,   125,   125,   125,   125,   125,   129,
+     130,   131,   132,   133,   134,   138,   139,   145,   153,   159,
+     167,   177,   179,   180,   181,   182,   183,   184,   187,   195,
+     201,   211,   217,   223,   226,   228,   239,   240,   245,   254,
+     259,   267,   270,   272,   273,   274,   275,   276,   279,   285,
+     296,   302,   312,   314,   319,   327,   335,   338,   340,   341,
+     342,   347,   354,   359,   367,   370,   372,   373,   374,   377,
+     385,   392,   399,   405,   412,   414,   415,   416,   419,   427,
+     429,   434,   435,   438,   439,   440,   444,   445,   448,   449,
+     452,   453,   454,   455,   456,   457,   458,   461,   462,   465,
+     466
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT", "T_SELECT", "T_RANGE",
+  "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL",
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND", "T_EQUAL",
+  "T_NOT", "$accept", "input", "stmt_list", "option_name", "common_stmt",
+  "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "menu", "menu_entry",
+  "menu_end", "menu_stmt", "menu_block", "source_stmt", "comment",
+  "comment_stmt", "help_start", "help", "depends_list", "depends",
+  "prompt_stmt_opt", "prompt", "end", "nl", "if_expr", "expr", "symbol",
+  "word_opt", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    35,    36,    37,    37,    37,    37,    37,    37,    37,
+      37,    37,    38,    38,    38,    38,    38,    38,    38,    39,
+      39,    39,    39,    39,    39,    40,    40,    41,    42,    43,
+      44,    45,    45,    45,    45,    45,    45,    45,    46,    46,
+      46,    46,    46,    47,    48,    48,    49,    49,    50,    51,
+      52,    53,    54,    54,    54,    54,    54,    54,    55,    55,
+      55,    55,    56,    56,    57,    58,    59,    60,    60,    60,
+      60,    61,    62,    63,    64,    65,    65,    65,    65,    66,
+      67,    68,    69,    70,    71,    71,    71,    71,    72,    73,
+      73,    74,    74,    75,    75,    75,    76,    76,    77,    77,
+      78,    78,    78,    78,    78,    78,    78,    79,    79,    80,
+      80
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     0,     2,     2,     2,     4,     2,     4,
+       4,     3,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     3,     2,     3,     2,     3,
+       2,     0,     2,     2,     2,     2,     2,     2,     3,     4,
+       4,     4,     5,     3,     0,     3,     0,     2,     3,     2,
+       1,     3,     0,     2,     2,     2,     2,     2,     4,     3,
+       2,     4,     0,     2,     3,     1,     3,     0,     2,     2,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     3,
+       3,     2,     2,     2,     0,     2,     2,     2,     4,     0,
+       2,     1,     1,     2,     2,     2,     1,     2,     0,     2,
+       1,     3,     3,     3,     2,     3,     3,     1,     1,     0,
+       1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       3,     0,     0,     1,     0,     0,     0,     0,     0,   109,
+       0,     0,     0,     0,     0,     0,    12,    16,    13,    14,
+      18,    15,    17,     0,    19,     0,     4,    31,    22,    31,
+      23,    52,    62,     5,    67,    20,    84,    75,     6,    24,
+      84,    21,     8,    11,    91,    92,     0,     0,    93,     0,
+     110,     0,    94,     0,     0,     0,   107,   108,     0,     0,
+       0,   100,    95,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    96,     7,    71,    79,    48,    80,    27,
+      29,     0,   104,     0,     0,    64,     0,     0,     9,    10,
+       0,     0,     0,     0,    89,     0,     0,     0,    44,     0,
+      37,    36,    32,    33,     0,    35,    34,     0,     0,    89,
+       0,    56,    57,    53,    55,    54,    63,    51,    50,    68,
+      70,    66,    69,    65,    86,    87,    85,    76,    78,    74,
+      77,    73,    97,   103,   105,   106,   102,   101,    26,    82,
+       0,    98,     0,    98,    98,    98,     0,     0,     0,    83,
+      60,    98,     0,    98,     0,     0,     0,    38,    90,     0,
+       0,    98,    46,    43,    25,     0,    59,     0,    88,    99,
+      39,    40,    41,     0,     0,    45,    58,    61,    42,    47
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     1,     2,    25,    26,   101,    27,    28,    29,    30,
+      65,   102,   103,   147,   175,    31,    32,   117,    33,    67,
+     113,    68,    34,   121,    35,    69,    36,    37,   129,    38,
+      71,    39,    40,    41,   104,   105,    70,   106,   142,   143,
+      42,    74,   156,    60,    61,    51
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -80
+static const yytype_int16 yypact[] =
+{
+     -80,     2,   132,   -80,   -13,    -1,    -1,    -2,    -1,     9,
+      33,    -1,    27,    40,    -3,    38,   -80,   -80,   -80,   -80,
+     -80,   -80,   -80,    71,   -80,    77,   -80,   -80,   -80,   -80,
+     -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
+     -80,   -80,   -80,   -80,   -80,   -80,    57,    61,   -80,    63,
+     -80,    76,   -80,    87,   101,   133,   -80,   -80,    -3,    -3,
+     195,    -6,   -80,   136,   149,    39,   104,    65,   150,     5,
+     194,     5,   167,   -80,   176,   -80,   -80,   -80,   -80,   -80,
+     -80,    68,   -80,    -3,    -3,   176,    72,    72,   -80,   -80,
+     177,   187,    78,    -1,    -1,    -3,   196,    72,   -80,   222,
+     -80,   -80,   -80,   -80,   221,   -80,   -80,   205,    -1,    -1,
+     211,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
+     -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
+     -80,   -80,   -80,   -80,   206,   -80,   -80,   -80,   -80,   -80,
+      -3,   223,   209,   223,   197,   223,    72,     7,   210,   -80,
+     -80,   223,   212,   223,   201,    -3,   213,   -80,   -80,   214,
+     215,   223,   208,   -80,   -80,   216,   -80,   217,   -80,   113,
+     -80,   -80,   -80,   218,    -1,   -80,   -80,   -80,   -80,   -80
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -80,   -80,   -80,   -80,   122,   -34,   -80,   -80,   -80,   -80,
+     220,   -80,   -80,   -80,   -80,   -80,   -80,   -80,    59,   -80,
+     -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   125,
+     -80,   -80,   -80,   -80,   -80,   183,   219,    22,   142,    -5,
+     147,   192,    69,   -54,   -79,   -80
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -82
+static const yytype_int16 yytable[] =
+{
+      46,    47,     3,    49,    81,    82,    53,   136,   137,     6,
+       7,     8,     9,    10,    11,    12,    13,    43,   146,    14,
+      15,    86,    56,    57,    44,    45,    58,    87,    48,   134,
+     135,    59,   162,   112,    50,    24,   125,   163,   125,   -28,
+      90,   144,   -28,   -28,   -28,   -28,   -28,   -28,   -28,   -28,
+     -28,    91,    54,   -28,   -28,    92,   -28,    93,    94,    95,
+      96,    97,    98,    52,    99,    55,    90,   161,    62,   100,
+     -49,   -49,    63,   -49,   -49,   -49,   -49,    91,    64,   -49,
+     -49,    92,   107,   108,   109,   110,   154,    73,   141,   115,
+      99,    75,   126,    76,   126,   111,   133,    56,    57,    83,
+      84,   169,   140,   151,   -30,    90,    77,   -30,   -30,   -30,
+     -30,   -30,   -30,   -30,   -30,   -30,    91,    78,   -30,   -30,
+      92,   -30,    93,    94,    95,    96,    97,    98,   120,    99,
+     128,    79,    -2,     4,   100,     5,     6,     7,     8,     9,
+      10,    11,    12,    13,    83,    84,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,     7,     8,    23,    10,    11,
+      12,    13,    24,    80,    14,    15,    88,   -81,    90,   179,
+     -81,   -81,   -81,   -81,   -81,   -81,   -81,   -81,   -81,    89,
+      24,   -81,   -81,    92,   -81,   -81,   -81,   -81,   -81,   -81,
+     116,   119,    99,   127,   122,    90,   130,   124,   -72,   -72,
+     -72,   -72,   -72,   -72,   -72,   -72,   132,   138,   -72,   -72,
+      92,   155,   158,   159,   160,   118,   123,   139,   131,    99,
+     165,   145,   167,   148,   124,    73,    83,    84,    83,    84,
+     173,   168,    83,    84,   149,   150,   153,   155,    84,   157,
+     164,   174,   166,   170,   171,   172,   176,   177,   178,    66,
+     114,   152,    85,     0,     0,     0,     0,     0,     0,    72
+};
+
+static const yytype_int16 yycheck[] =
+{
+       5,     6,     0,     8,    58,    59,    11,    86,    87,     4,
+       5,     6,     7,     8,     9,    10,    11,    30,    97,    14,
+      15,    27,    25,    26,    25,    26,    29,    33,    30,    83,
+      84,    34,    25,    67,    25,    30,    70,    30,    72,     0,
+       1,    95,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    25,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,    30,    25,    25,     1,   146,    30,    30,
+       5,     6,     1,     8,     9,    10,    11,    12,     1,    14,
+      15,    16,    17,    18,    19,    20,   140,    30,    93,    67,
+      25,    30,    70,    30,    72,    30,    28,    25,    26,    31,
+      32,   155,    24,   108,     0,     1,    30,     3,     4,     5,
+       6,     7,     8,     9,    10,    11,    12,    30,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    69,    25,
+      71,    30,     0,     1,    30,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    31,    32,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,     5,     6,    25,     8,     9,
+      10,    11,    30,    30,    14,    15,    30,     0,     1,   174,
+       3,     4,     5,     6,     7,     8,     9,    10,    11,    30,
+      30,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      68,    69,    25,    71,    69,     1,    71,    30,     4,     5,
+       6,     7,     8,     9,    10,    11,    30,    30,    14,    15,
+      16,    14,   143,   144,   145,    68,    69,    30,    71,    25,
+     151,    25,   153,     1,    30,    30,    31,    32,    31,    32,
+     161,    30,    31,    32,    13,    30,    25,    14,    32,    30,
+      30,    33,    30,    30,    30,    30,    30,    30,    30,    29,
+      67,   109,    60,    -1,    -1,    -1,    -1,    -1,    -1,    40
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    36,    37,     0,     1,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    14,    15,    16,    17,    18,    19,
+      20,    21,    22,    25,    30,    38,    39,    41,    42,    43,
+      44,    50,    51,    53,    57,    59,    61,    62,    64,    66,
+      67,    68,    75,    30,    25,    26,    74,    74,    30,    74,
+      25,    80,    30,    74,    25,    25,    25,    26,    29,    34,
+      78,    79,    30,     1,     1,    45,    45,    54,    56,    60,
+      71,    65,    71,    30,    76,    30,    30,    30,    30,    30,
+      30,    78,    78,    31,    32,    76,    27,    33,    30,    30,
+       1,    12,    16,    18,    19,    20,    21,    22,    23,    25,
+      30,    40,    46,    47,    69,    70,    72,    17,    18,    19,
+      20,    30,    40,    55,    70,    72,    39,    52,    75,    39,
+      53,    58,    64,    75,    30,    40,    72,    39,    53,    63,
+      64,    75,    30,    28,    78,    78,    79,    79,    30,    30,
+      24,    74,    73,    74,    78,    25,    79,    48,     1,    13,
+      30,    74,    73,    25,    78,    14,    77,    30,    77,    77,
+      77,    79,    25,    30,    30,    77,    30,    77,    30,    78,
+      30,    30,    30,    77,    33,    49,    30,    30,    30,    74
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 51: /* "choice_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 57: /* "if_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 62: /* "menu_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 8:
+
+    { zconf_error("unexpected end statement"); ;}
+    break;
+
+  case 9:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); ;}
+    break;
+
+  case 10:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[(2) - (4)].id)->name);
+;}
+    break;
+
+  case 11:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 25:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[(1) - (3)].string)); ;}
+    break;
+
+  case 26:
+
+    { zconf_error("invalid option"); ;}
+    break;
+
+  case 27:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 28:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 29:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 30:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 38:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (3)].id)->stype);
+;}
+    break;
+
+  case 39:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 40:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+	if ((yyvsp[(1) - (4)].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[(1) - (4)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (4)].id)->stype);
+;}
+    break;
+
+  case 41:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 42:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[(2) - (3)].string));
+	free((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 46:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 47:
+
+    { (yyval.string) = (yyvsp[(2) - (2)].string); ;}
+    break;
+
+  case 48:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+	sym->flags |= SYMBOL_AUTO;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 49:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 50:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 58:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 59:
+
+    {
+	if ((yyvsp[(1) - (3)].id)->stype == S_BOOLEAN || (yyvsp[(1) - (3)].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[(1) - (3)].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[(1) - (3)].id)->stype);
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 60:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 61:
+
+    {
+	if ((yyvsp[(1) - (4)].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 64:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[(2) - (3)].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 65:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 71:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 72:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 73:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 79:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+	zconf_nextfile((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 80:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 81:
+
+    {
+	menu_end_entry();
+;}
+    break;
+
+  case 82:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 83:
+
+    {
+	current_entry->help = (yyvsp[(2) - (2)].string);
+;}
+    break;
+
+  case 88:
+
+    {
+	menu_add_dep((yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 90:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 93:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 94:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 95:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 98:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 99:
+
+    { (yyval.expr) = (yyvsp[(2) - (2)].expr); ;}
+    break;
+
+  case 100:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); ;}
+    break;
+
+  case 101:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 102:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 103:
+
+    { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
+    break;
+
+  case 104:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); ;}
+    break;
+
+  case 105:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 106:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 107:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 108:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 109:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+
+
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	menu_init();
+	modules_sym = sym_lookup(NULL, 0);
+	modules_sym->type = S_BOOLEAN;
+	modules_sym->flags |= SYMBOL_AUTO;
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+#if YYDEBUG
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+#endif
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym->prop) {
+		struct property *prop;
+
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+	}
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		if (sym_check_deps(sym))
+			zconfnerrs++;
+        }
+	if (zconfnerrs)
+		exit(1);
+	sym_set_change_count(1);
+}
+
+static const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+#if YYDEBUG
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+#endif
+}
+
+static void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+static void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "choice\n");
+	else
+		fprintf(out, "config %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (menu->help) {
+		int len = strlen(menu->help);
+		while (menu->help[--len] == '\n')
+			menu->help[len] = 0;
+		fprintf(out, "  help\n%s\n", menu->help);
+	}
+	fputc('\n', out);
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+			fputs("\n", out);
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
diff -Naur /home/jara/linux-2.6.32/scripts/mod/elfconfig.h /usr/src/linux/scripts/mod/elfconfig.h
--- /home/jara/linux-2.6.32/scripts/mod/elfconfig.h	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/mod/elfconfig.h	2014-06-14 14:24:10.000000000 -0300
@@ -0,0 +1,5 @@
+#define KERNEL_ELFCLASS ELFCLASS32
+#define KERNEL_ELFDATA ELFDATA2LSB
+#define HOST_ELFCLASS ELFCLASS32
+#define HOST_ELFDATA ELFDATA2LSB
+#define MODULE_SYMBOL_PREFIX ""
diff -Naur /home/jara/linux-2.6.32/scripts/mod/mk_elfconfig /usr/src/linux/scripts/mod/mk_elfconfig
--- /home/jara/linux-2.6.32/scripts/mod/mk_elfconfig	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/mod/mk_elfconfig	2014-06-14 14:24:10.000000000 -0300
@@ -0,0 +1,13 @@
+ELF               4   t      4    (      4   44                                      8	  8	           8	  88  $           L	  LL               (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU q;   
+   	                                                       ("           K8gUa                               M              @              .              G              )                      9   L     3   P      __gmon_start__ libc.so.6 _IO_stdin_used exit puts stdin stderr fwrite fread __libc_start_main GLIBC_2.0                            ii   _         L  P	  ,  0  4  8  <  @  US    [  t       X[5$%(    %,h    %0h   %4h   %8h   %<h    %@h(       1^PTRhhQVhUS=T u?XD@9s    X@X9rT[]t& '    UHt    t	$HUWV8}t%LD$   D$   $D$Pt$D$   D$   4$D$u0   uZD$"<=  <}   $   LD$   D$   $D$G   8^_]t& LD$   D$   $D$8   ^_]t& $ D$#<   <b$`$D$.   fD$.      $E   @t	   uJ$b81^_]v $HC&    $<0L&    $1t& $ gU]t& '    UWVSO   %  S)t$1ED$ED$E$9r[^_]$US8t8fu[]US    [  Y[     Error: no arch
+ Error: input truncated
+ ELF Error: not ELF
+   h8300 blackfin   #define KERNEL_ELFCLASS ELFCLASS32  #define KERNEL_ELFCLASS ELFCLASS64  #define KERNEL_ELFDATA ELFDATA2LSB  #define KERNEL_ELFDATA ELFDATA2MSB  #define HOST_ELFCLASS ELFCLASS32    #define HOST_ELFDATA ELFDATA2MSB    #define HOST_ELFDATA ELFDATA2LSB    #define MODULE_SYMBOL_PREFIX "_"    #define MODULE_SYMBOL_PREFIX ""                          \   |   lo   t   
+   i                       0            ,               oo   o                                                    L                GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll  <                D   o     ,                N                          V         tt  i                  ^   o                     k   o                      z   	                           	      ,,  0                        \\  0                             p                              |                          ||                                                         44	                             88	                             @@	                             HH	                             LL	                           
+                              
+  $                          DD
+                             LL
+                          0       L
+  8                               
+                                  $  `     -         	                X                                               (          H          l                              t                         	          
+     ,          \                               |                    4          8          @          H          L                               D          L                                   8         @      (   H      5   0      K   T     Z   X     h                     t   <         4         H         P                              8         8         L       D                       %              4              H       O  |      U             r         D        L       H       D       Z                    L       P       \                                 L     &             6  J     M      R  \       crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux mk_elfconfig.c _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC data_start __libc_csu_fini _start __gmon_start__ _Jv_RegisterClasses _fp_hw _fini __libc_start_main@@GLIBC_2.0 _IO_stdin_used __data_start stderr@@GLIBC_2.0 __dso_handle __DTOR_END__ __libc_csu_init fwrite@@GLIBC_2.0 __bss_start stdin@@GLIBC_2.0 _end puts@@GLIBC_2.0 fread@@GLIBC_2.0 _edata exit@@GLIBC_2.0 __i686.get_pc_thunk.bx main _init 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/scripts/mod/modpost /usr/src/linux/scripts/mod/modpost
--- /home/jara/linux-2.6.32/scripts/mod/modpost	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/mod/modpost	2014-06-14 14:24:11.000000000 -0300
@@ -0,0 +1,155 @@
+ELF              4   8      4    (      4   44                                      H  H                    #                              (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU syZBgi0^%   5   '   2           *                  1                  +   %      )          (          "       .   $   	       /   !      #             4                                                                                             3             
+   0                                              &             ,          -             0          ."    0   3   K8]|2                $                                         B              ~              h             ?                            v              8                                                       n              ,                           q             V              g              E                                                                                                A                            )                            +                                                                    Y             0                           G                                                      2                           a             ^              <                 d       $#        I     O    #       @#      __gmon_start__ libc.so.6 _IO_stdin_used strcpy __rawmemchr exit fopen strncmp optind strrchr __strdup perror strncpy realloc mmap calloc strlen memset warn strstr __errno_location getopt vsnprintf fputc lseek fclose strtoul malloc asprintf __ctype_b_loc getenv optarg stderr munmap __fxstat fileno fwrite fread strchr qsort __ctype_toupper_loc memmove strcmp strerror __libc_start_main vfprintf free GLIBC_2.1 GLIBC_2.3 GLIBC_2.0                                                                       ii        ii        ii             #3  $#1  @#4            !  !  !  !  !  !	  !
+  !   !  $!  (!  ,!  0!  4!  8!  <!  @!  D!  H!  L!  P!  T!  X!  \!  `!  d!  h!  l!  p!   t!!  x!"  |!#  !$  !%  !&  !'  !(  !)  !*  !+  !,  !-  !.  !/  US    [  t     r  X[5 %     % h    % h   % h   % !h   %!h    %!h(   %!h0   %!h8   p%!h@   `%!hH   P%!hP   @% !hX   0%$!h`    %(!hh   %,!hp    %0!hx   %4!h   %8!h   %<!h   %@!h   %D!h   %H!h   %L!h   %P!h   p%T!h   `%X!h   P%\!h   @%`!h   0%d!h    %h!h   %l!h    %p!h   %t!h   %x!h  %|!h  %!h  %!h   %!h(  %!h0  %!h8  p%!h@  `%!hH  P%!hP  @%!hX  0%!h`   %!hh  %!hp               1^PTRhhQVhUS=D# u?H#  9s    H# H#9rD#[]t& '    U t    t	$ D$T$ D$T$D$/   $t$\$|$tP   h   8tp
+   \$t$|$t& UWVS,$l$@D$L$%tJt$)}  t(w&    ,1[^_]    }  uwl$\$tD$|$$D$u<;=uv 3    ; tfwt& ; uw{,D;[^_]&    UWVSt& ;t><$C?*t:pD<*tn<$   l$<$N   ;u1[^_]ftt,$<$tt9|)9t5 uFv t$|$,$X)    t$|$,$d8|5  -   [^_]W"VS u[^_t& $    _p@_<.   t*<.ut&         t<.u 1;.D$z$Nt&4$consfFt F [^_v D$|$t/4$datafF  [^_t& H4$if  &    \$\$ t$t$(CS)9|/L$$t$$L$Zs\$t$&    0  CD$$SS  $(  D$$$  \$$D$  D$\$D$$   $H  [t& UWVS<D$P;\$X   D$T1#D$(   tD$g    T$$T$$Fm DM u-<
+tM9|$XvGD$|$  wMl$PD$(    ] D$P{89|$Xv'D$(uF<
+u #<[^_]&    <1[^_]&    '       $   $   $   D$    $y1$   $          D$(D$\$$   uD$T$   D$    \$D$   D$   D$$    $5{tv $#D$   D$   $D$D$$D$D$ D$$#$&    $#D$	   D$   $D$D$$D$D$ D$$#$/&    UWVS   D$x$   $   L$pD$`t$`T$XSCN4J2||$XT$\t& p      etVPWt   t$|   D$pS{D$h     T$l9D$TD$t   |$TfVfw]C{P2DT$X$T$gu/S t(t!<$Q  F9D$trL$t)9v7t& ;t$Ts5D$T"S  v    [^_]t$h;t$TrT$h|$TD$TtD$hs  t$Tl$`T$pE r   9|$l  M   l$lD$`    \$lf9Mt    9s?f9MuEt]9  )N  9}l$`9r&    \$l  l$`  [ ] D$\@"t/D$Xd"qtt$T   &    D$\"BtD$Xd"0D$X"tD$\" #ttEL$h  L$pt$h1L$d1T$`V<T,\|$h T  !t#T$TD$\L$ht$,T$T$dD$$D$`L$L$x\$(T$T$X|$ l$D$T$L$$h|$|	woD$|$D$\D$\T$PD$XT$P\$(t$\$T$$T$Tl$D$$#|$T$ T$D$$d$#$   
+   $      [^_]nf)&    B$T$PD$T$PB<.r<d4l1{L$p D$h1L$dT$`X\$lBD$\D$\\$t$\$D$\D$$#$lD$\D$\L$P{D$\D$XnL$Pt$0T$\t$$t$h\$,L$(L$T\$ D$$#T$|$l$L$t$D$t$D$\D$\L$P D$\D$XL$Pt$0t$$t$\|$|$T\$,L$(D$D$h\$ t$l$D$$#|$D$$vD$\D$XL$PL$PT$T\$0\$(L$L$hT$,D$$#t$$\$ |$l$T$L$D$$D$\*|$|$Tt$\$D$|$D$$#$"t."&    D$$#D$$u$#$
+   D$D$\t$t$T\$ \$|$|$D$$#t$D$$BD$\`L$Tt$\$|$L$D$<D$$#$"`"D$$#D$$u3'    $#D$   D$   $D$D$$D$D$ D$$#$$   c,D$0t,T$4D$$T$xD$,\$t$|$$P   7D$$   14$D$$~D$.   $t&:wuP:xuP:yu  3sCt$3|$\$'    ,$\$t$ |$$l$($hD$$1    rG\$$G/	G\$t$ |$$l$(,t& '    UWVS,$D$T$L$ii#D$8 t11f3CR)uikNAD$190    3T$PT$3P,[^_]t&    $   $   $   $   T$D$*$t5$T$(T$$   D$Fx	D$T;Ct},$AD$D$$m   D$CD$   D$$;C   4$$   $   $   $          $tD$$l$D$   C$T$D$T$;Ct$b4;9u$H,$`fD$$$   UWVSLT$<D$8    T$$m  D$,t& D$<D$D$,D$D$8$_  D$	   <$  p  D$	   4$     h?    {    3u   f   Ct$$uf   d#   C    D$4    l$C|$D$,D$D$4$bD$4D$$*C0   D$C,$D$	$S0L$4C,S0Ko$d	lL[^_]t& @    l$,D$<,$D$L[^_]UWVS,D$.   D$$ai#t6\$1t& 3CR)uikNA90    3u#    tT$C$T$u,[^_]D$XL\$<t$@|$Dl$H"   PtGXECT$,T$,}	U\$<t$@|$Dl$HLt& @PT$, T$,uCT$L$t$D$$	vUqt& mPVfUWVS<T$,D$(    T$$D$      T$t& D$,T$($D$D$D$D$  D$D$	   $hx  P  D$	   $T$DT  x  D$	   <$$t  tD$	   4$t  T$D$$D$   D$$D${    }    D$$8    3u+  v   C|$$u   11t& ,$t t$$uD$11P
+T$P    ,$t t$$:uD$yt`T$@   PB$	v<[^_]    D$      P
+T$PD$uD$    t
+d#   @       L$qUW1V1S1Q   IE    E    lhE    \    X    T    &    D$$hT$l$   I.v$   v $p#   !    @#T`#   5@#|h#   $   D$$>@#PDC   5l#   &!    @#\@#X=@#h#   t   t	1t C13$Hu     #9l		  h}   u #1pt$$  }3Ev8ELFuH ]p0@2<
+9t}  1t&    9rf  tE   USt& d!  EC8EC<E{,xx   u(EF09EV  F2s,t|T1xdus8;u  U7S(	   [X
+   uQ|ExxfE]EC8tEEC<C8EC@DEE-b   u4M|fMxp$@t$+s   u}|f}x   z  U|fUxEF  U9v    9wp6|pEt|d#   @   UE$    }
+  v :Y  P:I  P:9  P:)  |]A   U$u];]]ri  v f  fv R  UBS  }U|$ET$D$|$7  E];]  }1Uu?Bf;Eut$f;Etf;Etf;Et1f;EfUu<   n}w}  p@   D                   s|B    fu
+     u   u|C   u   ~|F   l|AD$]$ \$Gpt!Q  ]uf{0 u=  1E    /v UD2td	  E(C09E  UK22xTu@u "_i  U]D2uU2HxdK2t8;D "xugtd<9rRt& 9vGSECUEEfxwxM$T$pU9w](EC09EUE$    i  +UT$UD$T$p$ZC  D$   |4D$p$E  u}E}fu|ft  EU9  1p    x    d9vKHuMf;Huu
+   0ud=  px9wxd  x$=D$x$|x~0F,19p  p9   CuCf;EuED$
+   D$$utSD$    $LE    D$|AD$LED$,$T$D$E$|B,U=MMED$]$`#|1NrF #9l=3uq  &    ?  Wu_t}Cv VLxL u      Cpt};xtD$/   <$StxUBuVNMLLt  	    WEL$|$$D$!M<1GWxdC2tD "`d<t9t]PB&    f('  f   4Mfy<  9t]  UGE    4sEfux%   DA4uDFvdt)D	  D	  DRUJx%   NuqI)dh  df{E4E%     4EMEfy`$MT$pU]9tP:E|
+jbuC   uQ   URf@	  f+*
+  }?.	  u|J1|Ax4V+Vk4Ed4El#pMpxp$h
+T$zt& t$L$|$$xU}?3  x    uv C|${()T$'U  E    D$4$D$4${D$ 4$kD$ 4$[D$4$KD$ 4$;D$/ 4$+D$4$D$L 4$K  StD$4$D$} 4$D$ 4$P$=PD$C<$D$V  {p    tt]!t& P9Ut#WP@WG?tK_ud#tGup#  UB\$$ D$n?u]`#  =3tt& G G?uD$ 4$D$4$D$ 4$D$4$D$4${tt   ]Gt\PuUX@   D$/   $LLtX u\$D$D$4$'1?u]D$4$\$4$P  {4   Cp	xD$D$E$DU|T   U   11|3tQt& h#tCu6C D$C@D$CD$CD$%<$D$:u   uT|t#t=!   XtXm\  E   ||13Ej  =h#tUrB  MA,4  D$PD$   Q0$T$&][0   1f}G,$3\$^D$|$9_0  <    ]#4$UG;Z0~   u]MA,484$D$t4$nu;^0s`kEL$|$$0D$ SUL$|$$T$3v B,484$u;^0r}G,$G,    E E\|<xeY[^_]aD$ 4$D$X4$
+D$ 4$D$4${u#SC$ D$GD$?t2GtOtGD$GD$ 4$D$?uD$ 4$~rG,4MA\$$ D$Tp   D$f 4$50D$ 4$ C4D$D$4$	D$ 4$U$D$LL   u{,fux  U%ED$4   t$p$(
+|$\$p$
+|$x\$pL$$	D$D$$(lD$$5ES,fEx|:PdD$	   D$gM$cuD$	   D$qu4$@RD$   D${4$ 2D$   D$4$ \<$t& W _V FEX)x    Ip$|$iEEEff$f/\$\$$t$t$ D$ 4$C$D$C 4$D$C t$\$D$ UWVSL\$`D$8t$dT$41L$0   9      |$011),>9   |  tD$01\$D$D$D$4D$D$8D$$#$11l$<D 8D$tD$$#$9w$#$
+   l$<\$,D$D$4$D$D$8D$T$,9=L[^_]CuD$4\$$8D$D$0D$D$4D$D$D$8D$&    '    UWVS,  $H  $@  L$C$t$_+|$|$tdC 1\$l$,$D  D$v |$9|$v=T$>l$D$B$tD$l$D$|$[|$9|$w,  [^_]    D$$D$D$D$($   &    UW1VSD$8 dmi*@ t$41Ft;t6PuuL$8$T$8f:    [^_]T$8$D$D$8T$$L$8$Ul$8V	t/L$4D	v B<]w:tU uE  D$8$T$8f* 7t& D$$D$D$D$($e   &    D$$D$D$D$($5   &    SD$$\$(8 u${f*    [&    $D$D$   [fUWVS,l$@D$9sR   	f9v@tD$$\$D$D$$q9w,[^_]VS\$(t$$inpufCt:C $fb   $VD$T$$$ufv 
+  $^VD$T$$$;fp   $$VD$T$$$fe f  $V
+D$T$$_$-e* ;  $f k*@    $f r*@ @  $uf a*@ >   $Xf m*@ ]  $9f l*@   $f s*@    $f f*@    $f w*@ t   1$   o   [^t& $f* t& $f* t& $lf* fVv $Tf* t&    1$   Et&    1$   t&    1$   t& V|1$   Vt1$?   uTVp1$   ]Vq   $  Bt& V1$   %D$$D$D$D$($   &    D$$@D$D$D$($   t& D$$@D$D$D$($q   t& t$t$$\$\$(|$fD$D$$3$fv ~ty$|$D$$$ffp vt4$Pt$D$$   \$t$|$$f* $f* f&    '    T$$\$t$K1t$< \$t$UWVS,\$Ht$Dpci:C $fv >f  $z|$D$$$[fd ~  $A|$D$$$"f sv@ ~   $|$D$${$f sd@ ~ts$|$D$$@FnVvWvD$w~D$D$@$XD$1,[^_]t& $Tf* $Df* Nt& $,f* fv $f* t& $f bc@ <   $f* $f sc@    $f* $fi |$tz$f* $   |*$df* ,   [^_]t& $DT$D$$Ht& $l$D$$k&    $T$D$$XVS\$$t$({  tS ; uT$D$D$4${@ t-{     @\$T$D$$t5t.v &    tDY t_u4$|*t4$f*    [^v  r&    '    UWVS,  $D  t$,T$$@  L$D$,usb:D$D$0 9!%t     fv   9!%t  i   C$T$D$D$T$/!%t  u fp >  9!%t  3   CT$D$D$$T$9!%t  u fd L$Z  :T$  |$    |$  
+!%t  u fdcB   
+!%t      C
+D$$D$/:!%t  u  dsc m  
+!%t     CD$$D$:!%t  u @fdpB   
+!%t     CD$$D$4
+!%t  u ficB ;   
+!%t  I   CD$$D$
+!%t  u isc   
+!%t  }   CD$$D$<:!%t  u fipB 7  !%t  V   f* !%t  u )|+*t$f* $H  t$D$| $,  [^_]&    /!%t     f* )t& !%t     f* !%t  u f* 
+t& :!%t  '   f* X:!%t     f* 
+!%t     f* 
+!%t  _   f* <:!%t     f* 
+!%t  u CD$$D$9!%t  u D$T$D$D$D$$D$.T$:T$Sv 9!%t     T$D$$t& 9!%t  u D$T$D$D$$ f* v  f* +v t&  f* v t&  f* v t&  f* v xt&  f* v t&  f* v t&  f* 3v t& Pt& WVS\$(t$$virtCio: $fd >   $x|$D$$$Yfv vtO$Ct$D$$$$|*t$f*    [^_t& $f* $f* xt& WVS\$(t$$ssb:C $fv >f   $|$D$$$wf id@ ~f   $R|$D$$$3rev v<tV$   t$D$$$|*t$f*    [^_    $f* $f* nt& $f* ft& '    WVS\$(t$$sdiofC: $bfc ><   $   A|$D$$$"fv ~f   $|$D$$|$fd vftP$t$D$$B$|*t$f*    [^_v $|f* $lf* fsv $Tf* t& WVS\$(t$$pariCsc: $!ft ><R  $    |$D$$y$f hv@ ~f   $|$D$$5$rev ~<   $   z|$D$$$[f sv@ vtK$?t$D$$$ |*t$f*    [^_$f* $f* vt& $f* fv $f* t& VS\$(t$$pcmcCia: $fm   $kVD$T$$$Hfc u  $1VD$T$$$ff #  $VD$T$$l$f fn@   $VD$T$$,$pfn Fw  ${VD$T$$$Xf pa@   $;VD$T$$$f pb@     $VD$T$$r$f pc@ @t}$VD$T$$7$f pd@ >    $f* $t|*t$cf*    [^    $Df* $4f* Gt& $f* fv $f* t& $f* fCv $f* t& $f* fv $f* It& $VD$T$$'    WVS\$(t$$serifCo:C $>f ty@ ><a  $   |$D$$$f pr@ ~<  $   |$D$$I$f id@ ~<   $   |$D$$$jf ex@ v<tP$   Ft$D$$$'|*t$f*    [^_$f* $f* fmv $f* t& $f* ft& '    VS\$(t$$ccw:C $ft   $nVD$T$$$Kfm    $4VD$T$$$f dt@ tt$VD$T$$m$f dm@ ux$f* $|*t$f*    [^$f* $tf* Pt& $\f* fv $DVD$T$$nVS\$(t$$ieeeC1394fC: $ven   $VD$T$$Z$f mo@    $VD$T$$$f sp@ tn$jVD$T$$$Hver ux$4f* $&|*t$f*    [^$f* $f* fTv $f* t& $VD$T$$2o'    VSD$$t$(x  tP 8 uT$D$D$4$t2t+    tDY t_u4$|*t4$f*    [^v UWVSL\$hT$dt$lCf   zf;G0s{B@Y  {xD$(    D$4$tM4$|  u>D$`   SD$p$/D$D$($ L[^_]t& D$34$  4$"|    T$`[BJ|$$   \$$t|$D$     t& L$1qYftQtD$HD$x ux
+ ufufv    f9   	v	      9L$uN   ft$<	uq9   	v	   9t$      tL$`$D$ZD$	   L$t$<	tT$`   D$|$$    T$T$9dfD$ L$ D$9L$$+v L$`   $D$|$L$v C$   D$yD$(fN<u;i,tVD$`   SD$ $D$"S   \$`D$P$e\$jt+L$`SD$$L$   /t+S   \$`D$ $\$Pt+D$`   SD$$D$Ft+L$`SD$$L$   ~t+S   \$`D$$\$C   K1   1T$`\$8D$B0|$$   L$` L$9l$D$|$D$4$C114uT$\$D$O$l:  K1L   \$`0D$,C |$$L   \\$$|$ D$    |$L$9L$,"D$    T$L$ x x   \$tI11    kL1t$&    x PtT$<$Ttgu9l$w\$$|$D$4$11L8uT$$D$8D$D$O$D$|$3D$D$ Lt+S4   \$`D$$\$_t+D$`   SD$p$D$U$t+L$`SD$$L$@   t+S   \$`D$P$\$Rt+D$`   SD$$D$st+L$`SD$$3L$   i:8t+S   \$`D$$R\$.Wt+D$`   SD$P$nD$frt+L$`SD$p$L$   +t+S   \$`D$`$\$}Lt+D$`$   SD$0$D$Bt+L$`SD$0$L$L  zfS   \$`D$ $ \$;UWVS@X
+0xL$<#H!	r!t$8p4$!	j4$<$l$4!!	j<$$l$0!!	j$$l$,!!	j$4$l$(!!	j4$l$$<$!!	j<$$l$ !!	j $$l$!!	j$$4$l$!!	j(4$<$l$!!	j,<$$l$!!	j0$$l$!!	j4$4$l$!!	j84$R<<$l$!!	<$$!!	T$<yZ	!	,L$,	!yZ!	T$yZ	!!	T$!yZ	!	\$8yZ	!!	l$(	!.yZ!	l$)yZ	!!	l$*yZ	!!	T$4!yZ	!	l$$+yZ	!!	l$)yZ	!!	L$!yZ	!	l$0*yZ	!!	l$ +yZ	!!	t$!7yZ	!	,$47)yZ	!!	l$<*nl$11T$n11\$,n11)nl$11t$47n1147*nl$$11+nl$11)nl$811.nl$1147*nl$(11+nl$11)nl$011.nl$1147*nl$ 11+n,$11)n1010HXP@[^_]U	   WVS<D$P\$TT$\D$ T$(y  $D$D$,S	$Z  S
+
+   T$T$D$$(3DU uD$,L$$|)|$M}  T$$
+DA i  Ct& DQ u	u$f4$)|$D$D$ D$   $   D$(D$    4$D$   $
+\$4$D$G$9t'a $T$ $T$D$+t$P<[^_]v <[^_]:	   fv  $=T$($T$D$D$ D$&     $T$ D$PT$TD$X<[^_]v '    VpTSXP? ?XPpTu2p1&    @u[^7&    T[^    UWVS  $  $  D$/   4$tX$l\$\$C|$D$$D$$  D$$D$<  D$
+   $\  XD$
+   $,    $D  #Eg$H  $L  $P  vT2$      $      6      D$    $D$$t
+  D$$;   $q|."  $$      S$D$$4D$/   $D$4}  D$D$4)\$t$D$($F$jD$4$t$\$D$,$D$,0 $  D$D$4$D$(*  1t& $  D$D$(D$$  $   a      t$H|\   t1T$ T$     tDQ t  D$,$D$eD$,$D$/   $UT79     +v    $  D$D$($D$,$DD$4$8  \$$$  $T  ?8  $D  L$D$    4$$  $  $  $  $  $  &    9uJ$D  $D  $H  D$$  $L  $P  D$$  $H  $L  $P  \$L$T$D$~$$  D$D$<$  [^_]    |a$  D$$}D$8   $  D$0   1ifT$ T$  DH uC"   /uD$8<8*   $  $D  $  $  D$09\$0v0t$8}\u;|$0sD$8]<8
+q9\$0wD$0   D$D$8$D$0$     $  ")$D  w!$  D$0l|\u9v$  $  $D  <"uD$0   )wt& 9v|*u</uD$41\$D$,$   D$4\$$GD$D$,$D$4$@D$D$    $$  9u$D  k8   p $\$1$gD$<t$$'Jt$$5U]t& '    UWVSO   =$  )t$1ED$ED$E$9r[^_]$US  t  fu[]US    [#  |Y[                             vmlinux vmlinux.o rodata ERROR:  WARNING:  (unknown) atd __param (unknown reference) %s,  FATAL:  malloc(sizeof(*mod)) strdup(modname) malloc(b->pos) line .ko malloc(sizeof(*extsym_iter)) i:I:e:cmsSo:awM:K: .modinfo %s has NOBITS .modinfo
+ __ksymtab __ksymtab_unused __ksymtab_gpl __ksymtab_unused_gpl __ksymtab_gpl_future __markers_strings %s has no symtab?
+ license GPL v2 GPL and additional rights Dual BSD/GPL Dual MIT/GPL Dual MPL/GPL "%s" [%s] is COMMON symbol
+ __crc_ __this_module _GLOBAL_OFFSET_TABLE_ _restgpr_ _savegpr_ _rest32gpr_ _save32gpr_ __ksymtab_ init_module cleanup_module version __mstrtab_ module_layout #include <linux/module.h>
+ #include <linux/vermagic.h>
+ #include <linux/compiler.h>
+ struct module __this_module
+  .name = KBUILD_MODNAME,
+  .init = init_module,
+  .arch = MODULE_ARCH_INIT,
+ };
+ 
+MODULE_INFO(staging, "Y");
+ "%s" [%s.ko] undefined!
+ __used
+ "%s" [%s.ko] has no CRC!
+ 	{ %#8x, "%s" },
+ "depends= , %s%s ";
+ %s.mod.c 0x%08x	%s	%s	%s
+ .text$ .init.* .devinit.* .cpuinit.* .meminit.* .data.rel$ .exit.* .devexit.* .cpuexit.* .memexit.* __ksymtab* EXPORT_SYMBOL EXPORT_UNUSED_SYMBOL EXPORT_SYMBOL_GPL EXPORT_UNUSED_SYMBOL_GPL EXPORT_SYMBOL_GPL_FUTURE .comment* .debug* .mdebug* .pdr .stab* .note* .got* .toc* .init.setup$ .init.rodata$ .devinit.rodata$ .cpuinit.rodata$ .meminit.rodata$.init.data$ .devinit.data$ .cpuinit.data$ .meminit.data$ *driver *_template *_timer *_sht *_ops *_probe *_probe_one *_console .head.text* __init_begin _sinittext _einittext drivers/staging variable function ()    %s(%s+0x%llx): Section mismatch in reference from the %s %s%s to the %s %s:%s%s
+    The function %s%s() references
+the %s %s%s%s.
+This is often because %s lacks a %s
+annotation or the annotation of %s is wrong.
+ The variable %s references
+the %s %s%s%s
+If the reference is valid then annotate the
+variable with __init* or __refdata (see linux/init.h) or name the variable:
+   The function %s() references a %s in an exit section.
+Often the %s %s%s has valid usage outside the exit section
+and the fix is to remove the %sannotation of %s.
+  The variable %s references
+the %s %s%s%s
+If the reference is valid then annotate the
+variable with __exit* (see linux/init.h) or name the variable:
+    The %s %s%s%s references
+a %s %s%s%s.
+If %s is only used by %s then
+annotate %s with a matching annotation.
+    The %s %s%s%s references
+a %s %s%s%s.
+This is often seen when error handling in the init function
+uses functionality in the exit path.
+The fix is often to remove the %sannotation of
+%s%s so it may be used outside an exit section.
+  The %s %s%s%s references
+a %s %s%s%s.
+This is often seen when error handling in the exit function
+uses functionality in the init path.
+The fix is often to remove the %sannotation of
+%s%s so it may be used outside an init section.
+  The symbol %s is exported and annotated %s
+Fix this by removing the %sannotation of %s or drop the export.
+ modpost: Memory allocation failure: %s.
+    malloc(sizeof(*s) + strlen(name) + 1)   realloc(mod->markers, ((mod->nmarkers + 1) * sizeof mod->markers[0]))   parse error in markers list file
+   %s: '%s' exported twice. Previous export was in %s%s
+   parse error in symbol dump file
+    section header offset=%lu in file '%s' is bigger than filesize=%lu
+ %s is truncated. sechdrs[i].sh_offset=%lu > sizeof(*hrd)=%zu
+   modpost: missing MODULE_LICENSE() in %s
+see include/linux/module.h for more information
+    %s (%s): unexpected non-allocatable section.
+Did you forget to use "ax"/"aw" in a .S file?
+Note that for example <linux/init.h> contains
+section definitions for use in .S files.
+
+ malloc(sizeof mod->markers[0] * n)  modpost: GPL-incompatible module %s%s uses GPL-only symbol '%s'
+    modpost: GPL-incompatible module %s%s uses GPL-only symbol marked UNUSED '%s'
+  modpost: GPL-incompatible module %s%s uses future GPL-only symbol '%s'
+ modpost: module %s%s uses symbol '%s' marked UNUSED
+    MODULE_INFO(vermagic, VERMAGIC_STRING);
+    __attribute__((section(".gnu.linkonce.this_module"))) = {
+  #ifdef CONFIG_MODULE_UNLOAD
+ .exit = cleanup_module,
+#endif
+    static const struct modversion_info ____versions[]
+ __attribute__((section("__versions"))) = {
+ static const char __module_depends[]
+   __attribute__((section(".modinfo"))) =
+ MODULE_INFO(srcversion, "%s");
+ modpost: Found %d section mismatch(es).
+To see full details build your kernel with:
+'make CONFIG_DEBUG_SECTION_MISMATCH=y'
+                              G}Bi2i!iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii                            6                                                                            =EP[                                                                   f                                                                        =EP[                                                                   6                                                                            qy                                                                   f                                                                        qy                                                                   EP[                                                                    =                                                                               [                                                                            P                                                                               P                                                                            [                                                                               y                                                                    q                                                                                                                                                                                                                                                                                                                                                                                                     =EP[                                                                qy                                                                   qy                                                                =EP[                                                                                                                                               =q                                                                        	                                  @PY bPY b0x%02x  MODULE_ALIAS("%s");
+ platform:%s :%s* spi:%s i2c:%s eisa:s%s* %X,* acpi*:%s:* css:t%01X ap:t%02X* hid:b%04X %02X of:N%sT%s %sC%s %0*X %u [%u-%u] vio:T%sS%s __mod_pci_device_table pci __mod_usb_device_table usb __mod_hid_device_table hid __mod_ieee1394_device_table ieee1394 __mod_ccw_device_table ccw __mod_ap_device_table ap __mod_css_device_table css __mod_serio_device_table serio __mod_acpi_device_table acpi __mod_pnp_device_table pnp MODULE_ALIAS("pnp:d%s*");
+ MODULE_ALIAS("acpi*:%s:*");
+ __mod_pnp_card_device_table __mod_pcmcia_device_table pcmcia __mod_of_device_table of __mod_vio_device_table vio __mod_input_device_table input __mod_eisa_device_table eisa __mod_parisc_device_table parisc __mod_sdio_device_table sdio __mod_ssb_device_table ssb __mod_virtio_device_table virtio __mod_i2c_device_table i2c __mod_spi_device_table spi __mod_dmi_device_table dmi __mod_platform_device_table platform bvn bvr bd svn pn pvr rvn rn rvr cvn ct cvr    %s: sizeof(struct %s_device_id)=%lu is not a modulo of the size of section __mod_%s_device_table=%lu.
+Fix definition of struct %s_device_id in mod_devicetable.h
+   %s: struct %s_device_id is %lu bytes.  The last of %lu is:
+ %s: struct %s_device_id is not terminated with a NULL entry!
+   Can't handle masks in %s:%04X
+          	                  	   #
+   &   *   .   1           $Revision writing sum in %s failed: %s
+ MODVERDIR . %s/%.*s.mod %.*s.%s.cmd malloc(dirlen + 1) could not find %s for %s
+ deps_ could not open %s: %s
+ %08X%08X%08X%08X  changing sum in %s failed: %s
+  changing sum in %s:%lu failed: %s
+  malformed versions file for %s
+ bad ending versions file for %s
+    malloc(strlen(objfile) + sizeof("..cmd"))                                                                                                                                                                                                                    T   ,   lo   `   
+                         x                           o|o   o                                                             
+*:JZjz
+*:JZjz
+*:JZjz                                                                              ',3:@                                FSar    f                    =EP[qy                                        =EP[    *5    GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll  p               D   o     4                N           P              V         ``                   ^   o     j                k   o   ||  @                z   	                            	        x                       TT
+  0                           
+                              o                          ,,}                             ``}  !                           DD                                                                                                                                                                                                               !  P                            #                           0         8                               H                                    P     q         	              8  	                                               (          H          l                              `                    |     	          
+               T                              ,          `          D                                                                             !           #                                                     (          5         K   D#     Z   H#     h                      t             D                                         P        pk                               "$       #           0  "$     B  @"$     U  d"     c  "     q  "        #       T       \       !       t#       d       l       P       3                     3       @q    )      6       B  `     S  @    ]   0     i  p#     y  !       h#       l#        "$       P                  b      P        (       0       h     #  0(     0  `(     =  N     K  o     T  Pp    c  (     q  ,     ~   ,       P       0?       p      p       `	      p       PE      ;            7                +       =       J           W  1    e  Z     j                                                   !                                              	                          -       =             N       \        c       m              |                `                    0]	                                             ,                                !             2             D  T    Q             n               `#                    d                                  #       !        @I                    d#     )  P     9             K             ]  $#     o                                                      !                                   Z       p                 #             5             H             Z  #     f             x               @P                    C                                                                      	  o     	             +	  @#     =	             N	  #     U	             i	  C     u	  Q     {	             	  I     	             	             	       	   0     	  6    	      	  T       crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux modpost.c compare_strings is_vmlinux get_next_modinfo match sec2annotation init_exit_sections line.5372 check_section_mismatch symbol_white_list init_data_sections data_sections head_sections init_sections linker_symbols CSWTCH.158 CSWTCH.159 sec_mismatch_verbose sec_mismatch_count CSWTCH.161 CSWTCH.162 new_module modules alloc_symbol new_symbol symbolhash write_if_changed read_markers find_symbol sym_add_exported read_dump export_list warn_unresolved vmlinux_section_warnings external_module all_versions section_white_list staging_dir.7259 file2alias.c device_id_check do_table do_platform_entry do_dmi_entry dmi_fields do_spi_entry do_i2c_entry do_eisa_entry do_input do_input_entry do_acpi_entry do_css_entry do_ap_entry do_hid_entry sym_is do_pci_entry do_of_entry do_usb_entry do_virtio_entry do_ssb_entry do_sdio_entry do_parisc_entry do_pcmcia_entry do_serio_entry do_ccw_entry do_ieee1394_entry do_vio_entry sumversion.c md4_transform T.92 _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC fileno@@GLIBC_2.0 data_start __errno_location@@GLIBC_2.0 sprintf@@GLIBC_2.0 open@@GLIBC_2.0 mmap@@GLIBC_2.0 strerror@@GLIBC_2.0 __libc_csu_fini qsort@@GLIBC_2.0 get_next_line _start grab_file __gmon_start__ _Jv_RegisterClasses _fp_hw realloc@@GLIBC_2.0 handle_moddevtable strchr@@GLIBC_2.0 vsnprintf@@GLIBC_2.0 getenv@@GLIBC_2.0 _fini calloc@@GLIBC_2.0 strncpy@@GLIBC_2.0 write@@GLIBC_2.0 memset@@GLIBC_2.0 sectioncheck __libc_start_main@@GLIBC_2.0 strrchr@@GLIBC_2.0 modversions perror@@GLIBC_2.0 _IO_stdin_used __ctype_toupper_loc@@GLIBC_2.3 free@@GLIBC_2.0 optind@@GLIBC_2.0 __data_start merror __ctype_b_loc@@GLIBC_2.3 have_vmlinux add_moddevtable fclose@@GLIBC_2.1 getopt@@GLIBC_2.0 stderr@@GLIBC_2.0 strtoul@@GLIBC_2.0 strlen@@GLIBC_2.0 fopen@@GLIBC_2.1 asprintf@@GLIBC_2.0 __dso_handle release_file strcpy@@GLIBC_2.0 __DTOR_END__ __libc_csu_init get_src_version close@@GLIBC_2.0 fwrite@@GLIBC_2.0 fprintf@@GLIBC_2.0 strstr@@GLIBC_2.0 __bss_start malloc@@GLIBC_2.0 fputc@@GLIBC_2.0 buf_printf memmove@@GLIBC_2.0 _end __rawmemchr@@GLIBC_2.1 __fxstat@@GLIBC_2.0 strncmp@@GLIBC_2.0 vfprintf@@GLIBC_2.0 lseek@@GLIBC_2.0 buf_write munmap@@GLIBC_2.0 optarg@@GLIBC_2.0 fread@@GLIBC_2.0 _edata snprintf@@GLIBC_2.0 cross_build fatal strcmp@@GLIBC_2.0 warn __strdup@@GLIBC_2.0 exit@@GLIBC_2.0 __i686.get_pc_thunk.bx do_nofail maybe_frob_rcs_version main _init 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/scripts/pnmtologo /usr/src/linux/scripts/pnmtologo
--- /home/jara/linux-2.6.32/scripts/pnmtologo	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/pnmtologo	2014-06-14 14:24:12.000000000 -0300
@@ -0,0 +1,55 @@
+ELF              4   d"      4    (      4   44                                                         <  h                             (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU Uv 8J1'].t                                                       	                                                   
+                                               e         )K82                A                                                         n              `              R              .              ;                                          g                            )              Y   `                D        d     4   @     |         __gmon_start__ libc.so.6 _IO_stdin_used exit fopen optind fgetc __errno_location getopt stdout fclose malloc __ctype_b_loc optarg stderr fwrite opterr strerror __libc_start_main vfprintf GLIBC_2.1 GLIBC_2.3 GLIBC_2.0                                    ii         ii         ii            @  D  `  d                     	  
+       $  (  US    [`  t>       X[5%    %h    %h   %h   % h   %h    %h(   %h0   %h8   p%h@   `%hH   P%hP   @% hX   0%$h`    %(hh       1^PTRh hQVh +US= u?9s    9r[]t& '    Ut    t	$D$$D$D$ D$D$$    t& UWVSt& 4 T 0 t;<$te#u&    <$dtJ
+u   t& 1&t& <$t& 7ttSU Bu[^_]$D$"fSE)1[&    '    X  D$$J  D$D$   D$   $D$   D$   $D$jD$   D$   $D$ED$D$$7D$   D$   $D$4D$D$$D$   D$   $-D$D$   D$   $D$4D$D$$t& ` $$D$D$QS*d)R9uXu,\$D$>$d[t& \$D$<$d[\$D$3$d[&    D$   D$   $FD$d4D$D$$V8D$L`D$$1D$[D$$D$kD$$=8t`4D$D$$D$   D$   $GD$t$Cv `D$|D$$n4D$D$$P_UWVST]d    ED$\$$   ntcv ~ov tFtv t$8D$   u38   &    y4i   t    u 8   98   )   N8   t& E;@(D$$
+  $Pu$1D$L}$D$3~6$D$$c	  1t3t& @$T=/	  ;5r|$L2  |$L3	  = tnD$D    \$HtC\$D11\$Lt& T$LD$H,CC;5rD$DL$D;r\$H$@8    $    v    uD$L1T$D\$H;D$Lv  T$D  T$H1y:Yt$#8u\$H1T$D\$@95  YA\$H:Au8u=    D$<    D$4       D$H    D$D    L$8&    `d  T$8t$<D$H21H8L$L@D$@t& 9s#XH\$0:u8L$LuL$@8L$0u9  D$DD$DD$H;qD$4T$4D$<;(= D$8          D$8D$D    D$H    D$<t& `    tdt$<0D$DP8T$L@1D$@v 9s#XH\$48u:L$LuL$@8L$4uB D$H\$HD$D;nD$8t$8;5,D$   D$   $FD$4D$(D$$=` d    t31t& -C$C;5`r       +  t$8R\$<t$H1fL1`13= D$D    D$HN\$L   t$D11t& T$H0D$LL$,L$,T$H0D$LL$,iL$,AT$H0D$LL$,DL$,A;=rD$Dt$D;5Z\$L`= D$@    D$D{\$HtB\$@11\$LfT$LT$DD$HCC;=rD$@L$@;rt$@T$Dt$H]T$8   D$<    L$@\$4|$@tyD$<T$4D$H    <fO1L$LGD$Df  XH\$0:u:L$LuL$D8L$0uD$H\$@9\$HrD$<t$89t$<l= gD$0    \$@t$@  L$0D$D    D$L    L$4    t$40D$<D$DP0T$H@1D$8t& t#HXL$8u:\$Hu\$8\$8uD$L;D$@sZ\$<t$DD3X0\$H@D$@1v t#QYT$<8u:\$Hu\$@8\$<u	^5D$LD$LD$Dt$@9D$0T$0;t& $hd5t$H   =D$L    D$DtaT$LL$D1fXpu!ut/&    $	t& uuu&    9rD$Lt$H9t$Lr= UD$H    tjD$H1D$L    19sBv1L$L
+1&    9s>8 t	u9wD$Ht$H;5rv D$   $\ $b$D$= $C$D$D$19J= t7    118T$,+T$,;5rU]t& '    UWVSO     S)t$1ED$ED$E$9r[^_]$US t fu[]US    [@  Y[             %s: end of file
+ w Cannot create file %s: %s
+ /*
+  *  DO NOT EDIT THIS FILE!
+  *
+  *  Linux logo %s
+  */
+
+ , 0x%02x ,
+	0x%02x 
+};
+
+ 	.type		= %s,
+ 	.width		= %d,
+ 	.height		= %d,
+ 	.clutsize	= %d,
+ 	.clut		= %s_clut,
+ 	.data		= %s_data
+ hn:o:t: mono vga16 clut224 gray256 r Cannot open file %s: %s
+ %s is not a PNM file
+ Image must be monochrome
+ Image must be grayscale
+ linux_logo LINUX_LOGO_MONO LINUX_LOGO_VGA16 LINUX_LOGO_CLUT224 LINUX_LOGO_GRAY256    *  It was automatically generated from %s
+ #include <linux/linux_logo.h>
+
+ static unsigned char %s_data[] __initdata = {
+  const struct linux_logo %s __initconst = {
+ 
+Usage: %s [options] <filename>
+
+Valid options:
+    -h          : display this usage information
+    -n <name>   : specify logo name (default: linux_logo)
+    -o <output> : output to file <output> instead of stdout
+    -t <type>   : specify logo type, one of
+                      mono    : monochrome black/white
+                      vga16   : 16 colors VGA text palette
+                      clut224 : 224 colors (default)
+                      gray256 : 256 levels grayscale
+
+    %s: Binary PNM is not supported
+Use pnmnoraw(1) to convert it to ASCII PNM
+ Image must use the 16 console colors only
+Use ppmquant(1) -map clut_vga16.ppm to reduce the number of colors
+   Image has more than %d colors
+Use ppmquant(1) to reduce the number of colors
+   static unsigned char %s_clut[] __initdata = {
+              GWh{                       U UUUUUUUUUUUU                                                                                                                                                                                                                                                                                                                                                                     |      lo      H
+                         p                  0         oo   or                                                            "2BRbr        <   GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll                  D   o     <                N         HH  P              V                             ^   o   rr  *                k   o     @                z   	        0                   	        p                        ||  0                                                                                                                                                                                                                                                                                                                                  D                          ,,!                             @<!  (                        0       <!  8                               t!                                  '  P     A         	              d-                                                 (          H          l                    H                    r               	          
+               |                                                                                                                         ,          @                                                   (         5         K        Z        h   0                  t                              p                     `,                        @"        p                       4              d        Q    -  8     7  `     B       M       Y  `     g       s       }        0                                       ,                                                  '              6              J       Q        W             t         @       ,                                               D                    0                          -  Z     =             O             b  <     n               h       `       d                           <                    j              |       crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux pnmtologo.c die get_number filename get_number255 write_header outputname out logoname write_hex write_hex_cnt write_footer logo_type logo_types logo_width logo_height logo_clutsize programname logo_data logo_clut clut_vga16 _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC data_start __errno_location@@GLIBC_2.0 strerror@@GLIBC_2.0 __libc_csu_fini _start __gmon_start__ _Jv_RegisterClasses _fp_hw _fini __libc_start_main@@GLIBC_2.0 _IO_stdin_used optind@@GLIBC_2.0 __data_start __ctype_b_loc@@GLIBC_2.3 fclose@@GLIBC_2.1 getopt@@GLIBC_2.0 stderr@@GLIBC_2.0 fopen@@GLIBC_2.1 __dso_handle fgetc@@GLIBC_2.0 __DTOR_END__ __libc_csu_init fwrite@@GLIBC_2.0 fprintf@@GLIBC_2.0 __bss_start malloc@@GLIBC_2.0 _end stdout@@GLIBC_2.0 opterr@@GLIBC_2.0 vfprintf@@GLIBC_2.0 optarg@@GLIBC_2.0 _edata exit@@GLIBC_2.0 __i686.get_pc_thunk.bx main _init 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/scripts/selinux/mdp/mdp /usr/src/linux/scripts/selinux/mdp/mdp
--- /home/jara/linux-2.6.32/scripts/selinux/mdp/mdp	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/scripts/selinux/mdp/mdp	2013-02-23 06:16:30.000000000 -0300
@@ -0,0 +1,53 @@
+ELF               4   0-      4    (      4   44                                                                                        (  ((D   D         Qtd                          /lib/ld-linux.so.2           GNU                       GNU 6(Fues8'fXm      
+                                              	                                K                               U              4              d              G              .              ]              N              \              A              <              )                 d      __gmon_start__ libc.so.6 _IO_stdin_used exit fopen strncpy puts fputc fclose fwrite strchr fprintf __libc_start_main GLIBC_2.1 GLIBC_2.0                               ii   v      ii                             	  
+       US    [  t   q  	  X[5%    %h    %h   %h   % h   %h    %h(   %h0   %h8   p%h@   `%hH   P%hP   @% hX   0        1^PTRhhQVhGUS= u?9s    9r[]t& '    Ut    t	$D$$h$   	UWVS   U~ZE  UZ:  S:  S:  EUD$$   ZUeUED$$    Z@D$$D$ D$,     t$,v D$D$4$Mt' u\$D$)4$MuD$,$
+   D$t$,`D$74$D$uT$,0$
+   T$t$,HD$_   $L$D$_   x<$L$    )d  )d  D$;T$T$|$$T$D; T$;$    T$D$Z4$L t*   D$D$g4$L8ut$D$   D$   $lw D$,   $
+   D$ut&     T$,1D$D$$7t$,	!t,9<`udD$p4$D$!u11t& =   t9:uv  =   ue  D$,$
+   D$M6D$,$
+   D$|$$ 
+  T$,   D$   D$   $T$>D$,D$   D$   $D$t$, t& D$D$4$	Mt' u\$D$4$MuT$,D$   D$   $T$D$,$
+   D$t$,`D$4$D$uT$,$
+   T$xD$,D$(   D$   $D$4T$,D$(   D$   $@T$D$,D$'   D$   $lD$T$,D$'   D$   $T$D$,D$,   D$   $D$T$,D$)   D$   $T$D$,D$)   D$   $D$\T$,D$*   D$   $DT$8D$,D$)   D$   $pD$T$,D$'   D$   $T$D$,D$%   D$   $D$T$,$D$ D$$"  \$D$   D$   $\$D$   D$   $b$*   1[^_]v T$,L$D$   D$   T$$dL$[|$(41v D$gD$D$,$9||$(T$,D$   D$   T$$lMXD$$    v ZUD$$    ZGT$ $T$\Uz$}$   $?i$   m\$$U+U]t& '    UWVSO   -  /)t$1ED$ED$E$9r[^_]$US t fu[]US    [  Y[             usage: %s [-m] policy_file context_file
+    Could not open %s for writing
+  role base_r types { base_t };
+  allow base_t base_t:user%d *;
+  user user_u roles { base_r };
+  fs_use_xattr ext2 user_u:base_r:base_t;
+    fs_use_xattr ext3 user_u:base_r:base_t;
+    fs_use_xattr jfs user_u:base_r:base_t;
+ fs_use_xattr xfs user_u:base_r:base_t;
+ fs_use_xattr reiserfs user_u:base_r:base_t;
+    fs_use_task pipefs user_u:base_r:base_t;
+   fs_use_task sockfs user_u:base_r:base_t;
+   fs_use_trans devpts user_u:base_r:base_t;
+  fs_use_trans tmpfs user_u:base_r:base_t;
+   fs_use_trans shm user_u:base_r:base_t;
+ genfscon proc / user_u:base_r:base_t
+   Wrote policy, but cannot open %s for writing
+   -m class %s
+ class user%d
+ sid %s
+ Error with commons defines common %s
+{
+ 	%s
+ }
+
+ inherits %s
+ MLS not yet implemented type base_t;
+ allow base_t base_t:%s *;
+ sid %s user_u:base_r:base_t
+ / user_u:base_r:base_t
+ /.* user_u:base_r:base_t
+ ioctl getattr setattr relabelfrom relabelto append unlink rename execute swapon quotaon mounton listen accept getopt setopt shutdown recvfrom sendto recv_msg send_msg name_bind destroy associate unix_read unix_write common_file_perm_to_string common_socket_perm_to_string common_ipc_perm_to_string ipc remount unmount quotamod quotaget add_name remove_name reparent rmdir open execute_no_trans entrypoint execmod use connectto newconn acceptfrom node_bind name_connect tcp_recv tcp_send udp_recv udp_send rawip_recv rawip_send enforce_dest dccp_recv dccp_send ingress egress fork sigchld sigkill sigstop signull signal getsched setsched getsession getpgid setpgid getcap setcap share setexec setfscreate noatsecure siginh setrlimit rlimitinh dyntransition setcurrent execmem execstack execheap setkeycreate setsockcreate enqueue receive compute_av compute_create compute_member check_context load_policy compute_relabel compute_user setenforce setbool setsecparam setcheckreqprot ipc_info syslog_read syslog_mod syslog_console module_request chown dac_override dac_read_search fowner fsetid setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin nlmsg_read nlmsg_write nlmsg_relay nlmsg_readpriv nlmsg_tty_audit setcontext polmatch flow_in flow_out forward_in forward_out view mmap_zero use_as_override create_files_as security process capability filesystem fd lnk_file chr_file blk_file sock_file fifo_file tcp_socket udp_socket rawip_socket node netif netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket sem msgq shm netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket association netlink_kobject_uevent_socket appletalk_socket key dccp_socket memprotect peer capability2 kernel_service tun_socket unlabeled file_labels init any_socket port netmsg igmp_packet icmp_socket sysctl_modprobe sysctl sysctl_fs sysctl_kernel sysctl_net sysctl_net_unix sysctl_vm sysctl_dev kmod scmp_packet devnull                             "+B3>l}ILU^gq{7                                                    0G\p                                                      ,;                l"FlP\alqx{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <   lo      
+                         `                           o`o   oB                                                            >N^n~                                                            e#/9@BGNV]e                            e#/9mt{        e    `     l   l	   l
+   l   l   l   l                           K      7   7   7   7+   ,   -   .   /   0   1   2   3   7   8   <                                 =      ;      C            #       /   @               K      T      ]      f      r      ;       {     @                         
+      
+      
+      
+                                   @                              @      @                                         @         )      3                                                    @   )      3      =      E     @                   L            Q      Y      a       i   @   q            x                                   @                                                  @                                     '       4      B      8      J            R      ]      l      {                @                                                                     %      2      B      I       \   @   P      W      ^      f      v                       @                                                  @                         !      0      6       <      @H      VE      ^E      k+     @ u+      ,     @ u,      -     @ u-      /     @ u/      1     @ u1      1      1      1      2     @ u2      6      6      6      6      9      89      .9      /9      9      9       9   @   :      :      :      :      ;:      B:       :   @   e<     @ <      =      D      .J      J      GCC: (Debian 4.4.7-2) 4.4.7 GCC: (Debian 4.4.7-3) 4.4.7  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment                                                                        #         ((                     1         HH  $                  H         ll  L                D   o                      N                          V                             ^   o   BB                  k   o   ``  0                z   	                           	        `                          0                           ((                                <	                          <<                             ``  p                                                                                                                                                                                                                <                          @@!  
+                           ,                          0       ,  8                               @,                                  1  0     0         	              7  ,                                               (          H          l                                        B          `     	          
+                         (                     <          `                                                                                 @                                                             (         5   0      K        Z        h                     t                                                            4       `p                                          @       +  `    6       F         M              \              p  `     w               <                     H                    `H        (       d     
+  @                   )             :      C  D     P       ]  Z     m                                                                                 \                         
+  
+     !      &         crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.5986 dtor_idx.5988 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux mdp.c usage classlist initial_sid_to_string _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC data_start av_inherit __libc_csu_fini _start __gmon_start__ _Jv_RegisterClasses _fp_hw strchr@@GLIBC_2.0 _fini strncpy@@GLIBC_2.0 common __libc_start_main@@GLIBC_2.0 common_file_perm_to_string common_ipc_perm_to_string _IO_stdin_used __data_start fclose@@GLIBC_2.1 fopen@@GLIBC_2.1 av_perms __dso_handle __DTOR_END__ __libc_csu_init printf@@GLIBC_2.0 fwrite@@GLIBC_2.0 fprintf@@GLIBC_2.0 __bss_start fputc@@GLIBC_2.0 _end puts@@GLIBC_2.0 common_socket_perm_to_string _edata exit@@GLIBC_2.0 __i686.get_pc_thunk.bx main _init 
\ No newline at end of file
diff -Naur /home/jara/linux-2.6.32/.version /usr/src/linux/.version
--- /home/jara/linux-2.6.32/.version	1969-12-31 21:00:00.000000000 -0300
+++ /usr/src/linux/.version	2015-03-18 09:09:31.000000000 -0300
@@ -0,0 +1 @@
+703
